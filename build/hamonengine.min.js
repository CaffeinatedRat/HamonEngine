/*
 Hamonengine 波紋
 Copyright (c) 2020, CaffeinatedRat.
 All rights reserved.
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
 EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.getGlobal = function $$jscomp$getGlobal$($maybeGlobal$$) {
  return "undefined" != typeof window && window === $maybeGlobal$$ ? $maybeGlobal$$ : "undefined" != typeof global && null != global ? global : $maybeGlobal$$;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.inherits = function $$jscomp$inherits$($childCtor$$, $parentCtor$$) {
  function $tempCtor$$() {
  }
  $tempCtor$$.prototype = $parentCtor$$.prototype;
  $childCtor$$.superClass_ = $parentCtor$$.prototype;
  $childCtor$$.prototype = new $tempCtor$$;
  $childCtor$$.prototype.constructor = $childCtor$$;
  for (var $p$$ in $parentCtor$$) {
    if ("prototype" != $p$$) {
      if (Object.defineProperties) {
        var $descriptor$$ = Object.getOwnPropertyDescriptor($parentCtor$$, $p$$);
        $descriptor$$ && Object.defineProperty($childCtor$$, $p$$, $descriptor$$);
      } else {
        $childCtor$$[$p$$] = $parentCtor$$[$p$$];
      }
    }
  }
};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function($target$$, $property$$, $descriptor$$) {
  $target$$ != Array.prototype && $target$$ != Object.prototype && ($target$$[$property$$] = $descriptor$$.value);
};
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function $$jscomp$initSymbol$() {
  $jscomp.initSymbol = function $$jscomp$initSymbol$() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.symbolCounter_ = 0;
$jscomp.Symbol = function $$jscomp$Symbol$($opt_description$$) {
  return $jscomp.SYMBOL_PREFIX + ($opt_description$$ || "") + $jscomp.symbolCounter_++;
};
$jscomp.initSymbolIterator = function $$jscomp$initSymbolIterator$() {
  $jscomp.initSymbol();
  var $symbolIterator$$ = $jscomp.global.Symbol.iterator;
  $symbolIterator$$ || ($symbolIterator$$ = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[$symbolIterator$$] && $jscomp.defineProperty(Array.prototype, $symbolIterator$$, {configurable:!0, writable:!0, value:function() {
    return $jscomp.arrayIterator(this);
  }});
  $jscomp.initSymbolIterator = function $$jscomp$initSymbolIterator$() {
  };
};
$jscomp.arrayIterator = function $$jscomp$arrayIterator$($array$$) {
  var $index$$ = 0;
  return $jscomp.iteratorPrototype(function() {
    return $index$$ < $array$$.length ? {done:!1, value:$array$$[$index$$++]} : {done:!0};
  });
};
$jscomp.iteratorPrototype = function $$jscomp$iteratorPrototype$($iterator$$) {
  $jscomp.initSymbolIterator();
  $iterator$$ = {next:$iterator$$};
  $iterator$$[$jscomp.global.Symbol.iterator] = function $$iterator$$$$jscomp$global$Symbol$iterator$() {
    return this;
  };
  return $iterator$$;
};
$jscomp.iteratorFromArray = function $$jscomp$iteratorFromArray$($array$$, $transform$$) {
  $jscomp.initSymbolIterator();
  $array$$ instanceof String && ($array$$ += "");
  var $i$$ = 0, $iter$$ = {next:function() {
    if ($i$$ < $array$$.length) {
      var $index$$ = $i$$++;
      return {value:$transform$$($index$$, $array$$[$index$$]), done:!1};
    }
    $iter$$.next = function $$iter$$$next$() {
      return {done:!0, value:void 0};
    };
    return $iter$$.next();
  }};
  $iter$$[Symbol.iterator] = function $$iter$$$Symbol$iterator$() {
    return $iter$$;
  };
  return $iter$$;
};
$jscomp.polyfill = function $$jscomp$polyfill$($property$jscomp$5_split_target$$, $impl_polyfill$$, $fromLang_obj$$, $i$$) {
  if ($impl_polyfill$$) {
    $fromLang_obj$$ = $jscomp.global;
    $property$jscomp$5_split_target$$ = $property$jscomp$5_split_target$$.split(".");
    for ($i$$ = 0; $i$$ < $property$jscomp$5_split_target$$.length - 1; $i$$++) {
      var $key$$ = $property$jscomp$5_split_target$$[$i$$];
      $key$$ in $fromLang_obj$$ || ($fromLang_obj$$[$key$$] = {});
      $fromLang_obj$$ = $fromLang_obj$$[$key$$];
    }
    $property$jscomp$5_split_target$$ = $property$jscomp$5_split_target$$[$property$jscomp$5_split_target$$.length - 1];
    $i$$ = $fromLang_obj$$[$property$jscomp$5_split_target$$];
    $impl_polyfill$$ = $impl_polyfill$$($i$$);
    $impl_polyfill$$ != $i$$ && null != $impl_polyfill$$ && $jscomp.defineProperty($fromLang_obj$$, $property$jscomp$5_split_target$$, {configurable:!0, writable:!0, value:$impl_polyfill$$});
  }
};
$jscomp.polyfill("Array.prototype.keys", function($orig$$) {
  return $orig$$ ? $orig$$ : function() {
    return $jscomp.iteratorFromArray(this, function($i$$) {
      return $i$$;
    });
  };
}, "es6", "es3");
$jscomp.makeIterator = function $$jscomp$makeIterator$($iterable$$) {
  $jscomp.initSymbolIterator();
  var $iteratorFunction$$ = $iterable$$[Symbol.iterator];
  return $iteratorFunction$$ ? $iteratorFunction$$.call($iterable$$) : $jscomp.arrayIterator($iterable$$);
};
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.polyfill("Promise", function($NativePromise$$) {
  function $AsyncExecutor$$() {
    this.batch_ = null;
  }
  function $resolvingPromise$$($opt_value$$) {
    return $opt_value$$ instanceof $PolyfillPromise$$ ? $opt_value$$ : new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $resolve$$($opt_value$$);
    });
  }
  if ($NativePromise$$ && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return $NativePromise$$;
  }
  $AsyncExecutor$$.prototype.asyncExecute = function $$AsyncExecutor$$$$asyncExecute$($f$$) {
    null == this.batch_ && (this.batch_ = [], this.asyncExecuteBatch_());
    this.batch_.push($f$$);
    return this;
  };
  $AsyncExecutor$$.prototype.asyncExecuteBatch_ = function $$AsyncExecutor$$$$asyncExecuteBatch_$() {
    var $self$$ = this;
    this.asyncExecuteFunction(function() {
      $self$$.executeBatch_();
    });
  };
  var $nativeSetTimeout$$ = $jscomp.global.setTimeout;
  $AsyncExecutor$$.prototype.asyncExecuteFunction = function $$AsyncExecutor$$$$asyncExecuteFunction$($f$$) {
    $nativeSetTimeout$$($f$$, 0);
  };
  $AsyncExecutor$$.prototype.executeBatch_ = function $$AsyncExecutor$$$$executeBatch_$() {
    for (; this.batch_ && this.batch_.length;) {
      var $executingBatch$$ = this.batch_;
      this.batch_ = [];
      for (var $i$$ = 0; $i$$ < $executingBatch$$.length; ++$i$$) {
        var $f$$ = $executingBatch$$[$i$$];
        delete $executingBatch$$[$i$$];
        try {
          $f$$();
        } catch ($error$$) {
          this.asyncThrow_($error$$);
        }
      }
    }
    this.batch_ = null;
  };
  $AsyncExecutor$$.prototype.asyncThrow_ = function $$AsyncExecutor$$$$asyncThrow_$($exception$$) {
    this.asyncExecuteFunction(function() {
      throw $exception$$;
    });
  };
  var $PolyfillPromise$$ = function $$PolyfillPromise$$$($executor$$) {
    this.state_ = 0;
    this.result_ = void 0;
    this.onSettledCallbacks_ = [];
    var $resolveAndReject$$ = this.createResolveAndReject_();
    try {
      $executor$$($resolveAndReject$$.resolve, $resolveAndReject$$.reject);
    } catch ($e$$) {
      $resolveAndReject$$.reject($e$$);
    }
  };
  $PolyfillPromise$$.prototype.createResolveAndReject_ = function $$PolyfillPromise$$$$createResolveAndReject_$() {
    function $firstCallWins$$($method$$) {
      return function($x$$) {
        $alreadyCalled$$ || ($alreadyCalled$$ = !0, $method$$.call($thisPromise$$, $x$$));
      };
    }
    var $thisPromise$$ = this, $alreadyCalled$$ = !1;
    return {resolve:$firstCallWins$$(this.resolveTo_), reject:$firstCallWins$$(this.reject_)};
  };
  $PolyfillPromise$$.prototype.resolveTo_ = function $$PolyfillPromise$$$$resolveTo_$($value$$) {
    if ($value$$ === this) {
      this.reject_(new TypeError("A Promise cannot resolve to itself"));
    } else {
      if ($value$$ instanceof $PolyfillPromise$$) {
        this.settleSameAsPromise_($value$$);
      } else {
        a: {
          switch(typeof $value$$) {
            case "object":
              var $JSCompiler_inline_result$$ = null != $value$$;
              break a;
            case "function":
              $JSCompiler_inline_result$$ = !0;
              break a;
            default:
              $JSCompiler_inline_result$$ = !1;
          }
        }
        $JSCompiler_inline_result$$ ? this.resolveToNonPromiseObj_($value$$) : this.fulfill_($value$$);
      }
    }
  };
  $PolyfillPromise$$.prototype.resolveToNonPromiseObj_ = function $$PolyfillPromise$$$$resolveToNonPromiseObj_$($obj$$) {
    var $thenMethod$$ = void 0;
    try {
      $thenMethod$$ = $obj$$.then;
    } catch ($error$$) {
      this.reject_($error$$);
      return;
    }
    "function" == typeof $thenMethod$$ ? this.settleSameAsThenable_($thenMethod$$, $obj$$) : this.fulfill_($obj$$);
  };
  $PolyfillPromise$$.prototype.reject_ = function $$PolyfillPromise$$$$reject_$($reason$$) {
    this.settle_(2, $reason$$);
  };
  $PolyfillPromise$$.prototype.fulfill_ = function $$PolyfillPromise$$$$fulfill_$($value$$) {
    this.settle_(1, $value$$);
  };
  $PolyfillPromise$$.prototype.settle_ = function $$PolyfillPromise$$$$settle_$($settledState$$, $valueOrReason$$) {
    if (0 != this.state_) {
      throw Error("Cannot settle(" + $settledState$$ + ", " + $valueOrReason$$ | "): Promise already settled in state" + this.state_);
    }
    this.state_ = $settledState$$;
    this.result_ = $valueOrReason$$;
    this.executeOnSettledCallbacks_();
  };
  $PolyfillPromise$$.prototype.executeOnSettledCallbacks_ = function $$PolyfillPromise$$$$executeOnSettledCallbacks_$() {
    if (null != this.onSettledCallbacks_) {
      for (var $callbacks$$ = this.onSettledCallbacks_, $i$$ = 0; $i$$ < $callbacks$$.length; ++$i$$) {
        $callbacks$$[$i$$].call(), $callbacks$$[$i$$] = null;
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var $asyncExecutor$$ = new $AsyncExecutor$$;
  $PolyfillPromise$$.prototype.settleSameAsPromise_ = function $$PolyfillPromise$$$$settleSameAsPromise_$($promise$$) {
    var $methods$$ = this.createResolveAndReject_();
    $promise$$.callWhenSettled_($methods$$.resolve, $methods$$.reject);
  };
  $PolyfillPromise$$.prototype.settleSameAsThenable_ = function $$PolyfillPromise$$$$settleSameAsThenable_$($thenMethod$$, $thenable$$) {
    var $methods$$ = this.createResolveAndReject_();
    try {
      $thenMethod$$.call($thenable$$, $methods$$.resolve, $methods$$.reject);
    } catch ($error$$) {
      $methods$$.reject($error$$);
    }
  };
  $PolyfillPromise$$.prototype.then = function $$PolyfillPromise$$$$then$($onFulfilled$$, $onRejected$$) {
    function $createCallback$$($paramF$$, $defaultF$$) {
      return "function" == typeof $paramF$$ ? function($x$$) {
        try {
          $resolveChild$$($paramF$$($x$$));
        } catch ($error$$) {
          $rejectChild$$($error$$);
        }
      } : $defaultF$$;
    }
    var $resolveChild$$, $rejectChild$$, $childPromise$$ = new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $resolveChild$$ = $resolve$$;
      $rejectChild$$ = $reject$$;
    });
    this.callWhenSettled_($createCallback$$($onFulfilled$$, $resolveChild$$), $createCallback$$($onRejected$$, $rejectChild$$));
    return $childPromise$$;
  };
  $PolyfillPromise$$.prototype.catch = function $$PolyfillPromise$$$$catch$($onRejected$$) {
    return this.then(void 0, $onRejected$$);
  };
  $PolyfillPromise$$.prototype.callWhenSettled_ = function $$PolyfillPromise$$$$callWhenSettled_$($onFulfilled$$, $onRejected$$) {
    function $callback$$() {
      switch($thisPromise$$.state_) {
        case 1:
          $onFulfilled$$($thisPromise$$.result_);
          break;
        case 2:
          $onRejected$$($thisPromise$$.result_);
          break;
        default:
          throw Error("Unexpected state: " + $thisPromise$$.state_);
      }
    }
    var $thisPromise$$ = this;
    null == this.onSettledCallbacks_ ? $asyncExecutor$$.asyncExecute($callback$$) : this.onSettledCallbacks_.push(function() {
      $asyncExecutor$$.asyncExecute($callback$$);
    });
  };
  $PolyfillPromise$$.resolve = $resolvingPromise$$;
  $PolyfillPromise$$.reject = function $$PolyfillPromise$$$reject$($opt_reason$$) {
    return new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $reject$$($opt_reason$$);
    });
  };
  $PolyfillPromise$$.race = function $$PolyfillPromise$$$race$($thenablesOrValues$$) {
    return new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      for (var $iterator$$ = $jscomp.makeIterator($thenablesOrValues$$), $iterRec$$ = $iterator$$.next(); !$iterRec$$.done; $iterRec$$ = $iterator$$.next()) {
        $resolvingPromise$$($iterRec$$.value).callWhenSettled_($resolve$$, $reject$$);
      }
    });
  };
  $PolyfillPromise$$.all = function $$PolyfillPromise$$$all$($thenablesOrValues$$) {
    var $iterator$$ = $jscomp.makeIterator($thenablesOrValues$$), $iterRec$$ = $iterator$$.next();
    return $iterRec$$.done ? $resolvingPromise$$([]) : new $PolyfillPromise$$(function($resolveAll$$, $rejectAll$$) {
      function $onFulfilled$$($i$$) {
        return function($ithResult$$) {
          $resultsArray$$[$i$$] = $ithResult$$;
          $unresolvedCount$$--;
          0 == $unresolvedCount$$ && $resolveAll$$($resultsArray$$);
        };
      }
      var $resultsArray$$ = [], $unresolvedCount$$ = 0;
      do {
        $resultsArray$$.push(void 0), $unresolvedCount$$++, $resolvingPromise$$($iterRec$$.value).callWhenSettled_($onFulfilled$$($resultsArray$$.length - 1), $rejectAll$$), $iterRec$$ = $iterator$$.next();
      } while (!$iterRec$$.done);
    });
  };
  return $PolyfillPromise$$;
}, "es6", "es3");
$jscomp.owns = function $$jscomp$owns$($obj$$, $prop$$) {
  return Object.prototype.hasOwnProperty.call($obj$$, $prop$$);
};
$jscomp.polyfill("WeakMap", function($NativeWeakMap$$) {
  function $insert$$($target$$) {
    $jscomp.owns($target$$, $prop$$) || $jscomp.defineProperty($target$$, $prop$$, {value:{}});
  }
  function $patch$$($name$$) {
    var $prev$$ = Object[$name$$];
    $prev$$ && (Object[$name$$] = function $Object$$name$$$($target$$) {
      $insert$$($target$$);
      return $prev$$($target$$);
    });
  }
  if (function isConformant() {
    if (!$NativeWeakMap$$ || !Object.seal) {
      return !1;
    }
    try {
      var $x$$ = Object.seal({}), $y$$ = Object.seal({}), $map$$ = new $NativeWeakMap$$([[$x$$, 2], [$y$$, 3]]);
      if (2 != $map$$.get($x$$) || 3 != $map$$.get($y$$)) {
        return !1;
      }
      $map$$.delete($x$$);
      $map$$.set($y$$, 4);
      return !$map$$.has($x$$) && 4 == $map$$.get($y$$);
    } catch ($err$$) {
      return !1;
    }
  }()) {
    return $NativeWeakMap$$;
  }
  var $prop$$ = "$jscomp_hidden_" + Math.random().toString().substring(2);
  $patch$$("freeze");
  $patch$$("preventExtensions");
  $patch$$("seal");
  var $index$$ = 0, $PolyfillWeakMap$$ = function $$PolyfillWeakMap$$$($iter$jscomp$1_opt_iterable$$) {
    this.id_ = ($index$$ += Math.random() + 1).toString();
    if ($iter$jscomp$1_opt_iterable$$) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      $iter$jscomp$1_opt_iterable$$ = $jscomp.makeIterator($iter$jscomp$1_opt_iterable$$);
      for (var $entry_item$$; !($entry_item$$ = $iter$jscomp$1_opt_iterable$$.next()).done;) {
        $entry_item$$ = $entry_item$$.value, this.set($entry_item$$[0], $entry_item$$[1]);
      }
    }
  };
  $PolyfillWeakMap$$.prototype.set = function $$PolyfillWeakMap$$$$set$($key$$, $value$$) {
    $insert$$($key$$);
    if (!$jscomp.owns($key$$, $prop$$)) {
      throw Error("WeakMap key fail: " + $key$$);
    }
    $key$$[$prop$$][this.id_] = $value$$;
    return this;
  };
  $PolyfillWeakMap$$.prototype.get = function $$PolyfillWeakMap$$$$get$($key$$) {
    return $jscomp.owns($key$$, $prop$$) ? $key$$[$prop$$][this.id_] : void 0;
  };
  $PolyfillWeakMap$$.prototype.has = function $$PolyfillWeakMap$$$$has$($key$$) {
    return $jscomp.owns($key$$, $prop$$) && $jscomp.owns($key$$[$prop$$], this.id_);
  };
  $PolyfillWeakMap$$.prototype.delete = function $$PolyfillWeakMap$$$$delete$($key$$) {
    return $jscomp.owns($key$$, $prop$$) && $jscomp.owns($key$$[$prop$$], this.id_) ? delete $key$$[$prop$$][this.id_] : !1;
  };
  return $PolyfillWeakMap$$;
}, "es6", "es3");
$jscomp.MapEntry = function $$jscomp$MapEntry$() {
};
$jscomp.polyfill("Map", function($NativeMap$$) {
  if (!$jscomp.ASSUME_NO_NATIVE_MAP && function() {
    if (!$NativeMap$$ || !$NativeMap$$.prototype.entries || "function" != typeof Object.seal) {
      return !1;
    }
    try {
      var $key$$ = Object.seal({x:4}), $map$$ = new $NativeMap$$($jscomp.makeIterator([[$key$$, "s"]]));
      if ("s" != $map$$.get($key$$) || 1 != $map$$.size || $map$$.get({x:4}) || $map$$.set({x:4}, "t") != $map$$ || 2 != $map$$.size) {
        return !1;
      }
      var $iter$$ = $map$$.entries(), $item$$ = $iter$$.next();
      if ($item$$.done || $item$$.value[0] != $key$$ || "s" != $item$$.value[1]) {
        return !1;
      }
      $item$$ = $iter$$.next();
      return $item$$.done || 4 != $item$$.value[0].x || "t" != $item$$.value[1] || !$iter$$.next().done ? !1 : !0;
    } catch ($err$$) {
      return !1;
    }
  }()) {
    return $NativeMap$$;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var $idMap$$ = new WeakMap, $PolyfillMap$$ = function $$PolyfillMap$$$($iter$jscomp$3_opt_iterable$$) {
    this.data_ = {};
    this.head_ = $createHead$$();
    this.size = 0;
    if ($iter$jscomp$3_opt_iterable$$) {
      $iter$jscomp$3_opt_iterable$$ = $jscomp.makeIterator($iter$jscomp$3_opt_iterable$$);
      for (var $entry$jscomp$1_item$$; !($entry$jscomp$1_item$$ = $iter$jscomp$3_opt_iterable$$.next()).done;) {
        $entry$jscomp$1_item$$ = $entry$jscomp$1_item$$.value, this.set($entry$jscomp$1_item$$[0], $entry$jscomp$1_item$$[1]);
      }
    }
  };
  $PolyfillMap$$.prototype.set = function $$PolyfillMap$$$$set$($key$$, $value$$) {
    var $r$$ = $maybeGetEntry$$(this, $key$$);
    $r$$.list || ($r$$.list = this.data_[$r$$.id] = []);
    $r$$.entry ? $r$$.entry.value = $value$$ : ($r$$.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:$key$$, value:$value$$}, $r$$.list.push($r$$.entry), this.head_.previous.next = $r$$.entry, this.head_.previous = $r$$.entry, this.size++);
    return this;
  };
  $PolyfillMap$$.prototype.delete = function $$PolyfillMap$$$$delete$($key$jscomp$34_r$$) {
    $key$jscomp$34_r$$ = $maybeGetEntry$$(this, $key$jscomp$34_r$$);
    return $key$jscomp$34_r$$.entry && $key$jscomp$34_r$$.list ? ($key$jscomp$34_r$$.list.splice($key$jscomp$34_r$$.index, 1), $key$jscomp$34_r$$.list.length || delete this.data_[$key$jscomp$34_r$$.id], $key$jscomp$34_r$$.entry.previous.next = $key$jscomp$34_r$$.entry.next, $key$jscomp$34_r$$.entry.next.previous = $key$jscomp$34_r$$.entry.previous, $key$jscomp$34_r$$.entry.head = null, this.size--, !0) : !1;
  };
  $PolyfillMap$$.prototype.clear = function $$PolyfillMap$$$$clear$() {
    this.data_ = {};
    this.head_ = this.head_.previous = $createHead$$();
    this.size = 0;
  };
  $PolyfillMap$$.prototype.has = function $$PolyfillMap$$$$has$($key$$) {
    return !!$maybeGetEntry$$(this, $key$$).entry;
  };
  $PolyfillMap$$.prototype.get = function $$PolyfillMap$$$$get$($entry$jscomp$2_key$$) {
    return ($entry$jscomp$2_key$$ = $maybeGetEntry$$(this, $entry$jscomp$2_key$$).entry) && $entry$jscomp$2_key$$.value;
  };
  $PolyfillMap$$.prototype.entries = function $$PolyfillMap$$$$entries$() {
    return $makeIterator$$(this, function($entry$$) {
      return [$entry$$.key, $entry$$.value];
    });
  };
  $PolyfillMap$$.prototype.keys = function $$PolyfillMap$$$$keys$() {
    return $makeIterator$$(this, function($entry$$) {
      return $entry$$.key;
    });
  };
  $PolyfillMap$$.prototype.values = function $$PolyfillMap$$$$values$() {
    return $makeIterator$$(this, function($entry$$) {
      return $entry$$.value;
    });
  };
  $PolyfillMap$$.prototype.forEach = function $$PolyfillMap$$$$forEach$($callback$$, $opt_thisArg$$) {
    for (var $iter$$ = this.entries(), $entry$jscomp$6_item$$; !($entry$jscomp$6_item$$ = $iter$$.next()).done;) {
      $entry$jscomp$6_item$$ = $entry$jscomp$6_item$$.value, $callback$$.call($opt_thisArg$$, $entry$jscomp$6_item$$[1], $entry$jscomp$6_item$$[0], this);
    }
  };
  $PolyfillMap$$.prototype[Symbol.iterator] = $PolyfillMap$$.prototype.entries;
  var $maybeGetEntry$$ = function $$maybeGetEntry$$$($index$jscomp$46_map$$, $key$$) {
    var $id$jscomp$4_id$jscomp$inline_35_type$$ = $key$$ && typeof $key$$;
    "object" == $id$jscomp$4_id$jscomp$inline_35_type$$ || "function" == $id$jscomp$4_id$jscomp$inline_35_type$$ ? $idMap$$.has($key$$) ? $id$jscomp$4_id$jscomp$inline_35_type$$ = $idMap$$.get($key$$) : ($id$jscomp$4_id$jscomp$inline_35_type$$ = "" + ++$mapIndex$$, $idMap$$.set($key$$, $id$jscomp$4_id$jscomp$inline_35_type$$)) : $id$jscomp$4_id$jscomp$inline_35_type$$ = "p_" + $key$$;
    var $list$$ = $index$jscomp$46_map$$.data_[$id$jscomp$4_id$jscomp$inline_35_type$$];
    if ($list$$ && $jscomp.owns($index$jscomp$46_map$$.data_, $id$jscomp$4_id$jscomp$inline_35_type$$)) {
      for ($index$jscomp$46_map$$ = 0; $index$jscomp$46_map$$ < $list$$.length; $index$jscomp$46_map$$++) {
        var $entry$$ = $list$$[$index$jscomp$46_map$$];
        if ($key$$ !== $key$$ && $entry$$.key !== $entry$$.key || $key$$ === $entry$$.key) {
          return {id:$id$jscomp$4_id$jscomp$inline_35_type$$, list:$list$$, index:$index$jscomp$46_map$$, entry:$entry$$};
        }
      }
    }
    return {id:$id$jscomp$4_id$jscomp$inline_35_type$$, list:$list$$, index:-1, entry:void 0};
  }, $makeIterator$$ = function $$makeIterator$$$($map$$, $func$$) {
    var $entry$$ = $map$$.head_;
    return $jscomp.iteratorPrototype(function() {
      if ($entry$$) {
        for (; $entry$$.head != $map$$.head_;) {
          $entry$$ = $entry$$.previous;
        }
        for (; $entry$$.next != $entry$$.head;) {
          return $entry$$ = $entry$$.next, {done:!1, value:$func$$($entry$$)};
        }
        $entry$$ = null;
      }
      return {done:!0, value:void 0};
    });
  }, $createHead$$ = function $$createHead$$$() {
    var $head$$ = {};
    return $head$$.previous = $head$$.next = $head$$.head = $head$$;
  }, $mapIndex$$ = 0;
  return $PolyfillMap$$;
}, "es6", "es3");
$jscomp.polyfill("Set", function($NativeSet$$) {
  if (!$jscomp.ASSUME_NO_NATIVE_SET && function() {
    if (!$NativeSet$$ || !$NativeSet$$.prototype.entries || "function" != typeof Object.seal) {
      return !1;
    }
    try {
      var $value$$ = Object.seal({x:4}), $set$$ = new $NativeSet$$($jscomp.makeIterator([$value$$]));
      if (!$set$$.has($value$$) || 1 != $set$$.size || $set$$.add($value$$) != $set$$ || 1 != $set$$.size || $set$$.add({x:4}) != $set$$ || 2 != $set$$.size) {
        return !1;
      }
      var $iter$$ = $set$$.entries(), $item$$ = $iter$$.next();
      if ($item$$.done || $item$$.value[0] != $value$$ || $item$$.value[1] != $value$$) {
        return !1;
      }
      $item$$ = $iter$$.next();
      return $item$$.done || $item$$.value[0] == $value$$ || 4 != $item$$.value[0].x || $item$$.value[1] != $item$$.value[0] ? !1 : $iter$$.next().done;
    } catch ($err$$) {
      return !1;
    }
  }()) {
    return $NativeSet$$;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var $PolyfillSet$$ = function $$PolyfillSet$$$($iter$jscomp$6_opt_iterable$$) {
    this.map_ = new Map;
    if ($iter$jscomp$6_opt_iterable$$) {
      $iter$jscomp$6_opt_iterable$$ = $jscomp.makeIterator($iter$jscomp$6_opt_iterable$$);
      for (var $entry$$; !($entry$$ = $iter$jscomp$6_opt_iterable$$.next()).done;) {
        this.add($entry$$.value);
      }
    }
    this.size = this.map_.size;
  };
  $PolyfillSet$$.prototype.add = function $$PolyfillSet$$$$add$($value$$) {
    this.map_.set($value$$, $value$$);
    this.size = this.map_.size;
    return this;
  };
  $PolyfillSet$$.prototype.delete = function $$PolyfillSet$$$$delete$($result_value$$) {
    $result_value$$ = this.map_.delete($result_value$$);
    this.size = this.map_.size;
    return $result_value$$;
  };
  $PolyfillSet$$.prototype.clear = function $$PolyfillSet$$$$clear$() {
    this.map_.clear();
    this.size = 0;
  };
  $PolyfillSet$$.prototype.has = function $$PolyfillSet$$$$has$($value$$) {
    return this.map_.has($value$$);
  };
  $PolyfillSet$$.prototype.entries = function $$PolyfillSet$$$$entries$() {
    return this.map_.entries();
  };
  $PolyfillSet$$.prototype.values = function $$PolyfillSet$$$$values$() {
    return this.map_.values();
  };
  $PolyfillSet$$.prototype.keys = $PolyfillSet$$.prototype.values;
  $PolyfillSet$$.prototype[Symbol.iterator] = $PolyfillSet$$.prototype.values;
  $PolyfillSet$$.prototype.forEach = function $$PolyfillSet$$$$forEach$($callback$$, $opt_thisArg$$) {
    var $set$$ = this;
    this.map_.forEach(function($value$$) {
      return $callback$$.call($opt_thisArg$$, $value$$, $value$$, $set$$);
    });
  };
  return $PolyfillSet$$;
}, "es6", "es3");
var hamonengine = {debug:!0};
hamonengine.util = hamonengine.util || {};
(function() {
  hamonengine.util.fpscounter = function $hamonengine$util$fpscounter$($options$$) {
    this._spf = this._fps = this._frameCounter = this._globalStartTime = 0;
    this._minFPS = 1000;
    this._maxFPS = 0;
  };
  hamonengine.util.fpscounter.prototype.start = function $hamonengine$util$fpscounter$$start$() {
    this._globalStartTime = Date.now();
    this._spf = this._fps = this._frameCounter = 0;
    this._minFPS = 1000;
    this._maxFPS = 0;
  };
  hamonengine.util.fpscounter.prototype.begin = function $hamonengine$util$fpscounter$$begin$() {
    this._frameStartTime = Date.now();
  };
  hamonengine.util.fpscounter.prototype.end = function $hamonengine$util$fpscounter$$end$() {
    if (0 === this._startTime) {
      throw "[hamonengine.util.fpsCounter.end] Begin was not called before end.";
    }
    var $frameEndTime$$ = Date.now();
    this._frameCounter++;
    this._spf = 1000 * ($frameEndTime$$ - this._frameStartTime);
    $frameEndTime$$ > this._globalStartTime + 1000 && (this._fps = Math.round(1000 * this._frameCounter / ($frameEndTime$$ - this._globalStartTime)), this._minFPS = Math.min(this._minFPS, this._fps), this._maxFPS = Math.max(this._maxFPS, this._fps), this._globalStartTime = $frameEndTime$$, this._frameCounter = 0);
  };
  $jscomp.global.Object.defineProperties(hamonengine.util.fpscounter.prototype, {SPF:{configurable:!0, enumerable:!0, get:function() {
    return this._spf;
  }}, FPS:{configurable:!0, enumerable:!0, get:function() {
    return this._fps;
  }}, minFPS:{configurable:!0, enumerable:!0, get:function() {
    return this._minFPS;
  }}, maxFPS:{configurable:!0, enumerable:!0, get:function() {
    return this._maxFPS;
  }}});
})();
var LOG_TYPE = {DISABLED:0, INFO:1, WARNING:2, CRITICAL:4, DEBUG:8, ALL:15};
hamonengine.util = hamonengine.util || {loggerlevel:LOG_TYPE.DISABLED};
(function() {
  hamonengine.util.logger = function $hamonengine$util$logger$() {
  };
  hamonengine.util.logger.debug = function $hamonengine$util$logger$debug$($message$$) {
    (hamonengine.util.loggerlevel & LOG_TYPE.DEBUG) === LOG_TYPE.DEBUG && console.log($message$$);
  };
  hamonengine.util.logger.info = function $hamonengine$util$logger$info$($message$$) {
    (hamonengine.util.loggerlevel & LOG_TYPE.INFO) === LOG_TYPE.INFO && console.info($message$$);
  };
  hamonengine.util.logger.warning = function $hamonengine$util$logger$warning$($message$$) {
    (hamonengine.util.loggerlevel & LOG_TYPE.WARNING) === LOG_TYPE.WARNING && console.warn($message$$);
  };
  hamonengine.util.bitwise = function $hamonengine$util$bitwise$() {
  };
  hamonengine.util.bitwise.toggle = function $hamonengine$util$bitwise$toggle$($value$$, $bitToToggle$$, $state$$) {
    return void 0 !== $state$$ ? $state$$ ? $value$$ | 1 << $bitToToggle$$ : $value$$ & ~(1 << $bitToToggle$$) : $value$$ ^ 1 << $bitToToggle$$;
  };
  hamonengine.util.bitwise.isSet = function $hamonengine$util$bitwise$isSet$($value$$, $bitToCheck_valueToCheck$$) {
    $bitToCheck_valueToCheck$$ = 1 << $bitToCheck_valueToCheck$$;
    return ($value$$ & $bitToCheck_valueToCheck$$) === $bitToCheck_valueToCheck$$;
  };
  Object.prototype.forEach = function $Object$$forEach$($f$$) {
    var $$jscomp$this$$ = this;
    $f$$ && Object.keys(this).forEach(function($key$$) {
      $$jscomp$this$$.hasOwnProperty($key$$) && $f$$($key$$, $$jscomp$this$$[$key$$]);
    });
  };
})();
hamonengine.math = hamonengine.math || {};
(function() {
  Math.PI2 = 6.283185307179586476925286766559;
  Math.PI3_2 = 3 * Math.PI / 2;
  Math.PI_2 = Math.PI / 2;
  Math.HalfPI = 1.5707963267948966192313216916398;
  Math.QuarterPI = 4.7123889803846898576939650749193;
  Math.maxInt32 = 2147483647;
  Math.maxUInt32 = 4294967296;
  Math.bitRound = function $Math$bitRound$($x$$) {
    return 0.5 + $x$$ << 0;
  };
  Math.truncate = function $Math$truncate$($x$$) {
    return $x$$ >= Math.maxInt32 ? Math.maxInt32 : ~~$x$$;
  };
  Math.sqr = function $Math$sqr$($x$$) {
    return $x$$ * $x$$;
  };
  Math.toDegrees = function $Math$toDegrees$($degrees$$) {
    return $degrees$$ * Math.PI / 180;
  };
  Math.toRadians = function $Math$toRadians$($radians$$) {
    return 180 * $radians$$ / Math.PI;
  };
})();
hamonengine.math = hamonengine.math || {};
(function() {
  hamonengine.math.sort = function $hamonengine$math$sort$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._compareFunc = $options$$.compareFunc ? $options$$.compareFunc : hamonengine.math.sort.sort.ascending;
  };
  hamonengine.math.sort.prototype.quickSort = function $hamonengine$math$sort$$quickSort$($arr$$) {
    hamonengine.math.sort.iquicksort(this._compareFunc, $arr$$, 0, $arr$$.length - 1);
  };
  hamonengine.math.sort.ascending = function $hamonengine$math$sort$ascending$($a$$, $b$$) {
    return $a$$ === $b$$ ? 0 : $a$$ < $b$$ ? -1 : 1;
  };
  hamonengine.math.sort.descending = function $hamonengine$math$sort$descending$($a$$, $b$$) {
    return $a$$ === $b$$ ? 0 : $a$$ < $b$$ ? 1 : -1;
  };
  hamonengine.math.sort.iquicksort = function $hamonengine$math$sort$iquicksort$($compareFunction$$, $arr$$, $left$$, $right$$) {
    for (var $i$$ = $left$$, $j$$ = $right$$, $pivot$$ = $arr$$[Math.truncate(($left$$ + $right$$) / 2)]; $i$$ <= $j$$;) {
      for (; 0 > $compareFunction$$($arr$$[$i$$], $pivot$$);) {
        $i$$++;
      }
      for (; 0 < $compareFunction$$($arr$$[$j$$], $pivot$$);) {
        $j$$--;
      }
      if ($i$$ <= $j$$) {
        var $tmp$$ = $arr$$[$i$$];
        $arr$$[$i$$] = $arr$$[$j$$];
        $arr$$[$j$$] = $tmp$$;
        $i$$++;
        $j$$--;
      }
    }
    $left$$ < $j$$ && hamonengine.math.sort.iquicksort($compareFunction$$, $arr$$, $left$$, $j$$);
    $i$$ < $right$$ && hamonengine.math.sort.iquicksort($compareFunction$$, $arr$$, $i$$, $right$$);
  };
})();
hamonengine.math = hamonengine.math || {};
(function() {
  var $m$$ = Math.maxUInt32;
  hamonengine.math.LCGRandom = function $hamonengine$math$LCGRandom$($seed$$) {
    this._seed = $seed$$;
  };
  hamonengine.math.LCGRandom.prototype.random = function $hamonengine$math$LCGRandom$$random$() {
    return this._seed = (214013 * this._seed + 2531011) % $m$$;
  };
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.line = function $hamonengine$geometry$line$($min$$, $max$$) {
    this.min = void 0 === $min$$ ? 0.0 : $min$$;
    this.max = void 0 === $max$$ ? 0.0 : $max$$;
  };
  hamonengine.geometry.line.clone = function $hamonengine$geometry$line$clone$($line$$) {
    return new hamonengine.geometry.line($line$$.min, $line$$.max);
  };
  hamonengine.geometry.line.prototype.clone = function $hamonengine$geometry$line$$clone$() {
    return hamonengine.geometry.line.clone(this);
  };
  hamonengine.geometry.line.prototype.toString = function $hamonengine$geometry$line$$toString$() {
    return "{min: '" + this.min + "', max: '" + this.max + "'}";
  };
  hamonengine.geometry.line.prototype.mirror = function $hamonengine$geometry$line$$mirror$() {
    return new hamonengine.geometry.line(this.max, this.min);
  };
  hamonengine.geometry.line.prototype.add = function $hamonengine$geometry$line$$add$($l$$) {
    return new hamonengine.geometry.line(this.min + $l$$.min, this.max + $l$$.max);
  };
  hamonengine.geometry.line.prototype.subtract = function $hamonengine$geometry$line$$subtract$($l$$) {
    return new hamonengine.geometry.line(this.min - $l$$.min, this.max - $l$$.max);
  };
  hamonengine.geometry.line.prototype.multiplyScalar = function $hamonengine$geometry$line$$multiplyScalar$($s$$) {
    return new hamonengine.geometry.line(this.min * $s$$, this.max * $s$$);
  };
  hamonengine.geometry.line.prototype.overlap = function $hamonengine$geometry$line$$overlap$($l$$) {
    var $isPointOnLine$$ = function $$isPointOnLine$$$($point$$, $line$$) {
      return $point$$ >= $line$$.min && $point$$ <= $line$$.max;
    }, $min$$ = NaN;
    $isPointOnLine$$(this.min, $l$$) ? $min$$ = this.min : $isPointOnLine$$($l$$.min, this) && ($min$$ = $l$$.min);
    var $max$$ = NaN;
    $isPointOnLine$$(this.max, $l$$) ? $max$$ = this.max : $isPointOnLine$$($l$$.max, this) && ($max$$ = $l$$.max);
    return new hamonengine.geometry.line($min$$, $max$$);
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.line.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return this.max - this.min;
  }}, isLine:{configurable:!0, enumerable:!0, get:function() {
    return !isNaN(this.min) && !isNaN(this.max);
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.polygon = function $hamonengine$geometry$polygon$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.geometry.polygon && ($options$$ = {vertices:$options$$.vertices});
    this._vertices = $options$$.vertices || [];
    this._edges = [];
    this._normals = [];
    this._dimensions = {center:null, max:null, min:null};
    this._dirty = 15;
    this._shapeType = SHAPE_TYPE.UNKNOWN;
  };
  hamonengine.geometry.polygon.prototype.clone = function $hamonengine$geometry$polygon$$clone$() {
    return new hamonengine.geometry.polygon(this);
  };
  hamonengine.geometry.polygon.prototype.toString = function $hamonengine$geometry$polygon$$toString$() {
    for (var $vertexString$$ = "", $i$$ = 0; $i$$ < this._vertices.length; $i$$++) {
      $vertexString$$ += "" + ("" !== $vertexString$$ ? "," : "") + this._vertices[$i$$].toString();
    }
    return "[" + $vertexString$$ + "]";
  };
  hamonengine.geometry.polygon.prototype.toRect = function $hamonengine$geometry$polygon$$toRect$() {
    return new hamonengine.geometry.rect(this.min.x, this.min.y, this.max.x - this.min.x, this.max.y - this.min.y);
  };
  hamonengine.geometry.polygon.prototype.addVertex = function $hamonengine$geometry$polygon$$addVertex$($x$$, $y$$) {
    this._vertices.push(new hamonengine.geometry.vector2($x$$, $y$$));
    this._dirty = 15;
  };
  hamonengine.geometry.polygon.prototype.translate = function $hamonengine$geometry$polygon$$translate$($translateVector$$) {
    $translateVector$$ = $translateVector$$ || new hamonengine.geometry.vector2(0, 0);
    for (var $newVertices$$ = [], $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      $newVertices$$.push(this.vertices[$i$$].add($translateVector$$));
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.rotate = function $hamonengine$geometry$polygon$$rotate$($cosTheta_theta$$, $offsetVector$$) {
    var $sinTheta$$ = Math.sin($cosTheta_theta$$);
    $cosTheta_theta$$ = Math.cos($cosTheta_theta$$);
    $offsetVector$$ = $offsetVector$$ || new hamonengine.geometry.vector2(0, 0);
    for (var $newVertices$$ = [], $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      var $xOffset$$ = this.vertices[$i$$].x - $offsetVector$$.x, $yOffset$$ = this.vertices[$i$$].y - $offsetVector$$.y;
      $newVertices$$.push(new hamonengine.geometry.vector2($xOffset$$ * $cosTheta_theta$$ - $yOffset$$ * $sinTheta$$ + $offsetVector$$.x, $xOffset$$ * $sinTheta$$ + $yOffset$$ * $cosTheta_theta$$ + $offsetVector$$.y));
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.rotateAtCenter = function $hamonengine$geometry$polygon$$rotateAtCenter$($theta$$) {
    return this.rotate($theta$$, this.center);
  };
  hamonengine.geometry.polygon.prototype.scale = function $hamonengine$geometry$polygon$$scale$($scaleVector$$) {
    $scaleVector$$ = $scaleVector$$ || new hamonengine.geometry.vector2(0, 0);
    for (var $newVertices$$ = [], $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      $newVertices$$.push(this.vertices[$i$$].multiplyVector($scaleVector$$));
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.isCollision = function $hamonengine$geometry$polygon$$isCollision$($shape$$) {
    return $shape$$ instanceof hamonengine.geometry.rect ? this.isCollisionRect($shape$$) : $shape$$ instanceof hamonengine.geometry.polygon ? this.isCollisionPolygon($shape$$) : new hamonengine.geometry.vector2(0, 0);
  };
  hamonengine.geometry.polygon.prototype.isCollisionPolygon = function $hamonengine$geometry$polygon$$isCollisionPolygon$($polygon$$) {
    if (!($polygon$$ instanceof hamonengine.geometry.polygon)) {
      throw "Parameter polygon is not of type hamonengine.geometry.polygon.";
    }
    for (var $overlappingLength$$ = NaN, $mtvAxis$$, $axisNormals$$ = $polygon$$.normals, $i$0_i$$ = 0; $i$0_i$$ < $axisNormals$$.length; $i$0_i$$++) {
      var $overlapping_overlapping$3_projection1_projection1$1$$ = this.project($axisNormals$$[$i$0_i$$]), $projection2_projection2$2$$ = $polygon$$.project($axisNormals$$[$i$0_i$$]);
      $overlapping_overlapping$3_projection1_projection1$1$$ = $overlapping_overlapping$3_projection1_projection1$1$$.overlap($projection2_projection2$2$$);
      if (!$overlapping_overlapping$3_projection1_projection1$1$$.isLine) {
        return new hamonengine.geometry.vector2;
      }
      if (isNaN($overlappingLength$$) || $overlapping_overlapping$3_projection1_projection1$1$$.length < $overlappingLength$$) {
        $overlappingLength$$ = $overlapping_overlapping$3_projection1_projection1$1$$.length, $mtvAxis$$ = $axisNormals$$[$i$0_i$$];
      }
    }
    $axisNormals$$ = this.normals;
    for ($i$0_i$$ = 0; $i$0_i$$ < $axisNormals$$.length; $i$0_i$$++) {
      $overlapping_overlapping$3_projection1_projection1$1$$ = this.project($axisNormals$$[$i$0_i$$]);
      $projection2_projection2$2$$ = $polygon$$.project($axisNormals$$[$i$0_i$$]);
      $overlapping_overlapping$3_projection1_projection1$1$$ = $overlapping_overlapping$3_projection1_projection1$1$$.overlap($projection2_projection2$2$$);
      if (!$overlapping_overlapping$3_projection1_projection1$1$$.isLine) {
        return new hamonengine.geometry.vector2;
      }
      if (isNaN($overlappingLength$$) || $overlapping_overlapping$3_projection1_projection1$1$$.length < $overlappingLength$$) {
        $overlappingLength$$ = $overlapping_overlapping$3_projection1_projection1$1$$.length, $mtvAxis$$ = $axisNormals$$[$i$0_i$$];
      }
    }
    return $mtvAxis$$.multiply($overlappingLength$$);
  };
  hamonengine.geometry.polygon.prototype.isCollisionRect = function $hamonengine$geometry$polygon$$isCollisionRect$($rect$$) {
    return $rect$$.toPolygon().isCollision(this);
  };
  hamonengine.geometry.polygon.prototype.isContained = function $hamonengine$geometry$polygon$$isContained$($position$$, $polygon$$) {
    $polygon$$ instanceof hamonengine.geometry.polygon || hamonengine.util.logger.warning("[hamonengine.geometry.polygon.isContained] The polygon parameter is not of type hamonengine.geometry.polygon!");
    return new hamonengine.geometry.vector2;
  };
  hamonengine.geometry.polygon.prototype.project = function $hamonengine$geometry$polygon$$project$($vector$$) {
    var $min$$ = 0, $max$$ = 0;
    if (0 < this.vertices.length) {
      $max$$ = $min$$ = $vector$$.dot(this.vertices[0]);
      for (var $i$$ = 1; $i$$ < this.vertices.length; $i$$++) {
        var $projection$$ = $vector$$.dot(this.vertices[$i$$]);
        $projection$$ < $min$$ ? $min$$ = $projection$$ : $projection$$ > $max$$ && ($max$$ = $projection$$);
      }
    }
    return new hamonengine.geometry.line($min$$, $max$$);
  };
  hamonengine.geometry.polygon.calcEdges = function $hamonengine$geometry$polygon$calcEdges$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $edges$$ = [], $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      $edges$$.push($vertices$$[($i$$ + 1) % $vertices$$.length].subtract($vertices$$[$i$$]));
    }
    return $edges$$;
  };
  hamonengine.geometry.polygon.calcNormals = function $hamonengine$geometry$polygon$calcNormals$($edges$$) {
    $edges$$ = void 0 === $edges$$ ? [] : $edges$$;
    return $edges$$.map(function($edge$$) {
      return $edge$$.normal();
    });
  };
  hamonengine.geometry.polygon.calcDimensions = function $hamonengine$geometry$polygon$calcDimensions$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $xMax$$ = NaN, $xMin$$ = NaN, $yMax$$ = NaN, $yMin$$ = NaN, $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      $xMax$$ = $xMax$$ > $vertices$$[$i$$].x ? $xMax$$ : $vertices$$[$i$$].x, $xMin$$ = $xMin$$ < $vertices$$[$i$$].x ? $xMin$$ : $vertices$$[$i$$].x, $yMax$$ = $yMax$$ > $vertices$$[$i$$].y ? $yMax$$ : $vertices$$[$i$$].y, $yMin$$ = $yMin$$ < $vertices$$[$i$$].y ? $yMin$$ : $vertices$$[$i$$].y;
    }
    return {max:new hamonengine.geometry.vector2($xMax$$, $yMax$$), min:new hamonengine.geometry.vector2($xMin$$, $yMin$$), center:new hamonengine.geometry.vector2(($xMax$$ - $xMin$$) / 2, ($yMax$$ - $yMin$$) / 2)};
  };
  hamonengine.geometry.polygon.calcShapeType = function $hamonengine$geometry$polygon$calcShapeType$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $signCounter$$ = 0, $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      var $p2_v2$$ = $vertices$$[($i$$ + 1) % $vertices$$.length], $p3$$ = $vertices$$[($i$$ + 2) % $vertices$$.length], $v1$$ = $p2_v2$$.subtract($vertices$$[$i$$]);
      $p2_v2$$ = $p3$$.subtract($p2_v2$$);
      $signCounter$$ += 0 < $p2_v2$$.cross($v1$$).z ? 1 : -1;
    }
    return $vertices$$.length === $signCounter$$ ? SHAPE_TYPE.CONVEX : SHAPE_TYPE.CONCAVE;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.polygon.prototype, {vertices:{configurable:!0, enumerable:!0, get:function() {
    return this._vertices;
  }}, edges:{configurable:!0, enumerable:!0, get:function() {
    hamonengine.util.bitwise.isSet(this._dirty, 2) && (this._edges = hamonengine.geometry.polygon.calcEdges(this.vertices), hamonengine.util.bitwise.toggle(this._dirty, 2, !1));
    return this._edges;
  }}, normals:{configurable:!0, enumerable:!0, get:function() {
    hamonengine.util.bitwise.isSet(this._dirty, 0) && (this._normals = hamonengine.geometry.polygon.calcNormals(this.edges), hamonengine.util.bitwise.toggle(this._dirty, 0, !1));
    return this._normals;
  }}, center:{configurable:!0, enumerable:!0, get:function() {
    hamonengine.util.bitwise.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), hamonengine.util.bitwise.toggle(this._dirty, 1, !1));
    return this._dimensions.center;
  }}, max:{configurable:!0, enumerable:!0, get:function() {
    hamonengine.util.bitwise.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), hamonengine.util.bitwise.toggle(this._dirty, 1, !1));
    return this._dimensions.max;
  }}, min:{configurable:!0, enumerable:!0, get:function() {
    hamonengine.util.bitwise.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), hamonengine.util.bitwise.toggle(this._dirty, 1, !1));
    return this._dimensions.min;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this.max.x - this.min.x;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this.max.y - this.min.y;
  }}, shapeType:{configurable:!0, enumerable:!0, get:function() {
    hamonengine.util.bitwise.isSet(this._dirty, 3) && (this._shapeType = hamonengine.geometry.polygon.calcShapeType(this.vertices), hamonengine.util.bitwise.toggle(this._dirty, 3, !1));
    return this._shapeType;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.rect = function $hamonengine$geometry$rect$($x$$, $y$$, $width$$, $height$$) {
    this.x = void 0 === $x$$ ? 0 : $x$$;
    this.y = void 0 === $y$$ ? 0 : $y$$;
    this.width = void 0 === $width$$ ? 0 : $width$$;
    this.height = void 0 === $height$$ ? 0 : $height$$;
  };
  hamonengine.geometry.rect.prototype.clone = function $hamonengine$geometry$rect$$clone$() {
    return new hamonengine.geometry.rect(this.x, this.y, this.width, this.height);
  };
  hamonengine.geometry.rect.prototype.toString = function $hamonengine$geometry$rect$$toString$() {
    return "{x: " + this.x + ", y: " + this.y + ", width: " + this.width + ", height: " + this.height + "}";
  };
  hamonengine.geometry.rect.prototype.toPolygon = function $hamonengine$geometry$rect$$toPolygon$() {
    return new hamonengine.geometry.polygon({vertices:[new hamonengine.geometry.vector2(this.x, this.y), new hamonengine.geometry.vector2(this.x + this.width, this.y), new hamonengine.geometry.vector2(this.x + this.width, this.y + this.height), new hamonengine.geometry.vector2(this.x, this.y + this.height)]});
  };
  hamonengine.geometry.rect.prototype.isCollision = function $hamonengine$geometry$rect$$isCollision$($shape$$) {
    return $shape$$ instanceof hamonengine.geometry.rect ? this.isCollisionRect($shape$$) : $shape$$ instanceof hamonengine.geometry.polygon ? this.isCollisionPolygon($shape$$) : new hamonengine.geometry.vector2(0, 0);
  };
  hamonengine.geometry.rect.prototype.isCollisionRect = function $hamonengine$geometry$rect$$isCollisionRect$($otherRect_other_XAxisProjection_overlappingXAxis$$) {
    $otherRect_other_XAxisProjection_overlappingXAxis$$ instanceof hamonengine.geometry.rect || hamonengine.util.logger.warning("[hamonengine.geometry.rect.isCollision] The otherRect parameter is not of type hamonengine.geometry.rect!");
    var $overlappingLength$$ = NaN, $overlappingYAxis_this_XAxisProjection_this_YAxisProection$$ = new hamonengine.geometry.line(this.y, this.y + this.height), $other_YAxisProection$$ = new hamonengine.geometry.line($otherRect_other_XAxisProjection_overlappingXAxis$$.y, $otherRect_other_XAxisProjection_overlappingXAxis$$.y + $otherRect_other_XAxisProjection_overlappingXAxis$$.height);
    $overlappingYAxis_this_XAxisProjection_this_YAxisProection$$ = $overlappingYAxis_this_XAxisProjection_this_YAxisProection$$.overlap($other_YAxisProection$$);
    if (!$overlappingYAxis_this_XAxisProjection_this_YAxisProection$$.isLine) {
      return new hamonengine.geometry.vector2;
    }
    if (isNaN($overlappingLength$$) || $overlappingYAxis_this_XAxisProjection_this_YAxisProection$$.length < $overlappingLength$$) {
      $overlappingLength$$ = $overlappingYAxis_this_XAxisProjection_this_YAxisProection$$.length;
      var $mtvAxis$$ = hamonengine.geometry.vector2.Y_AXIS_NORMAL;
    }
    $overlappingYAxis_this_XAxisProjection_this_YAxisProection$$ = new hamonengine.geometry.line(this.x, this.x + this.width);
    $otherRect_other_XAxisProjection_overlappingXAxis$$ = new hamonengine.geometry.line($otherRect_other_XAxisProjection_overlappingXAxis$$.x, $otherRect_other_XAxisProjection_overlappingXAxis$$.x + $otherRect_other_XAxisProjection_overlappingXAxis$$.width);
    $otherRect_other_XAxisProjection_overlappingXAxis$$ = $overlappingYAxis_this_XAxisProjection_this_YAxisProection$$.overlap($otherRect_other_XAxisProjection_overlappingXAxis$$);
    if (!$otherRect_other_XAxisProjection_overlappingXAxis$$.isLine) {
      return new hamonengine.geometry.vector2;
    }
    if (isNaN($overlappingLength$$) || $otherRect_other_XAxisProjection_overlappingXAxis$$.length < $overlappingLength$$) {
      $overlappingLength$$ = $otherRect_other_XAxisProjection_overlappingXAxis$$.length, $mtvAxis$$ = hamonengine.geometry.vector2.X_AXIS_NORMAL;
    }
    return $mtvAxis$$.multiply($overlappingLength$$);
  };
  hamonengine.geometry.rect.prototype.isCollisionPolygon = function $hamonengine$geometry$rect$$isCollisionPolygon$($polygon$$) {
    return $polygon$$.isCollision(this.toPolygon());
  };
  hamonengine.geometry.rect.prototype.isContained = function $hamonengine$geometry$rect$$isContained$($position$$, $rect$$) {
    $rect$$ instanceof hamonengine.geometry.rect || hamonengine.util.logger.warning("[hamonengine.geometry.rect.isContained] The rect parameter is not of type hamonengine.geometry.rect!");
    var $outsideDirection$$ = new hamonengine.geometry.vector2, $xOffset$$ = $position$$.x + $rect$$.x, $yOffset$$ = $position$$.y + $rect$$.y;
    $xOffset$$ < this.x ? (hamonengine.util.logger.debug("[hamonengine.geometry.rect.isContained] Outside -x: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.x = -1) : $position$$.x + $rect$$.right > this.right && (hamonengine.util.logger.debug("[hamonengine.geometry.rect.isContained] Outside +x: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.x = 1);
    $yOffset$$ < this.y ? (hamonengine.util.logger.debug("[hamonengine.geometry.rect.isContained] Outside -y: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.y = -1) : $position$$.y + $rect$$.bottom > this.bottom && (hamonengine.util.logger.debug("[hamonengine.geometry.rect.isContained] Outside +y: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.y = 1);
    return $outsideDirection$$;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.rect.prototype, {right:{configurable:!0, enumerable:!0, get:function() {
    return this.x + this.width;
  }}, bottom:{configurable:!0, enumerable:!0, get:function() {
    return this.y + this.height;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
var COLLISION_TYPES = {NONE:0, EDGE:1, INSIDE:2}, COORDINATE_SYSTEM = {LEFT:0, RIGHT:1}, SHAPE_TYPE = {UNKNOWN:0, CONVEX:1, CONCAVE:2};
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.vector2 = function $hamonengine$geometry$vector2$($x$$, $y$$) {
    this.x = void 0 === $x$$ ? 0.0 : $x$$;
    this.y = void 0 === $y$$ ? 0.0 : $y$$;
  };
  hamonengine.geometry.vector2.clone = function $hamonengine$geometry$vector2$clone$($vector$$) {
    return new hamonengine.geometry.vector2($vector$$.x, $vector$$.y);
  };
  hamonengine.geometry.vector2.prototype.clone = function $hamonengine$geometry$vector2$$clone$() {
    return hamonengine.geometry.vector2.clone(this);
  };
  hamonengine.geometry.vector2.prototype.toString = function $hamonengine$geometry$vector2$$toString$() {
    return "{x: '" + this.x + "', y: '" + this.y + "'}";
  };
  hamonengine.geometry.vector2.prototype.normalize = function $hamonengine$geometry$vector2$$normalize$() {
    var $l$$ = this.length;
    return 0 < $l$$ ? new hamonengine.geometry.vector2(this.x / $l$$, this.y / $l$$) : new hamonengine.geometry.vector2;
  };
  hamonengine.geometry.vector2.prototype.normal = function $hamonengine$geometry$vector2$$normal$($coordinateSystem$$) {
    $coordinateSystem$$ = void 0 === $coordinateSystem$$ ? COORDINATE_SYSTEM.LEFT : $coordinateSystem$$;
    var $l$$ = this.length;
    return $coordinateSystem$$ === COORDINATE_SYSTEM.LEFT ? new hamonengine.geometry.vector2(-this.y / $l$$, this.x / $l$$) : new hamonengine.geometry.vector2(this.y / $l$$, -this.x / $l$$);
  };
  hamonengine.geometry.vector2.prototype.mirror = function $hamonengine$geometry$vector2$$mirror$() {
    return new hamonengine.geometry.vector2(-this.x, this.y);
  };
  hamonengine.geometry.vector2.prototype.flip = function $hamonengine$geometry$vector2$$flip$() {
    return new hamonengine.geometry.vector2(this.x, -this.y);
  };
  hamonengine.geometry.vector2.prototype.invert = function $hamonengine$geometry$vector2$$invert$() {
    return new hamonengine.geometry.vector2(-this.x, -this.y);
  };
  hamonengine.geometry.vector2.prototype.add = function $hamonengine$geometry$vector2$$add$($v$$) {
    return new hamonengine.geometry.vector2(this.x + $v$$.x, this.y + $v$$.y);
  };
  hamonengine.geometry.vector2.prototype.subtract = function $hamonengine$geometry$vector2$$subtract$($v$$) {
    return new hamonengine.geometry.vector2(this.x - $v$$.x, this.y - $v$$.y);
  };
  hamonengine.geometry.vector2.prototype.multiply = function $hamonengine$geometry$vector2$$multiply$($vos$$) {
    return $vos$$ instanceof hamonengine.geometry.vector2 ? this.multiplyVector($vos$$) : this.multiplyScalar($vos$$);
  };
  hamonengine.geometry.vector2.prototype.multiplyScalar = function $hamonengine$geometry$vector2$$multiplyScalar$($s$$) {
    return new hamonengine.geometry.vector2(this.x * $s$$, this.y * $s$$);
  };
  hamonengine.geometry.vector2.prototype.multiplyVector = function $hamonengine$geometry$vector2$$multiplyVector$($v$$) {
    return new hamonengine.geometry.vector2(this.x * $v$$.x, this.y * $v$$.y);
  };
  hamonengine.geometry.vector2.prototype.dot = function $hamonengine$geometry$vector2$$dot$($v$$) {
    return this.x * $v$$.x + this.y * $v$$.y;
  };
  hamonengine.geometry.vector2.prototype.cross = function $hamonengine$geometry$vector2$$cross$($v$$) {
    return new hamonengine.geometry.vector3(0, 0, this.x * $v$$.y - this.y * $v$$.x);
  };
  hamonengine.geometry.vector2.prototype.equals = function $hamonengine$geometry$vector2$$equals$($v$$) {
    return this.x === $v$$.x && this.y === $v$$.y;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.vector2.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return (Math.atan2(this.y, this.x) + Math.PI2) % Math.PI2;
  }}});
  hamonengine.geometry.vector2.X_AXIS_NORMAL = new hamonengine.geometry.vector2(1, 0);
  hamonengine.geometry.vector2.Y_AXIS_NORMAL = new hamonengine.geometry.vector2(0, 1);
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.vector3 = function $hamonengine$geometry$vector3$($x$$, $y$$, $z$$) {
    this.x = void 0 === $x$$ ? 0.0 : $x$$;
    this.y = void 0 === $y$$ ? 0.0 : $y$$;
    this.z = void 0 === $z$$ ? 0.0 : $z$$;
  };
  hamonengine.geometry.vector3.clone = function $hamonengine$geometry$vector3$clone$($vector$$) {
    return new hamonengine.geometry.vector3($vector$$.x, $vector$$.y, $vector$$.z);
  };
  hamonengine.geometry.vector3.prototype.clone = function $hamonengine$geometry$vector3$$clone$() {
    return hamonengine.geometry.vector3.clone(this);
  };
  hamonengine.geometry.vector3.prototype.toString = function $hamonengine$geometry$vector3$$toString$() {
    return "{x: '" + this.x + "', y: '" + this.y + "', z: '" + this.z + "'}";
  };
  hamonengine.geometry.vector3.prototype.normalize = function $hamonengine$geometry$vector3$$normalize$() {
    var $l$$ = this.length;
    return 0 < $l$$ ? new hamonengine.geometry.vector3(this.x / $l$$, this.y / $l$$, this.z / $l$$) : new hamonengine.geometry.vector3;
  };
  hamonengine.geometry.vector3.prototype.invert = function $hamonengine$geometry$vector3$$invert$() {
    return new hamonengine.geometry.vector2(-this.x, -this.y, -this.z);
  };
  hamonengine.geometry.vector3.prototype.add = function $hamonengine$geometry$vector3$$add$($v$$) {
    return new hamonengine.geometry.vector3(this.x + $v$$.x, this.y + $v$$.y, this.z + $v$$.z);
  };
  hamonengine.geometry.vector3.prototype.subtract = function $hamonengine$geometry$vector3$$subtract$($v$$) {
    return new hamonengine.geometry.vector3(this.x - $v$$.x, this.y - $v$$.y, this.z - $v$$.z);
  };
  hamonengine.geometry.vector3.prototype.multiplyScalar = function $hamonengine$geometry$vector3$$multiplyScalar$($s$$) {
    return new hamonengine.geometry.vector3(this.x * $s$$, this.y * $s$$, this.z * $s$$);
  };
  hamonengine.geometry.vector3.prototype.multiplyVector = function $hamonengine$geometry$vector3$$multiplyVector$($v$$) {
    return new hamonengine.geometry.vector3(this.x * $v$$.x, this.y * $v$$.y, this.z * $v$$.z);
  };
  hamonengine.geometry.vector3.prototype.dot = function $hamonengine$geometry$vector3$$dot$($v$$) {
    return this.x * $v$$.x + this.y * $v$$.y + this.z * $v$$.z;
  };
  hamonengine.geometry.vector3.prototype.cross = function $hamonengine$geometry$vector3$$cross$($v$$) {
    return new hamonengine.geometry.vector3(this.y * $v$$.z - this.z * $v$$.y, $v$$.x * this.z - this.x * $v$$.z, this.x * $v$$.y - this.y * $v$$.x);
  };
  hamonengine.geometry.vector3.prototype.equals = function $hamonengine$geometry$vector3$$equals$($v$$) {
    return this.x === $v$$.x && this.y === $v$$.y && this.z === $v$$.z;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.vector3.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }}});
  hamonengine.geometry.vector3.X_AXIS_NORMAL = new hamonengine.geometry.vector3(1, 0, 0);
  hamonengine.geometry.vector3.Y_AXIS_NORMAL = new hamonengine.geometry.vector3(0, 1, 0);
  hamonengine.geometry.vector3.Z_AXIS_NORMAL = new hamonengine.geometry.vector3(0, 0, 1);
})();
hamonengine.graphics = hamonengine.graphics || {};
var BLENDING_OPS = {REPLACE:0, ADD:1, MULTIPLY:2, OR:3, AND:4, XOR:5, DIFFERENCE:6}, TEXT_DRAW_TYPE = {STROKE:0, FILL:1};
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.imageext = function $hamonengine$graphics$imageext$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.graphics.imageext && ($options$$ = {image:$options$$._image});
    this._image = $options$$.image || new Image;
    this._state = 0;
    this._backbufferCtx = this._backbufferResource = null;
    hamonengine.util.logger.debug("[hamonengine.graphics.imageext.constructor] Starting State: {" + this._state + "}");
  };
  hamonengine.graphics.imageext.prototype.clone = function $hamonengine$graphics$imageext$$clone$() {
    return new hamonengine.graphics.imageext(this);
  };
  hamonengine.graphics.imageext.prototype.load = function $hamonengine$graphics$imageext$$load$($src$$) {
    var $$jscomp$this$$ = this;
    this.src = $src$$;
    this._state = 1;
    return new Promise(function($resolve$$, $reject$$) {
      $$jscomp$this$$.image.addEventListener("load", function() {
        $$jscomp$this$$._state = 2;
        $resolve$$();
      }, !1);
      $$jscomp$this$$.image.addEventListener("error", function($error$$) {
        $$jscomp$this$$._state = 3;
        $reject$$("The image '" + ($error$$ && $error$$.path && 0 < $error$$.path.length && $error$$.path[0].src || "") + "' could not be loaded.");
      }, !1);
    });
  };
  hamonengine.graphics.imageext.createNewCanvas = function $hamonengine$graphics$imageext$createNewCanvas$($width$$, $height$$, $id$$) {
    $id$$ = void 0 === $id$$ ? "" : $id$$;
    var $canvas$$ = document.createElement("canvas");
    $canvas$$.setAttribute("width", $width$$);
    $canvas$$.setAttribute("height", $height$$);
    $id$$ && $canvas$$.setAttribute("id", $id$$);
    return $canvas$$;
  };
  hamonengine.graphics.imageext.prototype.getImageData = function $hamonengine$graphics$imageext$$getImageData$($region$$) {
    this._backbufferResource = this._backbufferResource || hamonengine.graphics.imageext.createNewCanvas(this.rawImage.width, this.rawImage.height);
    this._backbufferCtx = this._backbufferCtx || this._backbufferResource.getContext("2d");
    this._backbufferCtx.drawImage(this.rawImage, 0, 0);
    $region$$ = $region$$ || new hamonengine.geometry.rect;
    return this._backbufferCtx.getImageData($region$$.x, $region$$.y, $region$$.width || this.rawImage.width, $region$$.height || this.rawImage.height);
  };
  hamonengine.graphics.imageext.prototype.blendColorRegion = function $hamonengine$graphics$imageext$$blendColorRegion$($r$$, $g$$, $b$$, $a$$, $region$$, $blendingOps_data$$) {
    $r$$ = void 0 === $r$$ ? 0 : $r$$;
    $g$$ = void 0 === $g$$ ? 0 : $g$$;
    $b$$ = void 0 === $b$$ ? 0 : $b$$;
    $a$$ = void 0 === $a$$ ? 0 : $a$$;
    $region$$ = void 0 === $region$$ ? null : $region$$;
    $blendingOps_data$$ = void 0 === $blendingOps_data$$ ? BLENDING_OPS.REPLACE : $blendingOps_data$$;
    if (this.complete) {
      var $sourceData$$ = this.getImageData($region$$), $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
        return 0 < $s$$ ? $s$$ : $d$$;
      };
      switch($blendingOps_data$$) {
        case BLENDING_OPS.ADD:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ + $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.MULTIPLY:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ * $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.AND:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ & $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.OR:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ | $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.XOR:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ ^ $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.DIFFERENCE:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ - $d$$, 255) : $d$$;
          };
      }
      $blendingOps_data$$ = $sourceData$$.data;
      for (var $i$$ = 0; $i$$ < $blendingOps_data$$.length; $i$$ += 4) {
        $blendingOps_data$$[$i$$] = $blendingMethod$$($r$$, $blendingOps_data$$[$i$$]), $blendingOps_data$$[$i$$ + 1] = $blendingMethod$$($g$$, $blendingOps_data$$[$i$$ + 1]), $blendingOps_data$$[$i$$ + 2] = $blendingMethod$$($b$$, $blendingOps_data$$[$i$$ + 2]), $blendingOps_data$$[$i$$ + 3] = $blendingMethod$$($a$$, $blendingOps_data$$[$i$$ + 3]);
      }
      this._backbufferCtx.putImageData($sourceData$$, $region$$.x, $region$$.y);
    }
  };
  hamonengine.graphics.imageext.prototype.adjustColorChannel = function $hamonengine$graphics$imageext$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$, $region$$) {
    $r$$ = void 0 === $r$$ ? 1.0 : $r$$;
    $g$$ = void 0 === $g$$ ? 1.0 : $g$$;
    $b$$ = void 0 === $b$$ ? 1.0 : $b$$;
    $a$$ = void 0 === $a$$ ? 1.0 : $a$$;
    $region$$ = void 0 === $region$$ ? null : $region$$;
    if (this.complete) {
      for (var $sourceData$$ = this.getImageData($region$$), $data$$ = $sourceData$$.data, $i$$ = 0; $i$$ < $data$$.length; $i$$ += 4) {
        $data$$[$i$$] = Math.bitRound($data$$[$i$$] * $r$$), $data$$[$i$$ + 1] = Math.bitRound($data$$[$i$$ + 1] * $g$$), $data$$[$i$$ + 2] = Math.bitRound($data$$[$i$$ + 2] * $b$$), $data$$[$i$$ + 3] = Math.bitRound($data$$[$i$$ + 3] * $a$$);
      }
      this._backbufferCtx.putImageData($sourceData$$, $region$$.x, $region$$.y);
    }
  };
  hamonengine.graphics.imageext.prototype.bitblit = function $hamonengine$graphics$imageext$$bitblit$($destData_imageData$$, $srcRegion$$, $destRegion$$, $transparency$$) {
    if (this.complete) {
      $destData_imageData$$ instanceof hamonengine.graphics.imageext && ($destData_imageData$$ = $destData_imageData$$.rawImage);
      $transparency$$ = Math.max(Math.min(void 0 === $transparency$$ ? 1.0 : $transparency$$, 1.0), 0.0);
      var $destImageData$$ = this.getImageData($destRegion$$), $srcData_srcImageData_targetCtx$$ = hamonengine.graphics.imageext.createNewCanvas($destData_imageData$$.width, $destData_imageData$$.height).getContext("2d");
      $srcData_srcImageData_targetCtx$$.drawImage($destData_imageData$$, 0, 0);
      $srcData_srcImageData_targetCtx$$ = $srcData_srcImageData_targetCtx$$.getImageData($srcRegion$$.x, $srcRegion$$.y, $srcRegion$$.width, $srcRegion$$.height);
      $destData_imageData$$ = $destImageData$$.data;
      $srcData_srcImageData_targetCtx$$ = $srcData_srcImageData_targetCtx$$.data;
      for (var $minHeight$$ = Math.max($srcRegion$$.height, $destRegion$$.height), $minWidth$$ = Math.max($srcRegion$$.width, $destRegion$$.width), $row$$ = 0; $row$$ < $minHeight$$; $row$$++) {
        for (var $col$$ = 0; $col$$ < $minWidth$$; $col$$++) {
          var $destIndex$$ = 4 * ($row$$ * $destRegion$$.width + $col$$), $srcIndex$$ = 4 * ($row$$ * $srcRegion$$.width + $col$$), $transparencyComplement$$ = 0 < $srcData_srcImageData_targetCtx$$[$srcIndex$$ + 3] ? 1.0 - $transparency$$ : 1.0;
          $destData_imageData$$[$destIndex$$] = Math.bitRound($destData_imageData$$[$destIndex$$] * $transparencyComplement$$ + $srcData_srcImageData_targetCtx$$[$srcIndex$$] * $transparency$$);
          $destData_imageData$$[$destIndex$$ + 1] = Math.bitRound($destData_imageData$$[$destIndex$$ + 1] * $transparencyComplement$$ + $srcData_srcImageData_targetCtx$$[$srcIndex$$ + 1] * $transparency$$);
          $destData_imageData$$[$destIndex$$ + 2] = Math.bitRound($destData_imageData$$[$destIndex$$ + 2] * $transparencyComplement$$ + $srcData_srcImageData_targetCtx$$[$srcIndex$$ + 2] * $transparency$$);
          $destData_imageData$$[$destIndex$$ + 3] = Math.bitRound($destData_imageData$$[$destIndex$$ + 3] * (1.0 - $transparency$$) + $srcData_srcImageData_targetCtx$$[$srcIndex$$ + 3] * $transparency$$);
        }
      }
      this._backbufferCtx.putImageData($destImageData$$, $destRegion$$.x, $destRegion$$.y);
    }
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.imageext.prototype, {src:{configurable:!0, enumerable:!0, get:function() {
    return this._image.src;
  }, set:function($v$$) {
    this._image.src = $v$$;
  }}, complete:{configurable:!0, enumerable:!0, get:function() {
    return this._image.complete;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return 2 === this._state;
  }}, image:{configurable:!0, enumerable:!0, get:function() {
    return this._backbufferResource ? this._backbufferResource : this._image;
  }}, rawImage:{configurable:!0, enumerable:!0, get:function() {
    return this._image;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.layer = function $hamonengine$graphics$layer$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._canvasId = $options$$.canvasId || "";
    this._name = $options$$.name || "";
    this._alpha = void 0 !== $options$$.alpha ? $options$$.alpha : !1;
    this._allowEventBinding = void 0 !== $options$$.allowEventBinding ? $options$$.allowEventBinding : !1;
    this._wrapVertical = void 0 !== $options$$.wrapVertical ? $options$$.wrapVertical : !1;
    this._wrapHorizontal = void 0 !== $options$$.wrapHorizontal ? $options$$.wrapHorizontal : !1;
    this._clipToViewPort = void 0 !== $options$$.clipToViewPort ? $options$$.clipToViewPort : !0;
    this._enableImageSmoothing = void 0 !== $options$$.enableImageSmoothing ? $options$$.enableImageSmoothing : !0;
    this._invertYAxis = void 0 !== $options$$.invertYAxis ? $options$$.invertYAxis : !1;
    this._invertXAxis = void 0 !== $options$$.invertXAxis ? $options$$.invertXAxis : !1;
    if (!this._canvasId) {
      throw console.error("[hamonengine.graphics.layer.constructor] Invalid canvasId: '" + this._canvasId + "' unable to create the engine!"), "Cannot create the layer";
    }
    this._canvas = document.getElementById(this._canvasId);
    if (!this._canvas) {
      throw console.error("[hamonengine.graphics.layer.constructor] Invalid canvas: '" + this._canvasId + "' unable to create the engine!"), "Cannot create the layer";
    }
    try {
      this._canvasContext = this._canvas.getContext("2d", {alpha:this._alpha});
    } catch ($err$$) {
    }
    this.enableImageSmoothing($options$$.enableImageSmoothing);
    if (!this._canvasContext) {
      throw console.error("[hamonengine.graphics.layer.constructor] Unable to get the 2d context: '" + this._canvasId + "' unable to create the engine!"), "Cannot create the layer";
    }
    this._viewPort = $options$$.viewPort || new hamonengine.geometry.rect(0, 0, this._canvas.width, this._canvas.height);
    this._wasReset = !1;
    this._allowSaveStateEnabled = !0;
    this._viewPortBorderColor = "";
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] Canvas Id: " + this._canvasId);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] Name: " + this._name);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] Alpha: " + this._alpha);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] AllowEventBinding: " + this._allowEventBinding);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] WrapVertical: " + this._wrapVertical);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] WrapHorizontal: " + this._wrapHorizontal);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] ClipToViewPort: " + this._clipToViewPort);
  };
  hamonengine.graphics.layer.prototype.enableImageSmoothing = function $hamonengine$graphics$layer$$enableImageSmoothing$($enable$$) {
    $enable$$ = void 0 === $enable$$ ? !0 : $enable$$;
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] EnableImageSmoothing: " + $enable$$);
    this._enableImageSmoothing = $enable$$;
    try {
      this.context.webkitImageSmoothingEnabled = $enable$$, this.context.mozImageSmoothingEnabled = $enable$$, this.context.imageSmoothingEnabled = $enable$$;
    } catch ($err$$) {
    }
  };
  hamonengine.graphics.layer.prototype.clear = function $hamonengine$graphics$layer$$clear$($x$$, $y$$, $width$$, $height$$) {
    $x$$ = void 0 === $x$$ ? this.viewPort.x : $x$$;
    $y$$ = void 0 === $y$$ ? this.viewPort.y : $y$$;
    $width$$ = void 0 === $width$$ ? this.viewPort.width : $width$$;
    $height$$ = void 0 === $height$$ ? this.viewPort.height : $height$$;
    this._wasReset = !1;
    this.context.clearRect($x$$, $y$$, $width$$, $height$$);
  };
  hamonengine.graphics.layer.prototype.reset = function $hamonengine$graphics$layer$$reset$() {
    this._wasReset || (this.context.resetTransform(), this._wasReset = !0);
  };
  hamonengine.graphics.layer.prototype.save = function $hamonengine$graphics$layer$$save$() {
    this.allowSaveState && this.context.save();
  };
  hamonengine.graphics.layer.prototype.restore = function $hamonengine$graphics$layer$$restore$() {
    this.allowSaveState && this.context.restore();
  };
  hamonengine.graphics.layer.prototype.fillLayerImage = function $hamonengine$graphics$layer$$fillLayerImage$($image$$, $x$$, $y$$) {
    $x$$ = void 0 === $x$$ ? this.viewPort.x : $x$$;
    $y$$ = void 0 === $y$$ ? this.viewPort.y : $y$$;
    this.context.drawImage($image$$, $x$$, $y$$, this.viewPort.width, this.viewPort.height);
  };
  hamonengine.graphics.layer.prototype.beginPainting = function $hamonengine$graphics$layer$$beginPainting$() {
    this.clear();
    this.borderColor && (this.context.strokeStyle = this.borderColor, this.context.strokeRect(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height));
    !this.clipToViewPort || 0 === this.viewPort.x && 0 === this.viewPort.y && this.viewPort.width === this.width && this.viewPort.height === this.height || (this.context.beginPath(), this.context.rect(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height), this.context.clip());
  };
  hamonengine.graphics.layer.prototype.endPainting = function $hamonengine$graphics$layer$$endPainting$() {
    this.reset();
  };
  hamonengine.graphics.layer.prototype.drawText = function $hamonengine$graphics$layer$$drawText$($text$$, $sourceX$$, $sourceY$$, $font$$, $color$$, $textDrawType$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    $color$$ = void 0 === $color$$ ? "white" : $color$$;
    $textDrawType$$ = void 0 === $textDrawType$$ ? TEXT_DRAW_TYPE.FILL : $textDrawType$$;
    this.context.font = void 0 === $font$$ ? "16px serif" : $font$$;
    this.context.textBaseline = "top";
    $textDrawType$$ === TEXT_DRAW_TYPE.STROKE ? (this.context.strokeStyle = $color$$, this.context.strokeText($text$$, $sourceX$$, $sourceY$$)) : (this.context.fillStyle = $color$$, this.context.fillText($text$$, $sourceX$$, $sourceY$$));
  };
  hamonengine.graphics.layer.prototype.drawImage = function $hamonengine$graphics$layer$$drawImage$($image$$, $sourceX$$, $sourceY$$, $sourceWidth$$, $sourceHeight$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$) {
    $image$$.complete && this.context.drawImage($image$$ instanceof hamonengine.graphics.imageext ? $image$$.image : $image$$, $sourceX$$, $sourceY$$, $sourceWidth$$, $sourceHeight$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$);
  };
  hamonengine.graphics.layer.prototype.drawRect = function $hamonengine$graphics$layer$$drawRect$($rect$$, $sourceX$jscomp$2_x$$, $sourceY$jscomp$2_y$$, $lineWidth$$, $color$$) {
    if (!($rect$$ instanceof hamonengine.geometry.rect)) {
      throw "Parameter rect is not of type hamonengine.geometry.rect.";
    }
    this.context.lineWidth = void 0 === $lineWidth$$ ? 1 : $lineWidth$$;
    this.context.strokeStyle = void 0 === $color$$ ? "white" : $color$$;
    $sourceX$jscomp$2_x$$ = $rect$$.x + (void 0 === $sourceX$jscomp$2_x$$ ? 0 : $sourceX$jscomp$2_x$$);
    $sourceY$jscomp$2_y$$ = $rect$$.y + (void 0 === $sourceY$jscomp$2_y$$ ? 0 : $sourceY$jscomp$2_y$$);
    this.invertYAxis && ($sourceY$jscomp$2_y$$ = this.viewPort.height - $sourceY$jscomp$2_y$$);
    this.invertXAxis && ($sourceX$jscomp$2_x$$ = this.viewPort.width - $sourceX$jscomp$2_x$$);
    this.context.beginPath();
    this.context.moveTo($sourceX$jscomp$2_x$$, $sourceY$jscomp$2_y$$);
    this.context.lineTo($sourceX$jscomp$2_x$$ + $rect$$.width, $sourceY$jscomp$2_y$$);
    this.context.lineTo($sourceX$jscomp$2_x$$ + $rect$$.width, $sourceY$jscomp$2_y$$ + $rect$$.height);
    this.context.lineTo($sourceX$jscomp$2_x$$, $sourceY$jscomp$2_y$$ + $rect$$.height);
    this.context.closePath();
    this.context.stroke();
  };
  hamonengine.graphics.layer.prototype.drawPolygon = function $hamonengine$graphics$layer$$drawPolygon$($polygon$$, $sourceX$$, $sourceY$$, $lineWidth$$, $color$$, $drawNormals$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    $lineWidth$$ = void 0 === $lineWidth$$ ? 1 : $lineWidth$$;
    $color$$ = void 0 === $color$$ ? "white" : $color$$;
    $drawNormals$$ = void 0 === $drawNormals$$ ? !1 : $drawNormals$$;
    this.simpleDrawPolygon($polygon$$, $sourceX$$, $sourceY$$, $lineWidth$$, $color$$, $drawNormals$$);
    if (this.wrapHorizontal) {
      var $xOffset$jscomp$2_yOffset$$ = $sourceX$$ + $polygon$$.min.x - this.viewPort.x;
      0 >= $xOffset$jscomp$2_yOffset$$ && this.simpleDrawPolygon($polygon$$, this.viewPort.width + $xOffset$jscomp$2_yOffset$$, $sourceY$$, $lineWidth$$, $color$$, $drawNormals$$);
      $sourceX$$ + $polygon$$.width >= this.viewPort.width && this.simpleDrawPolygon($polygon$$, this.viewPort.x - (this.viewPort.width - ($sourceX$$ + $polygon$$.min.x)), $sourceY$$, $lineWidth$$, $color$$, $drawNormals$$);
    }
    this.wrapVertical && ($xOffset$jscomp$2_yOffset$$ = $sourceY$$ + $polygon$$.min.y - this.viewPort.y, 0 >= $xOffset$jscomp$2_yOffset$$ && this.simpleDrawPolygon($polygon$$, $sourceX$$, this.viewPort.height + $xOffset$jscomp$2_yOffset$$, $lineWidth$$, $color$$, $drawNormals$$), $sourceY$$ + $polygon$$.height >= this.viewPort.height && this.simpleDrawPolygon($polygon$$, $sourceX$$, this.viewPort.y - (this.viewPort.height - ($sourceY$$ + $polygon$$.min.y)), $lineWidth$$, $color$$, $drawNormals$$));
  };
  hamonengine.graphics.layer.prototype.simpleDrawPolygon = function $hamonengine$graphics$layer$$simpleDrawPolygon$($polygon$$, $sourceX$$, $sourceY$$, $index$jscomp$47_lineWidth$$, $color$jscomp$5_edge$jscomp$1_normalSize_x$$, $drawNormals$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    $drawNormals$$ = void 0 === $drawNormals$$ ? !1 : $drawNormals$$;
    if (!($polygon$$ instanceof hamonengine.geometry.polygon)) {
      throw "Parameter polygon is not of type hamonengine.geometry.polygon.";
    }
    this.context.lineWidth = void 0 === $index$jscomp$47_lineWidth$$ ? 1 : $index$jscomp$47_lineWidth$$;
    this.context.strokeStyle = void 0 === $color$jscomp$5_edge$jscomp$1_normalSize_x$$ ? "white" : $color$jscomp$5_edge$jscomp$1_normalSize_x$$;
    this.context.beginPath();
    for ($index$jscomp$47_lineWidth$$ = 0; $index$jscomp$47_lineWidth$$ < $polygon$$.vertices.length; $index$jscomp$47_lineWidth$$++) {
      $color$jscomp$5_edge$jscomp$1_normalSize_x$$ = Math.bitRound($sourceX$$ + $polygon$$.vertices[$index$jscomp$47_lineWidth$$].x);
      var $vertex_y$8_y$$ = Math.bitRound($sourceY$$ + $polygon$$.vertices[$index$jscomp$47_lineWidth$$].y);
      this.invertYAxis && ($vertex_y$8_y$$ = this.viewPort.height - $vertex_y$8_y$$);
      this.invertXAxis && ($color$jscomp$5_edge$jscomp$1_normalSize_x$$ = this.viewPort.width - $color$jscomp$5_edge$jscomp$1_normalSize_x$$);
      0 === $index$jscomp$47_lineWidth$$ ? this.context.moveTo($color$jscomp$5_edge$jscomp$1_normalSize_x$$, $vertex_y$8_y$$) : this.context.lineTo($color$jscomp$5_edge$jscomp$1_normalSize_x$$, $vertex_y$8_y$$);
    }
    this.context.closePath();
    this.context.stroke();
    if (hamonengine.debug && $drawNormals$$) {
      for (this.context.strokeStyle = "white", $drawNormals$$ = 0; $drawNormals$$ < $polygon$$.vertices.length; $drawNormals$$++) {
        $vertex_y$8_y$$ = $polygon$$.vertices[$drawNormals$$];
        $color$jscomp$5_edge$jscomp$1_normalSize_x$$ = $polygon$$.edges[$drawNormals$$];
        $index$jscomp$47_lineWidth$$ = Math.bitRound($sourceX$$ + $vertex_y$8_y$$.x + $color$jscomp$5_edge$jscomp$1_normalSize_x$$.x / 2);
        $vertex_y$8_y$$ = Math.bitRound($sourceY$$ + $vertex_y$8_y$$.y + $color$jscomp$5_edge$jscomp$1_normalSize_x$$.y / 2);
        this.invertYAxis && ($vertex_y$8_y$$ = this.viewPort.height - $vertex_y$8_y$$);
        this.invertXAxis && ($index$jscomp$47_lineWidth$$ = this.viewPort.width - $index$jscomp$47_lineWidth$$);
        this.context.beginPath();
        this.context.moveTo($index$jscomp$47_lineWidth$$, $vertex_y$8_y$$);
        var $normal$$ = $polygon$$.normals[$drawNormals$$];
        $color$jscomp$5_edge$jscomp$1_normalSize_x$$ = Math.bitRound($color$jscomp$5_edge$jscomp$1_normalSize_x$$.length / 2);
        $normal$$ = $normal$$.invert();
        this.invertYAxis && ($normal$$.y = -$normal$$.y);
        this.invertXAxis && ($normal$$.x = -$normal$$.x);
        this.context.lineTo($index$jscomp$47_lineWidth$$ + $normal$$.x * $color$jscomp$5_edge$jscomp$1_normalSize_x$$, $vertex_y$8_y$$ + $normal$$.y * $color$jscomp$5_edge$jscomp$1_normalSize_x$$);
        this.context.stroke();
      }
    }
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.layer.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, allowEventBinding:{configurable:!0, enumerable:!0, get:function() {
    return this._allowEventBinding;
  }}, context:{configurable:!0, enumerable:!0, get:function() {
    return this._canvasContext;
  }}, canvas:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas;
  }}, clipToViewPort:{configurable:!0, enumerable:!0, get:function() {
    return this._clipToViewPort;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas.width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas.height;
  }}, offsetX:{configurable:!0, enumerable:!0, get:function() {
    return this.canvas.offsetLeft;
  }}, offsetY:{configurable:!0, enumerable:!0, get:function() {
    return this.canvas.offsetTop;
  }}, viewPort:{configurable:!0, enumerable:!0, get:function() {
    return this._viewPort;
  }}, wrapHorizontal:{configurable:!0, enumerable:!0, get:function() {
    return this._wrapHorizontal;
  }, set:function($v$$) {
    this._wrapHorizontal = $v$$;
  }}, wrapVertical:{configurable:!0, enumerable:!0, get:function() {
    return this._wrapVertical;
  }, set:function($v$$) {
    this._wrapVertical = $v$$;
  }}, allowSaveState:{configurable:!0, enumerable:!0, get:function() {
    return this._allowSaveStateEnabled;
  }, set:function($v$$) {
    this._allowSaveStateEnabled = $v$$;
  }}, borderColor:{configurable:!0, enumerable:!0, get:function() {
    return this._viewPortBorderColor;
  }, set:function($v$$) {
    this._viewPortBorderColor = $v$$;
  }}, invertYAxis:{configurable:!0, enumerable:!0, get:function() {
    return this._invertYAxis;
  }, set:function($v$$) {
    this._invertYAxis = $v$$;
  }}, invertXAxis:{configurable:!0, enumerable:!0, get:function() {
    return this._invertXAxis;
  }, set:function($v$$) {
    this._invertXAxis = $v$$;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.sprite = function $hamonengine$graphics$sprite$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.graphics.sprite && ($options$$ = {name:$options$$.name, image:$options$$._image && $options$$._image.clone(), dimensions:$options$$._dimensions, theta:$options$$.theta});
    this._name = $options$$.name;
    this._image = $options$$.image;
    this._dimensions = $options$$.dimensions || new hamonengine.geometry.rect;
    this._theta = $options$$.theta || 0.0;
    this._scaleVector = new hamonengine.geometry.vector2(1.0, 1.0);
    this._spriteOrientation = 0;
    this._showFullImage = this._showDiagnosisLines = !1;
    this._maxWrapping = 0;
    hamonengine.util.logger.debug("[hamonengine.graphics.sprite.constructor] Starting Dimensions: {" + this._dimensions.toString() + "}");
    hamonengine.util.logger.debug("[hamonengine.graphics.sprite.constructor] Name: " + this._name);
    hamonengine.util.logger.debug("[hamonengine.graphics.sprite.constructor] Theta: " + this._theta);
    hamonengine.util.logger.debug("[hamonengine.graphics.sprite.constructor] ScaleVector: {" + this._scaleVector.toString() + "}");
  };
  hamonengine.graphics.sprite.prototype.copyProperties = function $hamonengine$graphics$sprite$$copyProperties$($properties$$) {
    this._theta = $properties$$.theta;
    this._scaleVector = $properties$$._scaleVector;
    this._spriteOrientation = $properties$$._spriteOrientation;
    this._showDiagnosisLines = $properties$$._showDiagnosisLines;
    this._showFullImage = $properties$$._showFullImage;
  };
  hamonengine.graphics.sprite.prototype.clone = function $hamonengine$graphics$sprite$$clone$() {
    return new hamonengine.graphics.sprite(this);
  };
  hamonengine.graphics.sprite.prototype.rotate = function $hamonengine$graphics$sprite$$rotate$($theta$$) {
    this._theta = $theta$$ || 0.0;
  };
  hamonengine.graphics.sprite.prototype.scale = function $hamonengine$graphics$sprite$$scale$($x$$, $y$$) {
    this._scaleVector.x = $x$$;
    this._scaleVector.y = $y$$;
  };
  hamonengine.graphics.sprite.prototype.mirror = function $hamonengine$graphics$sprite$$mirror$($state$$) {
    this._spriteOrientation = hamonengine.util.bitwise.toggle(this._spriteOrientation, 2, $state$$);
  };
  hamonengine.graphics.sprite.prototype.flip = function $hamonengine$graphics$sprite$$flip$($state$$) {
    this._spriteOrientation = hamonengine.util.bitwise.toggle(this._spriteOrientation, 1, $state$$);
  };
  hamonengine.graphics.sprite.prototype.blendColor = function $hamonengine$graphics$sprite$$blendColor$($r$$, $g$$, $b$$, $a$$, $blendingOps$$) {
    $blendingOps$$ = void 0 === $blendingOps$$ ? BLENDING_OPS.REPLACE : $blendingOps$$;
    this._image.blendColorRegion(void 0 === $r$$ ? 0 : $r$$, void 0 === $g$$ ? 0 : $g$$, void 0 === $b$$ ? 0 : $b$$, void 0 === $a$$ ? 0 : $a$$, this._dimensions, $blendingOps$$);
  };
  hamonengine.graphics.sprite.prototype.adjustColorChannel = function $hamonengine$graphics$sprite$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$) {
    this._image.adjustColorChannel(void 0 === $r$$ ? 1.0 : $r$$, void 0 === $g$$ ? 1.0 : $g$$, void 0 === $b$$ ? 1.0 : $b$$, void 0 === $a$$ ? 1.0 : $a$$, this._dimensions);
  };
  hamonengine.graphics.sprite.prototype.bitblit = function $hamonengine$graphics$sprite$$bitblit$($sprite$$, $transparency$$) {
    this._image.bitblit($sprite$$._image, $sprite$$._dimensions, this._dimensions, void 0 === $transparency$$ ? 1.0 : $transparency$$);
  };
  hamonengine.graphics.sprite.prototype.drawRaw = function $hamonengine$graphics$sprite$$drawRaw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this._dimensions.width : $width$$;
    $height$$ = void 0 === $height$$ ? this._dimensions.height : $height$$;
    this._image.complete && (this.showFullImage ? $layer$$.context.drawImage(this._image.image, Math.bitRound($x$$), Math.bitRound($y$$), Math.bitRound($width$$), Math.bitRound($height$$)) : $layer$$.drawImage(this._image, this._dimensions.x, this._dimensions.y, this._dimensions.width, this._dimensions.height, Math.bitRound($x$$), Math.bitRound($y$$), Math.bitRound($width$$), Math.bitRound($height$$)));
  };
  hamonengine.graphics.sprite.prototype.draw = function $hamonengine$graphics$sprite$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this._dimensions.width : $width$$;
    $height$$ = void 0 === $height$$ ? this._dimensions.height : $height$$;
    $x$$ = Math.bitRound($x$$);
    $y$$ = Math.bitRound($y$$);
    var $xCenterOffset_xCenterOffset$9$$ = Math.bitRound($width$$ / 2) + $x$$, $yCenterOffset_yCenterOffset$10$$ = Math.bitRound($height$$ / 2) + $y$$, $yOrientation$$ = hamonengine.util.bitwise.isSet(this._spriteOrientation, 1) ? -1.0 : 1.0, $xOrientation$$ = hamonengine.util.bitwise.isSet(this._spriteOrientation, 2) ? -1.0 : 1.0;
    $layer$$.save();
    if (1 !== this._scaleVector.x || 1 !== this._scaleVector.y) {
      $layer$$.context.translate($x$$, $y$$), $layer$$.context.scale(this._scaleVector.x, this._scaleVector.y), $layer$$.context.translate(-$x$$, -$y$$);
    }
    0 < this._spriteOrientation && ($layer$$.context.translate($xCenterOffset_xCenterOffset$9$$, $yCenterOffset_yCenterOffset$10$$), $layer$$.context.scale($xOrientation$$, $yOrientation$$), $layer$$.context.translate(-$xCenterOffset_xCenterOffset$9$$, -$yCenterOffset_yCenterOffset$10$$));
    0.0 !== this.theta && ($layer$$.context.translate($xCenterOffset_xCenterOffset$9$$, $yCenterOffset_yCenterOffset$10$$), $layer$$.context.rotate(this.theta), $layer$$.context.translate(-$xCenterOffset_xCenterOffset$9$$, -$yCenterOffset_yCenterOffset$10$$));
    ($layer$$.wrapHorizontal || $layer$$.wrapVertical) && this.drawSpriteWrapping($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$, $xOrientation$$, $yOrientation$$);
    this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$);
    if (hamonengine.debug && this.showDiagnosisLines) {
      $xCenterOffset_xCenterOffset$9$$ = Math.bitRound($width$$ / 2) + $x$$;
      $yCenterOffset_yCenterOffset$10$$ = Math.bitRound($height$$ / 2) + $y$$;
      if ($layer$$.wrapHorizontal || $layer$$.wrapVertical) {
        $layer$$.context.strokeStyle = "red", $layer$$.context.lineWidth = 2, $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$9$$, $yCenterOffset_yCenterOffset$10$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$9$$ + $layer$$.viewPort.width, $yCenterOffset_yCenterOffset$10$$), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$9$$, $yCenterOffset_yCenterOffset$10$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$9$$ - 
        $layer$$.viewPort.width, $yCenterOffset_yCenterOffset$10$$), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$9$$, $yCenterOffset_yCenterOffset$10$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$9$$, $yCenterOffset_yCenterOffset$10$$ + $layer$$.viewPort.height), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$9$$, $yCenterOffset_yCenterOffset$10$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$9$$, 
        $yCenterOffset_yCenterOffset$10$$ - $layer$$.viewPort.height), $layer$$.context.stroke(), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$ + $layer$$.viewPort.width, $y$$, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$ - $layer$$.viewPort.width, $y$$, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$ + $layer$$.viewPort.height, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$ - 
        $layer$$.viewPort.height, $width$$, $height$$), $layer$$.context.strokeStyle = "white", $layer$$.context.strokeRect($xCenterOffset_xCenterOffset$9$$ - $layer$$.viewPort.width / 2, $yCenterOffset_yCenterOffset$10$$ - $layer$$.viewPort.height / 2, $layer$$.viewPort.width, $layer$$.viewPort.height);
      }
      $layer$$.context.strokeStyle = "red";
      $layer$$.context.strokeRect($x$$, $y$$, $width$$, $height$$);
      $layer$$.context.strokeStyle = "cyan";
      $layer$$.context.strokeRect($layer$$.viewPort.x, $layer$$.viewPort.y, $layer$$.viewPort.width, $layer$$.viewPort.height);
    }
    $layer$$.restore();
  };
  hamonengine.graphics.sprite.prototype.drawSpriteWrapping = function $hamonengine$graphics$sprite$$drawSpriteWrapping$($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$92_xOffset$$, $y$jscomp$72_yOffset$$, $width$$, $height$$, $xOrientation$$, $yOrientation$$) {
    var $cosAngle_wrapLoop$12_wrapLoop$13$$ = Math.cos(-this.theta), $sinAngle$$ = Math.sin(-this.theta), $widthScaled_wrapLoop_wrapLoop$11$$ = $width$$ * this._scaleVector.x, $heightScaled$$ = $height$$ * this._scaleVector.y, $wrappingDirection$$ = new hamonengine.geometry.vector2;
    if ($layer$$.wrapHorizontal) {
      var $horizontalLength_v1y$$ = $layer$$.viewPort.width / this._scaleVector.x * $xOrientation$$;
      var $v1x$$ = Math.bitRound($cosAngle_wrapLoop$12_wrapLoop$13$$ * $horizontalLength_v1y$$);
      $horizontalLength_v1y$$ = Math.bitRound($sinAngle$$ * $horizontalLength_v1y$$);
      if ($x$jscomp$92_xOffset$$ - $widthScaled_wrapLoop_wrapLoop$11$$ <= $layer$$.viewPort.x) {
        if ($wrappingDirection$$.x = 1, $widthScaled_wrapLoop_wrapLoop$11$$ = Math.abs(parseInt(($x$jscomp$92_xOffset$$ - $widthScaled_wrapLoop_wrapLoop$11$$) / $layer$$.viewPort.width, 10)) + 1, 0 === this._maxWrapping || $widthScaled_wrapLoop_wrapLoop$11$$ < this._maxWrapping) {
          this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$92_xOffset$$ + $v1x$$ * $widthScaled_wrapLoop_wrapLoop$11$$, $y$jscomp$72_yOffset$$ + $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$11$$, $width$$, $height$$), 0 < --$widthScaled_wrapLoop_wrapLoop$11$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$92_xOffset$$ + $v1x$$ * $widthScaled_wrapLoop_wrapLoop$11$$, $y$jscomp$72_yOffset$$ + $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$11$$, 
          $width$$, $height$$);
        }
      } else {
        $x$jscomp$92_xOffset$$ + $widthScaled_wrapLoop_wrapLoop$11$$ >= $layer$$.viewPort.width && ($wrappingDirection$$.x = -1, $widthScaled_wrapLoop_wrapLoop$11$$ = parseInt(($x$jscomp$92_xOffset$$ + $widthScaled_wrapLoop_wrapLoop$11$$) / $layer$$.viewPort.width, 10), 0 === this._maxWrapping || $widthScaled_wrapLoop_wrapLoop$11$$ < this._maxWrapping) && (this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$92_xOffset$$ - $v1x$$ * $widthScaled_wrapLoop_wrapLoop$11$$, $y$jscomp$72_yOffset$$ - 
        $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$11$$, $width$$, $height$$), 0 < --$widthScaled_wrapLoop_wrapLoop$11$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$92_xOffset$$ - $v1x$$ * $widthScaled_wrapLoop_wrapLoop$11$$, $y$jscomp$72_yOffset$$ - $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$11$$, $width$$, $height$$));
      }
    }
    if ($layer$$.wrapVertical) {
      var $v2y_verticalLength$$ = $layer$$.viewPort.height / this._scaleVector.y * $yOrientation$$;
      var $v2x$$ = Math.bitRound($sinAngle$$ * $v2y_verticalLength$$);
      $v2y_verticalLength$$ = Math.bitRound($cosAngle_wrapLoop$12_wrapLoop$13$$ * $v2y_verticalLength$$);
      if ($y$jscomp$72_yOffset$$ - $heightScaled$$ <= $layer$$.viewPort.y) {
        if ($wrappingDirection$$.y = 1, $cosAngle_wrapLoop$12_wrapLoop$13$$ = Math.abs(parseInt(($y$jscomp$72_yOffset$$ - $heightScaled$$) / $layer$$.viewPort.height, 10)) + 1, 0 === this._maxWrapping || $cosAngle_wrapLoop$12_wrapLoop$13$$ < this._maxWrapping) {
          this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$92_xOffset$$ - $v2x$$ * $cosAngle_wrapLoop$12_wrapLoop$13$$, $y$jscomp$72_yOffset$$ + $v2y_verticalLength$$ * $cosAngle_wrapLoop$12_wrapLoop$13$$, $width$$, $height$$), 0 < --$cosAngle_wrapLoop$12_wrapLoop$13$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$92_xOffset$$ - $v2x$$ * $cosAngle_wrapLoop$12_wrapLoop$13$$, $y$jscomp$72_yOffset$$ + $v2y_verticalLength$$ * $cosAngle_wrapLoop$12_wrapLoop$13$$, $width$$, 
          $height$$);
        }
      } else {
        $y$jscomp$72_yOffset$$ + $heightScaled$$ >= $layer$$.viewPort.height && ($wrappingDirection$$.y = -1, $cosAngle_wrapLoop$12_wrapLoop$13$$ = parseInt(($y$jscomp$72_yOffset$$ + $heightScaled$$) / $layer$$.viewPort.height, 10), 0 === this._maxWrapping || $cosAngle_wrapLoop$12_wrapLoop$13$$ < this._maxWrapping) && (this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$92_xOffset$$ + $v2x$$ * $cosAngle_wrapLoop$12_wrapLoop$13$$, $y$jscomp$72_yOffset$$ - $v2y_verticalLength$$ * $cosAngle_wrapLoop$12_wrapLoop$13$$, 
        $width$$, $height$$), 0 < --$cosAngle_wrapLoop$12_wrapLoop$13$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$92_xOffset$$ + $v2x$$ * $cosAngle_wrapLoop$12_wrapLoop$13$$, $y$jscomp$72_yOffset$$ - $v2y_verticalLength$$ * $cosAngle_wrapLoop$12_wrapLoop$13$$, $width$$, $height$$));
      }
    }
    $layer$$.wrapVertical && $layer$$.wrapHorizontal && ($x$jscomp$92_xOffset$$ = $x$jscomp$92_xOffset$$ - $wrappingDirection$$.y * $v2x$$ + $wrappingDirection$$.x * $v1x$$, $y$jscomp$72_yOffset$$ = $y$jscomp$72_yOffset$$ + $wrappingDirection$$.y * $v2y_verticalLength$$ + $wrappingDirection$$.x * $horizontalLength_v1y$$, $x$jscomp$92_xOffset$$ && $y$jscomp$72_yOffset$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$92_xOffset$$, $y$jscomp$72_yOffset$$, $width$$, $height$$));
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.sprite.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return this._theta;
  }}, showDiagnosisLines:{configurable:!0, enumerable:!0, get:function() {
    return this._showDiagnosisLines;
  }, set:function($v$$) {
    this._showDiagnosisLines = $v$$;
  }}, showFullImage:{configurable:!0, enumerable:!0, get:function() {
    return this._showFullImage;
  }, set:function($v$$) {
    this._showFullImage = $v$$;
  }}, maxWrapping:{configurable:!0, enumerable:!0, set:function($v$$) {
    this._maxWrapping = $v$$;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.animsprite = function $hamonengine$graphics$animsprite$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.graphics.sprite.call(this, $options$$);
    $options$$ instanceof hamonengine.graphics.animsprite && ($options$$ = {frames:$options$$._frames.map(function($frame$$) {
      return $frame$$.clone();
    }), animationRate:$options$$._animationRate, animationCycles:$options$$._animationCycles});
    this._frames = $options$$.frames || [];
    this._animationRate = $options$$.animationRate || 0;
    this._animationCycles = $options$$.animationCycles || -1;
    this._numberOfAnimationCycles = this._timeSinceLastFrame = this._index = 0;
    this._enableAnimation = !0;
    hamonengine.util.logger.debug("[hamonengine.graphics.animsprite.constructor] Starting Animation Rate: " + this._animationRate);
    hamonengine.util.logger.debug("[hamonengine.graphics.animsprite.constructor] Starting Animation Cycle: " + this._animationCycles);
    hamonengine.util.logger.debug("[hamonengine.graphics.animsprite.constructor] Starting Index: " + this._index);
    hamonengine.util.logger.debug("[hamonengine.graphics.animsprite.constructor] Starting Enable Animation: " + this._enableAnimation);
  };
  $jscomp.inherits(hamonengine.graphics.animsprite, hamonengine.graphics.sprite);
  hamonengine.graphics.animsprite.prototype.clone = function $hamonengine$graphics$animsprite$$clone$() {
    return new hamonengine.graphics.animsprite(this);
  };
  hamonengine.graphics.animsprite.prototype.start = function $hamonengine$graphics$animsprite$$start$() {
    this._enableAnimation = !0;
    this._numberOfAnimationCycles = 0;
  };
  hamonengine.graphics.animsprite.prototype.stop = function $hamonengine$graphics$animsprite$$stop$() {
    this._enableAnimation = !1;
  };
  hamonengine.graphics.animsprite.prototype.pause = function $hamonengine$graphics$animsprite$$pause$() {
    this._enableAnimation = !this._enableAnimation;
  };
  hamonengine.graphics.animsprite.prototype.addFrame = function $hamonengine$graphics$animsprite$$addFrame$($frame$$) {
    hamonengine.util.logger.debug("[hamonengine.graphics.animsprite.animsprite.addFrame]");
    this._frames.push($frame$$);
  };
  hamonengine.graphics.animsprite.prototype.blendColor = function $hamonengine$graphics$animsprite$$blendColor$($r$$, $g$$, $b$$, $a$$, $blendingOps$$) {
    $r$$ = void 0 === $r$$ ? 0 : $r$$;
    $g$$ = void 0 === $g$$ ? 0 : $g$$;
    $b$$ = void 0 === $b$$ ? 0 : $b$$;
    $a$$ = void 0 === $a$$ ? 0 : $a$$;
    $blendingOps$$ = void 0 === $blendingOps$$ ? BLENDING_OPS.REPLACE : $blendingOps$$;
    for (var $i$$ = 0; $i$$ < this._frames.length; $i$$++) {
      this._frames[$i$$].blendColor($r$$, $g$$, $b$$, $a$$, $blendingOps$$);
    }
  };
  hamonengine.graphics.animsprite.prototype.adjustColorChannel = function $hamonengine$graphics$animsprite$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$) {
    $r$$ = void 0 === $r$$ ? 1.0 : $r$$;
    $g$$ = void 0 === $g$$ ? 1.0 : $g$$;
    $b$$ = void 0 === $b$$ ? 1.0 : $b$$;
    $a$$ = void 0 === $a$$ ? 1.0 : $a$$;
    for (var $i$$ = 0; $i$$ < this._frames.length; $i$$++) {
      this._frames[$i$$].adjustColorChannel($r$$, $g$$, $b$$, $a$$);
    }
  };
  hamonengine.graphics.animsprite.prototype.draw = function $hamonengine$graphics$animsprite$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? null : $width$$;
    $height$$ = void 0 === $height$$ ? null : $height$$;
    var $timeSinceLastFrame$$ = this._timeSinceLastFrame + $elapsedTimeInMilliseconds$$;
    if (this._enableAnimation) {
      var $numberOfAnimationCycles_numberOfFrames$$ = parseInt($timeSinceLastFrame$$ / this.animationRate, 10);
      $numberOfAnimationCycles_numberOfFrames$$ = this.index + $numberOfAnimationCycles_numberOfFrames$$;
      -1 < this.animationCycles && (this._numberOfAnimationCycles += parseInt($numberOfAnimationCycles_numberOfFrames$$ / this._frames.length, 10), this._enableAnimation = this._numberOfAnimationCycles <= this.animationCycles);
      this.index = $numberOfAnimationCycles_numberOfFrames$$ % this._frames.length;
    }
    0 < this._frames.length && (this._frames[this.index].copyProperties(this), this._frames[this.index].draw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$));
    this._timeSinceLastFrame = $timeSinceLastFrame$$ % this.animationRate;
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.animsprite.prototype, {index:{configurable:!0, enumerable:!0, get:function() {
    return this._index;
  }, set:function($v$$) {
    this._index = $v$$ % this._frames.length || 0;
  }}, animationRate:{configurable:!0, enumerable:!0, get:function() {
    return this._animationRate;
  }, set:function($v$$) {
    this._animationRate = $v$$;
  }}, animationCycles:{configurable:!0, enumerable:!0, get:function() {
    return this._animationCycles;
  }, set:function($v$$) {
    this._animationCycles = $v$$;
    this._enableAnimation = !0;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.spritesheet = function $hamonengine$graphics$spritesheet$($options$$) {
    this._imageResource = new hamonengine.graphics.imageext;
    this._sprites = {};
    this._spriteIndex = [];
  };
  hamonengine.graphics.spritesheet.prototype.load = function $hamonengine$graphics$spritesheet$$load$($spriteSheetMetadata$$) {
    for (var $resourceLoadingPromise$$ = this._imageResource.load($spriteSheetMetadata$$.spritesheetUrl), $i$14_i$$ = 0; $i$14_i$$ < $spriteSheetMetadata$$.sprites.length; $i$14_i$$++) {
      var $animSpriteMetadata_spriteMetadata$$ = $spriteSheetMetadata$$.sprites[$i$14_i$$];
      this._spriteIndex.push($animSpriteMetadata_spriteMetadata$$.name);
      this._sprites[$animSpriteMetadata_spriteMetadata$$.name] = new hamonengine.graphics.sprite({image:this._imageResource, name:$animSpriteMetadata_spriteMetadata$$.name, dimensions:new hamonengine.geometry.rect($animSpriteMetadata_spriteMetadata$$.x, $animSpriteMetadata_spriteMetadata$$.y, $animSpriteMetadata_spriteMetadata$$.width, $animSpriteMetadata_spriteMetadata$$.height)});
    }
    for ($i$14_i$$ = 0; $i$14_i$$ < $spriteSheetMetadata$$.animSprites.length; $i$14_i$$++) {
      $animSpriteMetadata_spriteMetadata$$ = $spriteSheetMetadata$$.animSprites[$i$14_i$$];
      for (var $animatedSprite$$ = new hamonengine.graphics.animsprite({animationRate:$animSpriteMetadata_spriteMetadata$$.animationRate}), $j$$ = 0; $j$$ < $animSpriteMetadata_spriteMetadata$$.frames.length; $j$$++) {
        var $frameMetadata$$ = $animSpriteMetadata_spriteMetadata$$.frames[$j$$];
        $animatedSprite$$.addFrame(new hamonengine.graphics.sprite({image:this._imageResource, name:$frameMetadata$$.name, dimensions:new hamonengine.geometry.rect($frameMetadata$$.x, $frameMetadata$$.y, $frameMetadata$$.width, $frameMetadata$$.height)}));
      }
      this._spriteIndex.push($animSpriteMetadata_spriteMetadata$$.name);
      this._sprites[$animSpriteMetadata_spriteMetadata$$.name] = $animatedSprite$$;
    }
    return $resourceLoadingPromise$$;
  };
  hamonengine.graphics.spritesheet.prototype.getSprite = function $hamonengine$graphics$spritesheet$$getSprite$($spriteName$$) {
    return this._sprites[$spriteName$$].clone();
  };
  hamonengine.graphics.spritesheet.prototype.getSpriteByOrdinal = function $hamonengine$graphics$spritesheet$$getSpriteByOrdinal$($index$$) {
    return this._sprites[this._spriteIndex[$index$$]].clone();
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.spritesheet.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return this._spriteIndex.length;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._imageResource.isLoaded();
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.object2d = function $hamonengine$entities$object2d$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._name = $options$$.name || "";
    this._boundingShape = $options$$.boundingShape;
    this._width = $options$$.width || 0;
    this._height = $options$$.height || 0;
    this._zindex = $options$$.zindex || 0;
    this._movementRate = $options$$.movementRate || 0;
    this._position = $options$$.position || new hamonengine.geometry.vector2;
    this._direction = $options$$.direction || new hamonengine.geometry.vector2;
    this._theta = $options$$.theta || 0.0;
    this._isSolid = void 0 === $options$$.isSolid ? !0 : !1;
    this._isMoveable = void 0 === $options$$.isMoveable ? !1 : !0;
    this._isVisible = void 0 === $options$$.isVisible ? !0 : !1;
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Name: " + this.name);
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Starting Dimensions {Width: " + this.width + ", Height: " + this.height + "}");
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Starting Direction: {x: " + this.direction.x + ", y: " + this.direction.y + "}");
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Starting Position: {x: " + this.position.x + ", y: " + this.position.y + "}");
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Starting Theta: " + this.theta);
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Movement Rate: " + this._movementRate);
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] isSolid: " + this.isSolid);
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] isMoveable: " + this.isMoveable);
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] isVisible: " + this.isVisible);
  };
  hamonengine.entities.object2d.prototype.move = function $hamonengine$entities$object2d$$move$($elapsedTimeInMilliseconds$$, $movementVector$$) {
    this.isMoveable && ($movementVector$$ = (void 0 === $movementVector$$ ? null : $movementVector$$) || this.calcMove($elapsedTimeInMilliseconds$$), this.position.x += $movementVector$$.x, this.position.y += $movementVector$$.y);
  };
  hamonengine.entities.object2d.prototype.calcMove = function $hamonengine$entities$object2d$$calcMove$($elapsedTimeInMilliseconds$$) {
    return new hamonengine.geometry.vector2(this._movementRate * this.direction.x * $elapsedTimeInMilliseconds$$, this._movementRate * this.direction.y * $elapsedTimeInMilliseconds$$);
  };
  hamonengine.entities.object2d.prototype.isCollision = function $hamonengine$entities$object2d$$isCollision$($object$$) {
    return this.boundingShape.isCollision($object$$);
  };
  hamonengine.entities.object2d.prototype.isContained = function $hamonengine$entities$object2d$$isContained$($targetObject$$) {
    return this.boundingShape.isContained($targetObject$$.position, $targetObject$$.boundingShape);
  };
  hamonengine.entities.object2d.prototype.render = function $hamonengine$entities$object2d$$render$($layer$$, $elapsedTimeInMilliseconds$$) {
  };
  hamonengine.entities.object2d.prototype.toString = function $hamonengine$entities$object2d$$toString$() {
    return "{name: '" + this.name + "', position: '" + this.position + "'}";
  };
  hamonengine.entities.object2d.prototype.onEnvironmentCollision = function $hamonengine$entities$object2d$$onEnvironmentCollision$($position$$, $environmentObject$$) {
    this._position = $position$$;
    return !0;
  };
  hamonengine.entities.object2d.prototype.onObjectCollision = function $hamonengine$entities$object2d$$onObjectCollision$($x$$, $y$$, $object$$) {
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.object2d.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, position:{configurable:!0, enumerable:!0, get:function() {
    return this._position;
  }, set:function($v$$) {
    this._position = $v$$;
  }}, direction:{configurable:!0, enumerable:!0, get:function() {
    return this._direction;
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return this._theta || 0.0;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._height;
  }}, zIndex:{configurable:!0, enumerable:!0, get:function() {
    return this._zindex;
  }, set:function($v$$) {
    this._zindex = $v$$;
  }}, boundingShape:{configurable:!0, enumerable:!0, get:function() {
    return this._boundingShape = this._boundingShape || new hamonengine.geometry.rect(0, 0, this.width, this.height);
  }}, isMoveable:{configurable:!0, enumerable:!0, get:function() {
    return this._isMoveable;
  }}, isSolid:{configurable:!0, enumerable:!0, get:function() {
    return this._isSolid;
  }}, isVisible:{configurable:!0, enumerable:!0, get:function() {
    return this._isVisible;
  }, set:function($v$$) {
    this._isVisible = $v$$;
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.cell = function $hamonengine$entities$cell$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.entities.object2d.call(this, $options$$);
    this._movementRate = 0;
    this._direction = new hamonengine.geometry.vector2;
    this._theta = 0;
    this._children = [];
    this._objects = [];
    this._zIndexSorter = new hamonengine.math.sort({compareFunc:function($a$$, $b$$) {
      return $a$$ === $b$$ ? 0 : $a$$.zIndex < $b$$.zIndex ? -1 : 1;
    }});
  };
  $jscomp.inherits(hamonengine.entities.cell, hamonengine.entities.object2d);
  hamonengine.entities.cell.prototype.addChild = function $hamonengine$entities$cell$$addChild$($child$$) {
    this._children.push($child$$);
  };
  hamonengine.entities.cell.prototype.addObject = function $hamonengine$entities$cell$$addObject$($object$$) {
    this._objects.push($object$$);
  };
  hamonengine.entities.cell.prototype.addObjects = function $hamonengine$entities$cell$$addObjects$($objects$$) {
    for (var $i$$ = 0; $i$$ < $objects$$.length; $i$$++) {
      this._objects.push($objects$$[$i$$]);
    }
  };
  hamonengine.entities.cell.prototype.process = function $hamonengine$entities$cell$$process$($elapsedTimeInMilliseconds$$) {
    if (this.objects) {
      for (var $collisionsEdges$$ = new Set, $i$$ = 0; $i$$ < this.objects.length; $i$$++) {
        var $object$$ = this.objects[$i$$];
        if ($object$$.isMoveable && ($object$$.move($elapsedTimeInMilliseconds$$), this.isSolid)) {
          var $adjustedPosition_i$15$$ = hamonengine.geometry.vector2.clone($object$$.position), $collisionVector_siblingObject$$ = this.isContained($object$$);
          0 > $collisionVector_siblingObject$$.x ? $adjustedPosition_i$15$$.x = this.boundingShape.x - $object$$.boundingShape.x : 0 < $collisionVector_siblingObject$$.x && ($adjustedPosition_i$15$$.x = this.boundingShape.width - $object$$.boundingShape.right);
          0 > $collisionVector_siblingObject$$.y ? $adjustedPosition_i$15$$.y = this.boundingShape.y - $object$$.boundingShape.y : 0 < $collisionVector_siblingObject$$.y && ($adjustedPosition_i$15$$.y = this.boundingShape.height - $object$$.boundingShape.bottom);
          if (!$object$$.onEnvironmentCollision($adjustedPosition_i$15$$, this)) {
            break;
          }
        }
        for ($adjustedPosition_i$15$$ = 0; $adjustedPosition_i$15$$ < this.objects.length; $adjustedPosition_i$15$$++) {
          if ($collisionVector_siblingObject$$ = this.objects[$adjustedPosition_i$15$$], $object$$ !== $collisionVector_siblingObject$$) {
            var $edgeName$$ = $object$$.name + "->" + $collisionVector_siblingObject$$.name;
            $collisionsEdges$$.has($edgeName$$) || ($collisionsEdges$$.add($edgeName$$), $collisionsEdges$$.add($collisionVector_siblingObject$$.name + "->" + $object$$.name));
          }
        }
      }
    }
  };
  hamonengine.entities.cell.prototype.render = function $hamonengine$entities$cell$$render$($layer$$, $elapsedTimeInMilliseconds$$) {
    if (this.objects && (this._zIndexSorter.quickSort(this._objects), this.objects)) {
      for (var $i$$ = 0; $i$$ < this.objects.length; $i$$++) {
        this.objects[$i$$].render($layer$$, $elapsedTimeInMilliseconds$$);
      }
    }
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.cell.prototype, {children:{configurable:!0, enumerable:!0, get:function() {
    return this._children;
  }}, objects:{configurable:!0, enumerable:!0, get:function() {
    return this._objects;
  }}});
})();
hamonengine.core = hamonengine.core || {};
(function() {
  hamonengine.core.engine = function $hamonengine$core$engine$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.util.logger.info("HamonEngine -- Using version: 0.1.0");
    this._movementRate = $options$$.movementRate || 0.25;
    this._size = $options$$.size || 64;
    this._showFPS = void 0 !== $options$$.showFPS ? $options$$.showFPS : !1;
    this._animationId = this._lastFrameTimeStamp = this._startTimeStamp = this._state = 0;
    this._fpsCounter = new hamonengine.util.fpscounter;
    this._layers = {};
    for (var $index$$ = 0, $i$$ = 0; $i$$ < $options$$.canvas.length; $i$$++) {
      var $canvas$$ = $options$$.canvas[$i$$], $canvasName$$ = $canvas$$.name || "canvas" + $index$$++;
      this._layers[$canvasName$$] = new hamonengine.graphics.layer({name:$canvasName$$, canvasId:$canvas$$.id, viewPort:$canvas$$.viewPort, allowEventBinding:$canvas$$.allowEventBinding, enableImageSmoothing:$options$$.enableImageSmoothing, clipToViewPort:$canvas$$.clipToViewPort});
    }
    this._resourcesLoaded = !1;
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] MovementRate: " + this._movementRate);
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] State: " + this._state);
  };
  hamonengine.core.engine.prototype.getLayer = function $hamonengine$core$engine$$getLayer$($name$$) {
    return this._layers[$name$$];
  };
  hamonengine.core.engine.prototype.load = function $hamonengine$core$engine$$load$() {
    var $$jscomp$this$$ = this;
    hamonengine.util.logger.info("[hamonengine.core.engine.load]");
    this.onPreload();
    this._state = 2;
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] State: " + this._state);
    return new Promise(function($resolve$$, $reject$$) {
      $$jscomp$this$$.onEventBinding().then(function() {
        hamonengine.util.logger.info("[hamonengine.core.engine.load] Event binding completed.");
      });
      $$jscomp$this$$.onloadResources().then(function() {
        $$jscomp$this$$._resourcesLoaded = !0;
        hamonengine.util.logger.info("[hamonengine.core.engine.load] Load resources completed.");
        $resolve$$($$jscomp$this$$);
      }).catch(function($error$$) {
        hamonengine.util.logger.info("[hamonengine.core.engine.load] Failed!");
        $$jscomp$this$$.stop();
        $reject$$();
      });
    });
  };
  hamonengine.core.engine.prototype.start = function $hamonengine$core$engine$$start$() {
    hamonengine.util.logger.info("[hamonengine.core.engine.start]");
    2 === this._state && (this._state = 1, hamonengine.util.logger.debug("[hamonengine.core.engine.start] State: " + this._state), this.fpsCounter.start(), this.onDraw(0));
    return this;
  };
  hamonengine.core.engine.prototype.stop = function $hamonengine$core$engine$$stop$() {
    hamonengine.util.logger.info("[hamonengine.core.engine.stop]");
    window.cancelAnimationFrame(this._animationId);
    this._state = this._startTimeStamp = this._animationId = 0;
    hamonengine.util.logger.debug("[hamonengine.core.engine.stop] State: " + this._state);
    return this;
  };
  hamonengine.core.engine.prototype.onPreload = function $hamonengine$core$engine$$onPreload$() {
    hamonengine.util.logger.info("[hamonengine.core.engine.onPreload]");
  };
  hamonengine.core.engine.prototype.onloadResources = function $hamonengine$core$engine$$onloadResources$() {
    hamonengine.util.logger.info("[hamonengine.core.engine.onloadResources]");
    return Promise.resolve();
  };
  hamonengine.core.engine.prototype.onEventBinding = function $hamonengine$core$engine$$onEventBinding$() {
    var $$jscomp$this$$ = this;
    return new Promise(function($resolve$$, $reject$$) {
      window.addEventListener("DOMContentLoaded", function($event$$) {
        $$jscomp$this$$._layers.forEach(function($key$$, $layer$$) {
          if ($layer$$.allowEventBinding) {
            var $mouseEvent$$ = function $$mouseEvent$$$($type$$, $e$$) {
              return $$jscomp$this$$.onMouseEvent($type$$, new hamonengine.geometry.vector2($e$$.clientX, $e$$.clientY), $e$$, $layer$$);
            }, $touchEvent$$ = function $$touchEvent$$$($type$$, $e$$) {
              for (var $touches$$ = [], $i$$ = 0; $i$$ < $e$$.touches.length; $i$$++) {
                $touches$$.push({left:$e$$.touches[$i$$].clientX - ($layer$$.offsetX || 0), top:$e$$.touches[$i$$].clientY - ($layer$$.offsetY || 0)});
              }
              $$jscomp$this$$.onTouchEvent($type$$, $e$$, $touches$$, $layer$$);
            };
            $layer$$.canvas.addEventListener("keyup", function($e$$) {
              return $$jscomp$this$$.onKeyEvent("up", $e$$.code, $e$$, $layer$$);
            });
            $layer$$.canvas.addEventListener("keydown", function($e$$) {
              return $$jscomp$this$$.onKeyEvent("down", $e$$.code, $e$$, $layer$$);
            });
            $layer$$.canvas.addEventListener("click", function($e$$) {
              $$jscomp$this$$.onMouseClick($e$$, $layer$$);
            });
            $layer$$.canvas.addEventListener("mouseup", function($e$$) {
              return $mouseEvent$$("up", $e$$);
            });
            $layer$$.canvas.addEventListener("mousedown", function($e$$) {
              return $mouseEvent$$("down", $e$$);
            });
            $layer$$.canvas.addEventListener("touchstart", function($e$$) {
              return $touchEvent$$("start", $e$$);
            });
            $layer$$.canvas.addEventListener("touchmove", function($e$$) {
              return $touchEvent$$("move", $e$$);
            });
            $layer$$.canvas.addEventListener("touchend", function($e$$) {
              return $$jscomp$this$$.onTouchEnd($e$$, $layer$$);
            });
            $layer$$.canvas.addEventListener("touchcancel", function($e$$) {
              return $$jscomp$this$$.onTouchCancel($e$$, $layer$$);
            });
          }
        });
      });
      $resolve$$();
    });
  };
  hamonengine.core.engine.prototype.onMouseClick = function $hamonengine$core$engine$$onMouseClick$($e$$, $layer$$) {
    hamonengine.util.logger.debug("[hamonengine.core.engine.onMouseClick] '" + $e$$ + "'");
  };
  hamonengine.core.engine.prototype.onMouseEvent = function $hamonengine$core$engine$$onMouseEvent$($type$$, $v$$, $e$$, $layer$$) {
    hamonengine.util.logger.debug("[hamonengine.core.engine.onMouseEvent] Type: '" + $type$$ + "' '" + $v$$.toString() + "'");
  };
  hamonengine.core.engine.prototype.onKeyEvent = function $hamonengine$core$engine$$onKeyEvent$($type$$, $keyCode$$, $e$$, $layer$$) {
    $e$$ && $e$$.preventDefault();
    hamonengine.util.logger.debug("[hamonengine.core.engine.onKeyEvent] Type: '" + $type$$ + "' '" + $keyCode$$ + "'");
  };
  hamonengine.core.engine.prototype.onTouchEvent = function $hamonengine$core$engine$$onTouchEvent$($type$$, $e$$, $touches$$, $layer$$) {
    $e$$ && $e$$.preventDefault();
    hamonengine.util.logger.debug("[hamonengine.core.engine.onTouchEvent] Type: '" + $type$$ + "' '" + $e$$ + "'");
  };
  hamonengine.core.engine.prototype.onTouchEnd = function $hamonengine$core$engine$$onTouchEnd$($e$$, $layer$$) {
    $e$$ && $e$$.preventDefault();
    hamonengine.util.logger.debug("[hamonengine.core.engine.onTouchEnd] '" + $e$$ + "'");
  };
  hamonengine.core.engine.prototype.onTouchCancel = function $hamonengine$core$engine$$onTouchCancel$($e$$, $layer$$) {
    $e$$ && $e$$.preventDefault();
    hamonengine.util.logger.debug("[hamonengine.core.engine.onTouchCancel] '" + $e$$ + "'");
  };
  hamonengine.core.engine.prototype.onDraw = function $hamonengine$core$engine$$onDraw$($timestampInMilliseconds$$) {
    var $$jscomp$this$$ = this;
    $timestampInMilliseconds$$ = $timestampInMilliseconds$$ || 0;
    this._startTimeStamp || (this._startTimeStamp = $timestampInMilliseconds$$);
    var $elapsedTimeInMilliseconds$$ = $timestampInMilliseconds$$ - this._lastFrameTimeStamp;
    try {
      this._animationId = window.requestAnimationFrame(function($scopedTimestampInMS$$) {
        $$jscomp$this$$._state = 3;
        $$jscomp$this$$.onFrame($elapsedTimeInMilliseconds$$);
        $$jscomp$this$$.onDraw($scopedTimestampInMS$$);
      });
    } catch ($exception$$) {
      this.stop(), hamonengine.util.logger.debug($exception$$);
    }
    this._lastFrameTimeStamp = $timestampInMilliseconds$$;
    return this;
  };
  hamonengine.core.engine.prototype.onFrame = function $hamonengine$core$engine$$onFrame$($elapsedTimeInMilliseconds$$) {
    return this;
  };
  $jscomp.global.Object.defineProperties(hamonengine.core.engine.prototype, {primaryLayer:{configurable:!0, enumerable:!0, get:function() {
    return this._layers.canvas0;
  }}, resourcesLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._resourcesLoaded;
  }}, fpsCounter:{configurable:!0, enumerable:!0, get:function() {
    return this._fpsCounter;
  }}});
})();

