/*
 Hamonengine 波紋
 Copyright \(c\) 2020-2023, CaffeinatedRat.
 All rights reserved.
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
 EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.createTemplateTagFirstArg = function $$jscomp$createTemplateTagFirstArg$($arrayStrings$$) {
  return $arrayStrings$$.raw = $arrayStrings$$;
};
$jscomp.createTemplateTagFirstArgWithRaw = function $$jscomp$createTemplateTagFirstArgWithRaw$($arrayStrings$$, $rawArrayStrings$$) {
  $arrayStrings$$.raw = $rawArrayStrings$$;
  return $arrayStrings$$;
};
$jscomp.arrayIteratorImpl = function $$jscomp$arrayIteratorImpl$($array$$) {
  var $index$$ = 0;
  return function() {
    return $index$$ < $array$$.length ? {done:!1, value:$array$$[$index$$++], } : {done:!0};
  };
};
$jscomp.arrayIterator = function $$jscomp$arrayIterator$($array$$) {
  return {next:$jscomp.arrayIteratorImpl($array$$)};
};
$jscomp.makeIterator = function $$jscomp$makeIterator$($iterable$$) {
  var $iteratorFunction$$ = "undefined" != typeof Symbol && Symbol.iterator && $iterable$$[Symbol.iterator];
  return $iteratorFunction$$ ? $iteratorFunction$$.call($iterable$$) : $jscomp.arrayIterator($iterable$$);
};
$jscomp.arrayFromIterator = function $$jscomp$arrayFromIterator$($iterator$$) {
  for (var $i$$, $arr$$ = []; !($i$$ = $iterator$$.next()).done;) {
    $arr$$.push($i$$.value);
  }
  return $arr$$;
};
$jscomp.arrayFromIterable = function $$jscomp$arrayFromIterable$($iterable$$) {
  return $iterable$$ instanceof Array ? $iterable$$ : $jscomp.arrayFromIterator($jscomp.makeIterator($iterable$$));
};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.SIMPLE_FROUND_POLYFILL = !1;
$jscomp.ISOLATE_POLYFILLS = !1;
$jscomp.objectCreate = $jscomp.ASSUME_ES5 || "function" == typeof Object.create ? Object.create : function($prototype$$) {
  var $ctor$$ = function $$ctor$$$() {
  };
  $ctor$$.prototype = $prototype$$;
  return new $ctor$$;
};
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function($target$$, $property$$, $descriptor$$) {
  if ($target$$ == Array.prototype || $target$$ == Object.prototype) {
    return $target$$;
  }
  $target$$[$property$$] = $descriptor$$.value;
  return $target$$;
};
$jscomp.getGlobal = function $$jscomp$getGlobal$($passedInThis_possibleGlobals$$) {
  $passedInThis_possibleGlobals$$ = ["object" == typeof globalThis && globalThis, $passedInThis_possibleGlobals$$, "object" == typeof window && window, "object" == typeof self && self, "object" == typeof global && global, ];
  for (var $i$$ = 0; $i$$ < $passedInThis_possibleGlobals$$.length; ++$i$$) {
    var $maybeGlobal$$ = $passedInThis_possibleGlobals$$[$i$$];
    if ($maybeGlobal$$ && $maybeGlobal$$.Math == Math) {
      return $maybeGlobal$$;
    }
  }
  throw Error("Cannot find global object");
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.IS_SYMBOL_NATIVE = "function" === typeof Symbol && "symbol" === typeof Symbol("x");
$jscomp.TRUST_ES6_POLYFILLS = !$jscomp.ISOLATE_POLYFILLS || $jscomp.IS_SYMBOL_NATIVE;
$jscomp.polyfills = {};
$jscomp.propertyToPolyfillSymbol = {};
$jscomp.POLYFILL_PREFIX = "$jscp$";
var $jscomp$lookupPolyfilledValue = function $$jscomp$lookupPolyfilledValue$($target$$, $key$$) {
  var $polyfill_polyfilledKey$$ = $jscomp.propertyToPolyfillSymbol[$key$$];
  if (null == $polyfill_polyfilledKey$$) {
    return $target$$[$key$$];
  }
  $polyfill_polyfilledKey$$ = $target$$[$polyfill_polyfilledKey$$];
  return void 0 !== $polyfill_polyfilledKey$$ ? $polyfill_polyfilledKey$$ : $target$$[$key$$];
};
$jscomp.polyfill = function $$jscomp$polyfill$($target$$, $polyfill$$, $fromLang$$, $toLang$$) {
  $polyfill$$ && ($jscomp.ISOLATE_POLYFILLS ? $jscomp.polyfillIsolated($target$$, $polyfill$$, $fromLang$$, $toLang$$) : $jscomp.polyfillUnisolated($target$$, $polyfill$$, $fromLang$$, $toLang$$));
};
$jscomp.polyfillUnisolated = function $$jscomp$polyfillUnisolated$($property$jscomp$5_split_target$$, $impl_polyfill$$, $fromLang$jscomp$1_obj$$, $i$jscomp$5_orig_toLang$$) {
  $fromLang$jscomp$1_obj$$ = $jscomp.global;
  $property$jscomp$5_split_target$$ = $property$jscomp$5_split_target$$.split(".");
  for ($i$jscomp$5_orig_toLang$$ = 0; $i$jscomp$5_orig_toLang$$ < $property$jscomp$5_split_target$$.length - 1; $i$jscomp$5_orig_toLang$$++) {
    var $key$$ = $property$jscomp$5_split_target$$[$i$jscomp$5_orig_toLang$$];
    if (!($key$$ in $fromLang$jscomp$1_obj$$)) {
      return;
    }
    $fromLang$jscomp$1_obj$$ = $fromLang$jscomp$1_obj$$[$key$$];
  }
  $property$jscomp$5_split_target$$ = $property$jscomp$5_split_target$$[$property$jscomp$5_split_target$$.length - 1];
  $i$jscomp$5_orig_toLang$$ = $fromLang$jscomp$1_obj$$[$property$jscomp$5_split_target$$];
  $impl_polyfill$$ = $impl_polyfill$$($i$jscomp$5_orig_toLang$$);
  $impl_polyfill$$ != $i$jscomp$5_orig_toLang$$ && null != $impl_polyfill$$ && $jscomp.defineProperty($fromLang$jscomp$1_obj$$, $property$jscomp$5_split_target$$, {configurable:!0, writable:!0, value:$impl_polyfill$$});
};
$jscomp.polyfillIsolated = function $$jscomp$polyfillIsolated$($isNativeClass_target$$, $impl$jscomp$1_polyfill$$, $fromLang$$, $obj$jscomp$27_root$jscomp$3_toLang$$) {
  var $property$jscomp$6_split$$ = $isNativeClass_target$$.split(".");
  $isNativeClass_target$$ = 1 === $property$jscomp$6_split$$.length;
  $obj$jscomp$27_root$jscomp$3_toLang$$ = $property$jscomp$6_split$$[0];
  $obj$jscomp$27_root$jscomp$3_toLang$$ = !$isNativeClass_target$$ && $obj$jscomp$27_root$jscomp$3_toLang$$ in $jscomp.polyfills ? $jscomp.polyfills : $jscomp.global;
  for (var $i$$ = 0; $i$$ < $property$jscomp$6_split$$.length - 1; $i$$++) {
    var $key$$ = $property$jscomp$6_split$$[$i$$];
    if (!($key$$ in $obj$jscomp$27_root$jscomp$3_toLang$$)) {
      return;
    }
    $obj$jscomp$27_root$jscomp$3_toLang$$ = $obj$jscomp$27_root$jscomp$3_toLang$$[$key$$];
  }
  $property$jscomp$6_split$$ = $property$jscomp$6_split$$[$property$jscomp$6_split$$.length - 1];
  $fromLang$$ = $jscomp.IS_SYMBOL_NATIVE && "es6" === $fromLang$$ ? $obj$jscomp$27_root$jscomp$3_toLang$$[$property$jscomp$6_split$$] : null;
  $impl$jscomp$1_polyfill$$ = $impl$jscomp$1_polyfill$$($fromLang$$);
  null != $impl$jscomp$1_polyfill$$ && ($isNativeClass_target$$ ? $jscomp.defineProperty($jscomp.polyfills, $property$jscomp$6_split$$, {configurable:!0, writable:!0, value:$impl$jscomp$1_polyfill$$}) : $impl$jscomp$1_polyfill$$ !== $fromLang$$ && ($jscomp.propertyToPolyfillSymbol[$property$jscomp$6_split$$] = $jscomp.IS_SYMBOL_NATIVE ? $jscomp.global.Symbol($property$jscomp$6_split$$) : $jscomp.POLYFILL_PREFIX + $property$jscomp$6_split$$, $property$jscomp$6_split$$ = $jscomp.propertyToPolyfillSymbol[$property$jscomp$6_split$$], 
  $jscomp.defineProperty($obj$jscomp$27_root$jscomp$3_toLang$$, $property$jscomp$6_split$$, {configurable:!0, writable:!0, value:$impl$jscomp$1_polyfill$$})));
};
$jscomp.getConstructImplementation = function $$jscomp$getConstructImplementation$() {
  function $reflectConstructWorks$$() {
    function $Base$$() {
    }
    new $Base$$;
    Reflect.construct($Base$$, [], function Derived() {
    });
    return new $Base$$ instanceof $Base$$;
  }
  if ($jscomp.TRUST_ES6_POLYFILLS && "undefined" != typeof Reflect && Reflect.construct) {
    if ($reflectConstructWorks$$()) {
      return Reflect.construct;
    }
    var $brokenConstruct$$ = Reflect.construct;
    return function($out_target$$, $argList$$, $opt_newTarget$$) {
      $out_target$$ = $brokenConstruct$$($out_target$$, $argList$$);
      $opt_newTarget$$ && Reflect.setPrototypeOf($out_target$$, $opt_newTarget$$.prototype);
      return $out_target$$;
    };
  }
  return function construct($target$$, $argList$$, $obj$jscomp$28_opt_newTarget$$) {
    void 0 === $obj$jscomp$28_opt_newTarget$$ && ($obj$jscomp$28_opt_newTarget$$ = $target$$);
    $obj$jscomp$28_opt_newTarget$$ = $jscomp.objectCreate($obj$jscomp$28_opt_newTarget$$.prototype || Object.prototype);
    return Function.prototype.apply.call($target$$, $obj$jscomp$28_opt_newTarget$$, $argList$$) || $obj$jscomp$28_opt_newTarget$$;
  };
};
$jscomp.construct = {valueOf:$jscomp.getConstructImplementation}.valueOf();
$jscomp.underscoreProtoCanBeSet = function $$jscomp$underscoreProtoCanBeSet$() {
  var $x$$ = {a:!0}, $y$$ = {};
  try {
    return $y$$.__proto__ = $x$$, $y$$.a;
  } catch ($e$$) {
  }
  return !1;
};
$jscomp.setPrototypeOf = $jscomp.TRUST_ES6_POLYFILLS && "function" == typeof Object.setPrototypeOf ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function($target$$, $proto$$) {
  $target$$.__proto__ = $proto$$;
  if ($target$$.__proto__ !== $proto$$) {
    throw new TypeError($target$$ + " is not extensible");
  }
  return $target$$;
} : null;
$jscomp.inherits = function $$jscomp$inherits$($childCtor$$, $parentCtor$$) {
  $childCtor$$.prototype = $jscomp.objectCreate($parentCtor$$.prototype);
  $childCtor$$.prototype.constructor = $childCtor$$;
  if ($jscomp.setPrototypeOf) {
    var $p_setPrototypeOf$$ = $jscomp.setPrototypeOf;
    $p_setPrototypeOf$$($childCtor$$, $parentCtor$$);
  } else {
    for ($p_setPrototypeOf$$ in $parentCtor$$) {
      if ("prototype" != $p_setPrototypeOf$$) {
        if (Object.defineProperties) {
          var $descriptor$$ = Object.getOwnPropertyDescriptor($parentCtor$$, $p_setPrototypeOf$$);
          $descriptor$$ && Object.defineProperty($childCtor$$, $p_setPrototypeOf$$, $descriptor$$);
        } else {
          $childCtor$$[$p_setPrototypeOf$$] = $parentCtor$$[$p_setPrototypeOf$$];
        }
      }
    }
  }
  $childCtor$$.superClass_ = $parentCtor$$.prototype;
};
$jscomp.generator = {};
$jscomp.generator.ensureIteratorResultIsObject_ = function $$jscomp$generator$ensureIteratorResultIsObject_$($result$$) {
  if (!($result$$ instanceof Object)) {
    throw new TypeError("Iterator result " + $result$$ + " is not an object");
  }
};
$jscomp.generator.Context = function $$jscomp$generator$Context$() {
  this.isRunning_ = !1;
  this.yieldAllIterator_ = null;
  this.yieldResult = void 0;
  this.nextAddress = 1;
  this.finallyAddress_ = this.catchAddress_ = 0;
  this.finallyContexts_ = this.abruptCompletion_ = null;
};
$jscomp.generator.Context.prototype.start_ = function $$jscomp$generator$Context$$start_$() {
  if (this.isRunning_) {
    throw new TypeError("Generator is already running");
  }
  this.isRunning_ = !0;
};
$jscomp.generator.Context.prototype.stop_ = function $$jscomp$generator$Context$$stop_$() {
  this.isRunning_ = !1;
};
$jscomp.generator.Context.prototype.jumpToErrorHandler_ = function $$jscomp$generator$Context$$jumpToErrorHandler_$() {
  this.nextAddress = this.catchAddress_ || this.finallyAddress_;
};
$jscomp.generator.Context.prototype.next_ = function $$jscomp$generator$Context$$next_$($value$$) {
  this.yieldResult = $value$$;
};
$jscomp.generator.Context.prototype.throw_ = function $$jscomp$generator$Context$$throw_$($e$$) {
  this.abruptCompletion_ = {exception:$e$$, isException:!0};
  this.jumpToErrorHandler_();
};
$jscomp.generator.Context.prototype.return = function $$jscomp$generator$Context$$return$($value$$) {
  this.abruptCompletion_ = {return:$value$$};
  this.nextAddress = this.finallyAddress_;
};
$jscomp.generator.Context.prototype.jumpThroughFinallyBlocks = function $$jscomp$generator$Context$$jumpThroughFinallyBlocks$($nextAddress$$) {
  this.abruptCompletion_ = {jumpTo:$nextAddress$$};
  this.nextAddress = this.finallyAddress_;
};
$jscomp.generator.Context.prototype.yield = function $$jscomp$generator$Context$$yield$($value$$, $resumeAddress$$) {
  this.nextAddress = $resumeAddress$$;
  return {value:$value$$};
};
$jscomp.generator.Context.prototype.yieldAll = function $$jscomp$generator$Context$$yieldAll$($iterable$jscomp$5_iterator$$, $resumeAddress$$) {
  $iterable$jscomp$5_iterator$$ = $jscomp.makeIterator($iterable$jscomp$5_iterator$$);
  var $result$$ = $iterable$jscomp$5_iterator$$.next();
  $jscomp.generator.ensureIteratorResultIsObject_($result$$);
  if ($result$$.done) {
    this.yieldResult = $result$$.value, this.nextAddress = $resumeAddress$$;
  } else {
    return this.yieldAllIterator_ = $iterable$jscomp$5_iterator$$, this.yield($result$$.value, $resumeAddress$$);
  }
};
$jscomp.generator.Context.prototype.jumpTo = function $$jscomp$generator$Context$$jumpTo$($nextAddress$$) {
  this.nextAddress = $nextAddress$$;
};
$jscomp.generator.Context.prototype.jumpToEnd = function $$jscomp$generator$Context$$jumpToEnd$() {
  this.nextAddress = 0;
};
$jscomp.generator.Context.prototype.setCatchFinallyBlocks = function $$jscomp$generator$Context$$setCatchFinallyBlocks$($catchAddress$$, $finallyAddress$$) {
  this.catchAddress_ = $catchAddress$$;
  void 0 != $finallyAddress$$ && (this.finallyAddress_ = $finallyAddress$$);
};
$jscomp.generator.Context.prototype.setFinallyBlock = function $$jscomp$generator$Context$$setFinallyBlock$($finallyAddress$$) {
  this.catchAddress_ = 0;
  this.finallyAddress_ = $finallyAddress$$ || 0;
};
$jscomp.generator.Context.prototype.leaveTryBlock = function $$jscomp$generator$Context$$leaveTryBlock$($nextAddress$$, $catchAddress$$) {
  this.nextAddress = $nextAddress$$;
  this.catchAddress_ = $catchAddress$$ || 0;
};
$jscomp.generator.Context.prototype.enterCatchBlock = function $$jscomp$generator$Context$$enterCatchBlock$($exception$$) {
  this.catchAddress_ = $exception$$ || 0;
  $exception$$ = this.abruptCompletion_.exception;
  this.abruptCompletion_ = null;
  return $exception$$;
};
$jscomp.generator.Context.prototype.enterFinallyBlock = function $$jscomp$generator$Context$$enterFinallyBlock$($nextCatchAddress$$, $nextFinallyAddress$$, $finallyDepth$$) {
  $finallyDepth$$ ? this.finallyContexts_[$finallyDepth$$] = this.abruptCompletion_ : this.finallyContexts_ = [this.abruptCompletion_];
  this.catchAddress_ = $nextCatchAddress$$ || 0;
  this.finallyAddress_ = $nextFinallyAddress$$ || 0;
};
$jscomp.generator.Context.prototype.leaveFinallyBlock = function $$jscomp$generator$Context$$leaveFinallyBlock$($nextAddress$$, $abruptCompletion_finallyDepth$$) {
  $abruptCompletion_finallyDepth$$ = this.finallyContexts_.splice($abruptCompletion_finallyDepth$$ || 0)[0];
  if ($abruptCompletion_finallyDepth$$ = this.abruptCompletion_ = this.abruptCompletion_ || $abruptCompletion_finallyDepth$$) {
    if ($abruptCompletion_finallyDepth$$.isException) {
      return this.jumpToErrorHandler_();
    }
    void 0 != $abruptCompletion_finallyDepth$$.jumpTo && this.finallyAddress_ < $abruptCompletion_finallyDepth$$.jumpTo ? (this.nextAddress = $abruptCompletion_finallyDepth$$.jumpTo, this.abruptCompletion_ = null) : this.nextAddress = this.finallyAddress_;
  } else {
    this.nextAddress = $nextAddress$$;
  }
};
$jscomp.generator.Context.prototype.forIn = function $$jscomp$generator$Context$$forIn$($object$$) {
  return new $jscomp.generator.Context.PropertyIterator($object$$);
};
$jscomp.generator.Context.PropertyIterator = function $$jscomp$generator$Context$PropertyIterator$($object$$) {
  this.object_ = $object$$;
  this.properties_ = [];
  for (var $property$$ in $object$$) {
    this.properties_.push($property$$);
  }
  this.properties_.reverse();
};
$jscomp.generator.Context.PropertyIterator.prototype.getNext = function $$jscomp$generator$Context$PropertyIterator$$getNext$() {
  for (; 0 < this.properties_.length;) {
    var $property$$ = this.properties_.pop();
    if ($property$$ in this.object_) {
      return $property$$;
    }
  }
  return null;
};
$jscomp.generator.Engine_ = function $$jscomp$generator$Engine_$($program$$) {
  this.context_ = new $jscomp.generator.Context;
  this.program_ = $program$$;
};
$jscomp.generator.Engine_.prototype.next_ = function $$jscomp$generator$Engine_$$next_$($value$$) {
  this.context_.start_();
  if (this.context_.yieldAllIterator_) {
    return this.yieldAllStep_(this.context_.yieldAllIterator_.next, $value$$, this.context_.next_);
  }
  this.context_.next_($value$$);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.return_ = function $$jscomp$generator$Engine_$$return_$($value$$) {
  this.context_.start_();
  var $yieldAllIterator$$ = this.context_.yieldAllIterator_;
  if ($yieldAllIterator$$) {
    return this.yieldAllStep_("return" in $yieldAllIterator$$ ? $yieldAllIterator$$["return"] : function($v$$) {
      return {value:$v$$, done:!0};
    }, $value$$, this.context_.return);
  }
  this.context_.return($value$$);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.throw_ = function $$jscomp$generator$Engine_$$throw_$($exception$$) {
  this.context_.start_();
  if (this.context_.yieldAllIterator_) {
    return this.yieldAllStep_(this.context_.yieldAllIterator_["throw"], $exception$$, this.context_.next_);
  }
  this.context_.throw_($exception$$);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.yieldAllStep_ = function $$jscomp$generator$Engine_$$yieldAllStep_$($action$$, $value$$, $nextAction$$) {
  try {
    var $result$$ = $action$$.call(this.context_.yieldAllIterator_, $value$$);
    $jscomp.generator.ensureIteratorResultIsObject_($result$$);
    if (!$result$$.done) {
      return this.context_.stop_(), $result$$;
    }
    var $resultValue$$ = $result$$.value;
  } catch ($e$$) {
    return this.context_.yieldAllIterator_ = null, this.context_.throw_($e$$), this.nextStep_();
  }
  this.context_.yieldAllIterator_ = null;
  $nextAction$$.call(this.context_, $resultValue$$);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.nextStep_ = function $$jscomp$generator$Engine_$$nextStep_$() {
  for (; this.context_.nextAddress;) {
    try {
      var $abruptCompletion$$ = this.program_(this.context_);
      if ($abruptCompletion$$) {
        return this.context_.stop_(), {value:$abruptCompletion$$.value, done:!1};
      }
    } catch ($e$$) {
      this.context_.yieldResult = void 0, this.context_.throw_($e$$);
    }
  }
  this.context_.stop_();
  if (this.context_.abruptCompletion_) {
    $abruptCompletion$$ = this.context_.abruptCompletion_;
    this.context_.abruptCompletion_ = null;
    if ($abruptCompletion$$.isException) {
      throw $abruptCompletion$$.exception;
    }
    return {value:$abruptCompletion$$.return, done:!0};
  }
  return {value:void 0, done:!0};
};
$jscomp.generator.Generator_ = function $$jscomp$generator$Generator_$($engine$$) {
  this.next = function $this$next$($opt_value$$) {
    return $engine$$.next_($opt_value$$);
  };
  this.throw = function $this$throw$($exception$$) {
    return $engine$$.throw_($exception$$);
  };
  this.return = function $this$return$($value$$) {
    return $engine$$.return_($value$$);
  };
  this[Symbol.iterator] = function $this$Symbol$iterator$() {
    return this;
  };
};
$jscomp.generator.createGenerator = function $$jscomp$generator$createGenerator$($generator$$, $program$jscomp$64_result$$) {
  $program$jscomp$64_result$$ = new $jscomp.generator.Generator_(new $jscomp.generator.Engine_($program$jscomp$64_result$$));
  $jscomp.setPrototypeOf && $generator$$.prototype && $jscomp.setPrototypeOf($program$jscomp$64_result$$, $generator$$.prototype);
  return $program$jscomp$64_result$$;
};
$jscomp.asyncExecutePromiseGenerator = function $$jscomp$asyncExecutePromiseGenerator$($generator$$) {
  function $passValueToGenerator$$($value$$) {
    return $generator$$.next($value$$);
  }
  function $passErrorToGenerator$$($error$$) {
    return $generator$$.throw($error$$);
  }
  return new Promise(function($resolve$$, $reject$$) {
    function $handleGeneratorRecord$$($genRec$$) {
      $genRec$$.done ? $resolve$$($genRec$$.value) : Promise.resolve($genRec$$.value).then($passValueToGenerator$$, $passErrorToGenerator$$).then($handleGeneratorRecord$$, $reject$$);
    }
    $handleGeneratorRecord$$($generator$$.next());
  });
};
$jscomp.asyncExecutePromiseGeneratorFunction = function $$jscomp$asyncExecutePromiseGeneratorFunction$($generatorFunction$$) {
  return $jscomp.asyncExecutePromiseGenerator($generatorFunction$$());
};
$jscomp.asyncExecutePromiseGeneratorProgram = function $$jscomp$asyncExecutePromiseGeneratorProgram$($program$$) {
  return $jscomp.asyncExecutePromiseGenerator(new $jscomp.generator.Generator_(new $jscomp.generator.Engine_($program$$)));
};
$jscomp.polyfill("Reflect", function($orig$$) {
  return $orig$$ ? $orig$$ : {};
}, "es6", "es3");
$jscomp.polyfill("Reflect.construct", function($orig$$) {
  return $jscomp.construct;
}, "es6", "es3");
$jscomp.polyfill("Reflect.setPrototypeOf", function($orig$$) {
  if ($orig$$) {
    return $orig$$;
  }
  if ($jscomp.setPrototypeOf) {
    var $setPrototypeOf$$ = $jscomp.setPrototypeOf;
    return function($target$$, $proto$$) {
      try {
        return $setPrototypeOf$$($target$$, $proto$$), !0;
      } catch ($e$$) {
        return !1;
      }
    };
  }
  return null;
}, "es6", "es5");
$jscomp.initSymbol = function $$jscomp$initSymbol$() {
};
$jscomp.polyfill("Symbol", function($orig$$) {
  if ($orig$$) {
    return $orig$$;
  }
  var $SymbolClass$$ = function $$SymbolClass$$$($id$$, $opt_description$$) {
    this.$jscomp$symbol$id_ = $id$$;
    $jscomp.defineProperty(this, "description", {configurable:!0, writable:!0, value:$opt_description$$});
  };
  $SymbolClass$$.prototype.toString = function $$SymbolClass$$$$toString$() {
    return this.$jscomp$symbol$id_;
  };
  var $counter$$ = 0, $symbolPolyfill$$ = function $$symbolPolyfill$$$($opt_description$$) {
    if (this instanceof $symbolPolyfill$$) {
      throw new TypeError("Symbol is not a constructor");
    }
    return new $SymbolClass$$("jscomp_symbol_" + ($opt_description$$ || "") + "_" + $counter$$++, $opt_description$$);
  };
  return $symbolPolyfill$$;
}, "es6", "es3");
$jscomp.initSymbolIterator = function $$jscomp$initSymbolIterator$() {
};
$jscomp.polyfill("Symbol.iterator", function($orig$$) {
  if ($orig$$) {
    return $orig$$;
  }
  $orig$$ = Symbol("Symbol.iterator");
  for (var $arrayLikes$$ = "Array Int8Array Uint8Array Uint8ClampedArray Int16Array Uint16Array Int32Array Uint32Array Float32Array Float64Array".split(" "), $i$$ = 0; $i$$ < $arrayLikes$$.length; $i$$++) {
    var $ArrayLikeCtor$$ = $jscomp.global[$arrayLikes$$[$i$$]];
    "function" === typeof $ArrayLikeCtor$$ && "function" != typeof $ArrayLikeCtor$$.prototype[$orig$$] && $jscomp.defineProperty($ArrayLikeCtor$$.prototype, $orig$$, {configurable:!0, writable:!0, value:function() {
      return $jscomp.iteratorPrototype($jscomp.arrayIteratorImpl(this));
    }});
  }
  return $orig$$;
}, "es6", "es3");
$jscomp.initSymbolAsyncIterator = function $$jscomp$initSymbolAsyncIterator$() {
};
$jscomp.iteratorPrototype = function $$jscomp$iteratorPrototype$($iterator$$) {
  $iterator$$ = {next:$iterator$$};
  $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
    return this;
  };
  return $iterator$$;
};
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.polyfill("Promise", function($NativePromise$$) {
  function $AsyncExecutor$$() {
    this.batch_ = null;
  }
  function $resolvingPromise$$($opt_value$$) {
    return $opt_value$$ instanceof $PolyfillPromise$$ ? $opt_value$$ : new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $resolve$$($opt_value$$);
    });
  }
  if ($NativePromise$$ && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return $NativePromise$$;
  }
  $AsyncExecutor$$.prototype.asyncExecute = function $$AsyncExecutor$$$$asyncExecute$($f$$) {
    if (null == this.batch_) {
      this.batch_ = [];
      var $self$$ = this;
      this.asyncExecuteFunction(function() {
        $self$$.executeBatch_();
      });
    }
    this.batch_.push($f$$);
  };
  var $nativeSetTimeout$$ = $jscomp.global.setTimeout;
  $AsyncExecutor$$.prototype.asyncExecuteFunction = function $$AsyncExecutor$$$$asyncExecuteFunction$($f$$) {
    $nativeSetTimeout$$($f$$, 0);
  };
  $AsyncExecutor$$.prototype.executeBatch_ = function $$AsyncExecutor$$$$executeBatch_$() {
    for (; this.batch_ && this.batch_.length;) {
      var $executingBatch$$ = this.batch_;
      this.batch_ = [];
      for (var $i$$ = 0; $i$$ < $executingBatch$$.length; ++$i$$) {
        var $f$$ = $executingBatch$$[$i$$];
        $executingBatch$$[$i$$] = null;
        try {
          $f$$();
        } catch ($error$$) {
          this.asyncThrow_($error$$);
        }
      }
    }
    this.batch_ = null;
  };
  $AsyncExecutor$$.prototype.asyncThrow_ = function $$AsyncExecutor$$$$asyncThrow_$($exception$$) {
    this.asyncExecuteFunction(function() {
      throw $exception$$;
    });
  };
  var $PolyfillPromise$$ = function $$PolyfillPromise$$$($executor$$) {
    this.state_ = 0;
    this.result_ = void 0;
    this.onSettledCallbacks_ = [];
    var $resolveAndReject$$ = this.createResolveAndReject_();
    try {
      $executor$$($resolveAndReject$$.resolve, $resolveAndReject$$.reject);
    } catch ($e$$) {
      $resolveAndReject$$.reject($e$$);
    }
  };
  $PolyfillPromise$$.prototype.createResolveAndReject_ = function $$PolyfillPromise$$$$createResolveAndReject_$() {
    function $firstCallWins$$($method$$) {
      return function($x$$) {
        $alreadyCalled$$ || ($alreadyCalled$$ = !0, $method$$.call($thisPromise$$, $x$$));
      };
    }
    var $thisPromise$$ = this, $alreadyCalled$$ = !1;
    return {resolve:$firstCallWins$$(this.resolveTo_), reject:$firstCallWins$$(this.reject_)};
  };
  $PolyfillPromise$$.prototype.resolveTo_ = function $$PolyfillPromise$$$$resolveTo_$($value$$) {
    if ($value$$ === this) {
      this.reject_(new TypeError("A Promise cannot resolve to itself"));
    } else {
      if ($value$$ instanceof $PolyfillPromise$$) {
        this.settleSameAsPromise_($value$$);
      } else {
        a: {
          switch(typeof $value$$) {
            case "object":
              var $JSCompiler_inline_result$$ = null != $value$$;
              break a;
            case "function":
              $JSCompiler_inline_result$$ = !0;
              break a;
            default:
              $JSCompiler_inline_result$$ = !1;
          }
        }
        $JSCompiler_inline_result$$ ? this.resolveToNonPromiseObj_($value$$) : this.fulfill_($value$$);
      }
    }
  };
  $PolyfillPromise$$.prototype.resolveToNonPromiseObj_ = function $$PolyfillPromise$$$$resolveToNonPromiseObj_$($obj$$) {
    var $thenMethod$$ = void 0;
    try {
      $thenMethod$$ = $obj$$.then;
    } catch ($error$$) {
      this.reject_($error$$);
      return;
    }
    "function" == typeof $thenMethod$$ ? this.settleSameAsThenable_($thenMethod$$, $obj$$) : this.fulfill_($obj$$);
  };
  $PolyfillPromise$$.prototype.reject_ = function $$PolyfillPromise$$$$reject_$($reason$$) {
    this.settle_(2, $reason$$);
  };
  $PolyfillPromise$$.prototype.fulfill_ = function $$PolyfillPromise$$$$fulfill_$($value$$) {
    this.settle_(1, $value$$);
  };
  $PolyfillPromise$$.prototype.settle_ = function $$PolyfillPromise$$$$settle_$($settledState$$, $valueOrReason$$) {
    if (0 != this.state_) {
      throw Error("Cannot settle(" + $settledState$$ + ", " + $valueOrReason$$ + "): Promise already settled in state" + this.state_);
    }
    this.state_ = $settledState$$;
    this.result_ = $valueOrReason$$;
    this.executeOnSettledCallbacks_();
  };
  $PolyfillPromise$$.prototype.executeOnSettledCallbacks_ = function $$PolyfillPromise$$$$executeOnSettledCallbacks_$() {
    if (null != this.onSettledCallbacks_) {
      for (var $i$$ = 0; $i$$ < this.onSettledCallbacks_.length; ++$i$$) {
        $asyncExecutor$$.asyncExecute(this.onSettledCallbacks_[$i$$]);
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var $asyncExecutor$$ = new $AsyncExecutor$$;
  $PolyfillPromise$$.prototype.settleSameAsPromise_ = function $$PolyfillPromise$$$$settleSameAsPromise_$($promise$$) {
    var $methods$$ = this.createResolveAndReject_();
    $promise$$.callWhenSettled_($methods$$.resolve, $methods$$.reject);
  };
  $PolyfillPromise$$.prototype.settleSameAsThenable_ = function $$PolyfillPromise$$$$settleSameAsThenable_$($thenMethod$$, $thenable$$) {
    var $methods$$ = this.createResolveAndReject_();
    try {
      $thenMethod$$.call($thenable$$, $methods$$.resolve, $methods$$.reject);
    } catch ($error$$) {
      $methods$$.reject($error$$);
    }
  };
  $PolyfillPromise$$.prototype.then = function $$PolyfillPromise$$$$then$($onFulfilled$$, $onRejected$$) {
    function $createCallback$$($paramF$$, $defaultF$$) {
      return "function" == typeof $paramF$$ ? function($x$$) {
        try {
          $resolveChild$$($paramF$$($x$$));
        } catch ($error$$) {
          $rejectChild$$($error$$);
        }
      } : $defaultF$$;
    }
    var $resolveChild$$, $rejectChild$$, $childPromise$$ = new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $resolveChild$$ = $resolve$$;
      $rejectChild$$ = $reject$$;
    });
    this.callWhenSettled_($createCallback$$($onFulfilled$$, $resolveChild$$), $createCallback$$($onRejected$$, $rejectChild$$));
    return $childPromise$$;
  };
  $PolyfillPromise$$.prototype.catch = function $$PolyfillPromise$$$$catch$($onRejected$$) {
    return this.then(void 0, $onRejected$$);
  };
  $PolyfillPromise$$.prototype.callWhenSettled_ = function $$PolyfillPromise$$$$callWhenSettled_$($onFulfilled$$, $onRejected$$) {
    function $callback$$() {
      switch($thisPromise$$.state_) {
        case 1:
          $onFulfilled$$($thisPromise$$.result_);
          break;
        case 2:
          $onRejected$$($thisPromise$$.result_);
          break;
        default:
          throw Error("Unexpected state: " + $thisPromise$$.state_);
      }
    }
    var $thisPromise$$ = this;
    null == this.onSettledCallbacks_ ? $asyncExecutor$$.asyncExecute($callback$$) : this.onSettledCallbacks_.push($callback$$);
  };
  $PolyfillPromise$$.resolve = $resolvingPromise$$;
  $PolyfillPromise$$.reject = function $$PolyfillPromise$$$reject$($opt_reason$$) {
    return new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $reject$$($opt_reason$$);
    });
  };
  $PolyfillPromise$$.race = function $$PolyfillPromise$$$race$($thenablesOrValues$$) {
    return new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      for (var $iterator$$ = $jscomp.makeIterator($thenablesOrValues$$), $iterRec$$ = $iterator$$.next(); !$iterRec$$.done; $iterRec$$ = $iterator$$.next()) {
        $resolvingPromise$$($iterRec$$.value).callWhenSettled_($resolve$$, $reject$$);
      }
    });
  };
  $PolyfillPromise$$.all = function $$PolyfillPromise$$$all$($thenablesOrValues$$) {
    var $iterator$$ = $jscomp.makeIterator($thenablesOrValues$$), $iterRec$$ = $iterator$$.next();
    return $iterRec$$.done ? $resolvingPromise$$([]) : new $PolyfillPromise$$(function($resolveAll$$, $rejectAll$$) {
      function $onFulfilled$$($i$$) {
        return function($ithResult$$) {
          $resultsArray$$[$i$$] = $ithResult$$;
          $unresolvedCount$$--;
          0 == $unresolvedCount$$ && $resolveAll$$($resultsArray$$);
        };
      }
      var $resultsArray$$ = [], $unresolvedCount$$ = 0;
      do {
        $resultsArray$$.push(void 0), $unresolvedCount$$++, $resolvingPromise$$($iterRec$$.value).callWhenSettled_($onFulfilled$$($resultsArray$$.length - 1), $rejectAll$$), $iterRec$$ = $iterator$$.next();
      } while (!$iterRec$$.done);
    });
  };
  return $PolyfillPromise$$;
}, "es6", "es3");
$jscomp.findInternal = function $$jscomp$findInternal$($array$$, $callback$$, $thisArg$$) {
  $array$$ instanceof String && ($array$$ = String($array$$));
  for (var $len$$ = $array$$.length, $i$$ = 0; $i$$ < $len$$; $i$$++) {
    var $value$$ = $array$$[$i$$];
    if ($callback$$.call($thisArg$$, $value$$, $i$$, $array$$)) {
      return {i:$i$$, v:$value$$};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill("Array.prototype.findIndex", function($orig$$) {
  return $orig$$ ? $orig$$ : function($callback$$, $opt_thisArg$$) {
    return $jscomp.findInternal(this, $callback$$, $opt_thisArg$$).i;
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.fill", function($orig$$) {
  return $orig$$ ? $orig$$ : function($value$$, $i$$, $opt_end$$) {
    var $length$$ = this.length || 0;
    0 > $i$$ && ($i$$ = Math.max(0, $length$$ + $i$$));
    if (null == $opt_end$$ || $opt_end$$ > $length$$) {
      $opt_end$$ = $length$$;
    }
    $opt_end$$ = Number($opt_end$$);
    0 > $opt_end$$ && ($opt_end$$ = Math.max(0, $length$$ + $opt_end$$));
    for ($i$$ = Number($i$$ || 0); $i$$ < $opt_end$$; $i$$++) {
      this[$i$$] = $value$$;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.typedArrayFill = function $$jscomp$typedArrayFill$($orig$$) {
  return $orig$$ ? $orig$$ : Array.prototype.fill;
};
$jscomp.polyfill("Int8Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Uint8Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Uint8ClampedArray.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Int16Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Uint16Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Int32Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Uint32Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Float32Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.polyfill("Float64Array.prototype.fill", $jscomp.typedArrayFill, "es6", "es5");
$jscomp.checkEs6ConformanceViaProxy = function $$jscomp$checkEs6ConformanceViaProxy$() {
  try {
    var $proxied$$ = {}, $proxy$$ = Object.create(new $jscomp.global.Proxy($proxied$$, {get:function($target$$, $key$$, $receiver$$) {
      return $target$$ == $proxied$$ && "q" == $key$$ && $receiver$$ == $proxy$$;
    }}));
    return !0 === $proxy$$.q;
  } catch ($err$$) {
    return !1;
  }
};
$jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = !1;
$jscomp.ES6_CONFORMANCE = $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && $jscomp.checkEs6ConformanceViaProxy();
$jscomp.owns = function $$jscomp$owns$($obj$$, $prop$$) {
  return Object.prototype.hasOwnProperty.call($obj$$, $prop$$);
};
$jscomp.polyfill("WeakMap", function($NativeWeakMap$$) {
  function $isConformant$$() {
    if (!$NativeWeakMap$$ || !Object.seal) {
      return !1;
    }
    try {
      var $x$$ = Object.seal({}), $y$$ = Object.seal({}), $map$$ = new $NativeWeakMap$$([[$x$$, 2], [$y$$, 3]]);
      if (2 != $map$$.get($x$$) || 3 != $map$$.get($y$$)) {
        return !1;
      }
      $map$$.delete($x$$);
      $map$$.set($y$$, 4);
      return !$map$$.has($x$$) && 4 == $map$$.get($y$$);
    } catch ($err$$) {
      return !1;
    }
  }
  function $WeakMapMembership$$() {
  }
  function $isValidKey$$($key$$) {
    var $type$$ = typeof $key$$;
    return "object" === $type$$ && null !== $key$$ || "function" === $type$$;
  }
  function $insert$$($target$$) {
    if (!$jscomp.owns($target$$, $prop$$)) {
      var $obj$$ = new $WeakMapMembership$$;
      $jscomp.defineProperty($target$$, $prop$$, {value:$obj$$});
    }
  }
  function $patch$$($name$$) {
    if (!$jscomp.ISOLATE_POLYFILLS) {
      var $prev$$ = Object[$name$$];
      $prev$$ && (Object[$name$$] = function $Object$$name$$$($target$$) {
        if ($target$$ instanceof $WeakMapMembership$$) {
          return $target$$;
        }
        Object.isExtensible($target$$) && $insert$$($target$$);
        return $prev$$($target$$);
      });
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if ($NativeWeakMap$$ && $jscomp.ES6_CONFORMANCE) {
      return $NativeWeakMap$$;
    }
  } else {
    if ($isConformant$$()) {
      return $NativeWeakMap$$;
    }
  }
  var $prop$$ = "$jscomp_hidden_" + Math.random();
  $patch$$("freeze");
  $patch$$("preventExtensions");
  $patch$$("seal");
  var $index$$ = 0, $PolyfillWeakMap$$ = function $$PolyfillWeakMap$$$($iter$jscomp$1_opt_iterable$$) {
    this.id_ = ($index$$ += Math.random() + 1).toString();
    if ($iter$jscomp$1_opt_iterable$$) {
      $iter$jscomp$1_opt_iterable$$ = $jscomp.makeIterator($iter$jscomp$1_opt_iterable$$);
      for (var $entry_item$$; !($entry_item$$ = $iter$jscomp$1_opt_iterable$$.next()).done;) {
        $entry_item$$ = $entry_item$$.value, this.set($entry_item$$[0], $entry_item$$[1]);
      }
    }
  };
  $PolyfillWeakMap$$.prototype.set = function $$PolyfillWeakMap$$$$set$($key$$, $value$$) {
    if (!$isValidKey$$($key$$)) {
      throw Error("Invalid WeakMap key");
    }
    $insert$$($key$$);
    if (!$jscomp.owns($key$$, $prop$$)) {
      throw Error("WeakMap key fail: " + $key$$);
    }
    $key$$[$prop$$][this.id_] = $value$$;
    return this;
  };
  $PolyfillWeakMap$$.prototype.get = function $$PolyfillWeakMap$$$$get$($key$$) {
    return $isValidKey$$($key$$) && $jscomp.owns($key$$, $prop$$) ? $key$$[$prop$$][this.id_] : void 0;
  };
  $PolyfillWeakMap$$.prototype.has = function $$PolyfillWeakMap$$$$has$($key$$) {
    return $isValidKey$$($key$$) && $jscomp.owns($key$$, $prop$$) && $jscomp.owns($key$$[$prop$$], this.id_);
  };
  $PolyfillWeakMap$$.prototype.delete = function $$PolyfillWeakMap$$$$delete$($key$$) {
    return $isValidKey$$($key$$) && $jscomp.owns($key$$, $prop$$) && $jscomp.owns($key$$[$prop$$], this.id_) ? delete $key$$[$prop$$][this.id_] : !1;
  };
  return $PolyfillWeakMap$$;
}, "es6", "es3");
$jscomp.MapEntry = function $$jscomp$MapEntry$() {
};
$jscomp.polyfill("Map", function($NativeMap$$) {
  function $isConformant$$() {
    if ($jscomp.ASSUME_NO_NATIVE_MAP || !$NativeMap$$ || "function" != typeof $NativeMap$$ || !$NativeMap$$.prototype.entries || "function" != typeof Object.seal) {
      return !1;
    }
    try {
      var $key$$ = Object.seal({x:4}), $map$$ = new $NativeMap$$($jscomp.makeIterator([[$key$$, "s"]]));
      if ("s" != $map$$.get($key$$) || 1 != $map$$.size || $map$$.get({x:4}) || $map$$.set({x:4}, "t") != $map$$ || 2 != $map$$.size) {
        return !1;
      }
      var $iter$$ = $map$$.entries(), $item$$ = $iter$$.next();
      if ($item$$.done || $item$$.value[0] != $key$$ || "s" != $item$$.value[1]) {
        return !1;
      }
      $item$$ = $iter$$.next();
      return $item$$.done || 4 != $item$$.value[0].x || "t" != $item$$.value[1] || !$iter$$.next().done ? !1 : !0;
    } catch ($err$$) {
      return !1;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if ($NativeMap$$ && $jscomp.ES6_CONFORMANCE) {
      return $NativeMap$$;
    }
  } else {
    if ($isConformant$$()) {
      return $NativeMap$$;
    }
  }
  var $idMap$$ = new WeakMap, $PolyfillMap$$ = function $$PolyfillMap$$$($iter$jscomp$3_opt_iterable$$) {
    this.data_ = {};
    this.head_ = $createHead$$();
    this.size = 0;
    if ($iter$jscomp$3_opt_iterable$$) {
      $iter$jscomp$3_opt_iterable$$ = $jscomp.makeIterator($iter$jscomp$3_opt_iterable$$);
      for (var $entry$jscomp$1_item$$; !($entry$jscomp$1_item$$ = $iter$jscomp$3_opt_iterable$$.next()).done;) {
        $entry$jscomp$1_item$$ = $entry$jscomp$1_item$$.value, this.set($entry$jscomp$1_item$$[0], $entry$jscomp$1_item$$[1]);
      }
    }
  };
  $PolyfillMap$$.prototype.set = function $$PolyfillMap$$$$set$($key$$, $value$$) {
    $key$$ = 0 === $key$$ ? 0 : $key$$;
    var $r$$ = $maybeGetEntry$$(this, $key$$);
    $r$$.list || ($r$$.list = this.data_[$r$$.id] = []);
    $r$$.entry ? $r$$.entry.value = $value$$ : ($r$$.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:$key$$, value:$value$$, }, $r$$.list.push($r$$.entry), this.head_.previous.next = $r$$.entry, this.head_.previous = $r$$.entry, this.size++);
    return this;
  };
  $PolyfillMap$$.prototype.delete = function $$PolyfillMap$$$$delete$($key$jscomp$48_r$$) {
    $key$jscomp$48_r$$ = $maybeGetEntry$$(this, $key$jscomp$48_r$$);
    return $key$jscomp$48_r$$.entry && $key$jscomp$48_r$$.list ? ($key$jscomp$48_r$$.list.splice($key$jscomp$48_r$$.index, 1), $key$jscomp$48_r$$.list.length || delete this.data_[$key$jscomp$48_r$$.id], $key$jscomp$48_r$$.entry.previous.next = $key$jscomp$48_r$$.entry.next, $key$jscomp$48_r$$.entry.next.previous = $key$jscomp$48_r$$.entry.previous, $key$jscomp$48_r$$.entry.head = null, this.size--, !0) : !1;
  };
  $PolyfillMap$$.prototype.clear = function $$PolyfillMap$$$$clear$() {
    this.data_ = {};
    this.head_ = this.head_.previous = $createHead$$();
    this.size = 0;
  };
  $PolyfillMap$$.prototype.has = function $$PolyfillMap$$$$has$($key$$) {
    return !!$maybeGetEntry$$(this, $key$$).entry;
  };
  $PolyfillMap$$.prototype.get = function $$PolyfillMap$$$$get$($entry$jscomp$2_key$$) {
    return ($entry$jscomp$2_key$$ = $maybeGetEntry$$(this, $entry$jscomp$2_key$$).entry) && $entry$jscomp$2_key$$.value;
  };
  $PolyfillMap$$.prototype.entries = function $$PolyfillMap$$$$entries$() {
    return $makeIterator$$(this, function($entry$$) {
      return [$entry$$.key, $entry$$.value];
    });
  };
  $PolyfillMap$$.prototype.keys = function $$PolyfillMap$$$$keys$() {
    return $makeIterator$$(this, function($entry$$) {
      return $entry$$.key;
    });
  };
  $PolyfillMap$$.prototype.values = function $$PolyfillMap$$$$values$() {
    return $makeIterator$$(this, function($entry$$) {
      return $entry$$.value;
    });
  };
  $PolyfillMap$$.prototype.forEach = function $$PolyfillMap$$$$forEach$($callback$$, $opt_thisArg$$) {
    for (var $iter$$ = this.entries(), $entry$jscomp$6_item$$; !($entry$jscomp$6_item$$ = $iter$$.next()).done;) {
      $entry$jscomp$6_item$$ = $entry$jscomp$6_item$$.value, $callback$$.call($opt_thisArg$$, $entry$jscomp$6_item$$[1], $entry$jscomp$6_item$$[0], this);
    }
  };
  $PolyfillMap$$.prototype[Symbol.iterator] = $PolyfillMap$$.prototype.entries;
  var $maybeGetEntry$$ = function $$maybeGetEntry$$$($index$jscomp$75_map$$, $key$$) {
    var $id$jscomp$6_id$jscomp$inline_66_type$$ = $key$$ && typeof $key$$;
    "object" == $id$jscomp$6_id$jscomp$inline_66_type$$ || "function" == $id$jscomp$6_id$jscomp$inline_66_type$$ ? $idMap$$.has($key$$) ? $id$jscomp$6_id$jscomp$inline_66_type$$ = $idMap$$.get($key$$) : ($id$jscomp$6_id$jscomp$inline_66_type$$ = "" + ++$mapIndex$$, $idMap$$.set($key$$, $id$jscomp$6_id$jscomp$inline_66_type$$)) : $id$jscomp$6_id$jscomp$inline_66_type$$ = "p_" + $key$$;
    var $list$$ = $index$jscomp$75_map$$.data_[$id$jscomp$6_id$jscomp$inline_66_type$$];
    if ($list$$ && $jscomp.owns($index$jscomp$75_map$$.data_, $id$jscomp$6_id$jscomp$inline_66_type$$)) {
      for ($index$jscomp$75_map$$ = 0; $index$jscomp$75_map$$ < $list$$.length; $index$jscomp$75_map$$++) {
        var $entry$$ = $list$$[$index$jscomp$75_map$$];
        if ($key$$ !== $key$$ && $entry$$.key !== $entry$$.key || $key$$ === $entry$$.key) {
          return {id:$id$jscomp$6_id$jscomp$inline_66_type$$, list:$list$$, index:$index$jscomp$75_map$$, entry:$entry$$};
        }
      }
    }
    return {id:$id$jscomp$6_id$jscomp$inline_66_type$$, list:$list$$, index:-1, entry:void 0};
  }, $makeIterator$$ = function $$makeIterator$$$($map$$, $func$$) {
    var $entry$$ = $map$$.head_;
    return $jscomp.iteratorPrototype(function() {
      if ($entry$$) {
        for (; $entry$$.head != $map$$.head_;) {
          $entry$$ = $entry$$.previous;
        }
        for (; $entry$$.next != $entry$$.head;) {
          return $entry$$ = $entry$$.next, {done:!1, value:$func$$($entry$$)};
        }
        $entry$$ = null;
      }
      return {done:!0, value:void 0};
    });
  }, $createHead$$ = function $$createHead$$$() {
    var $head$$ = {};
    return $head$$.previous = $head$$.next = $head$$.head = $head$$;
  }, $mapIndex$$ = 0;
  return $PolyfillMap$$;
}, "es6", "es3");
$jscomp.polyfill("Set", function($NativeSet$$) {
  function $isConformant$$() {
    if ($jscomp.ASSUME_NO_NATIVE_SET || !$NativeSet$$ || "function" != typeof $NativeSet$$ || !$NativeSet$$.prototype.entries || "function" != typeof Object.seal) {
      return !1;
    }
    try {
      var $value$$ = Object.seal({x:4}), $set$$ = new $NativeSet$$($jscomp.makeIterator([$value$$]));
      if (!$set$$.has($value$$) || 1 != $set$$.size || $set$$.add($value$$) != $set$$ || 1 != $set$$.size || $set$$.add({x:4}) != $set$$ || 2 != $set$$.size) {
        return !1;
      }
      var $iter$$ = $set$$.entries(), $item$$ = $iter$$.next();
      if ($item$$.done || $item$$.value[0] != $value$$ || $item$$.value[1] != $value$$) {
        return !1;
      }
      $item$$ = $iter$$.next();
      return $item$$.done || $item$$.value[0] == $value$$ || 4 != $item$$.value[0].x || $item$$.value[1] != $item$$.value[0] ? !1 : $iter$$.next().done;
    } catch ($err$$) {
      return !1;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if ($NativeSet$$ && $jscomp.ES6_CONFORMANCE) {
      return $NativeSet$$;
    }
  } else {
    if ($isConformant$$()) {
      return $NativeSet$$;
    }
  }
  var $PolyfillSet$$ = function $$PolyfillSet$$$($iter$jscomp$6_opt_iterable$$) {
    this.map_ = new Map;
    if ($iter$jscomp$6_opt_iterable$$) {
      $iter$jscomp$6_opt_iterable$$ = $jscomp.makeIterator($iter$jscomp$6_opt_iterable$$);
      for (var $entry$$; !($entry$$ = $iter$jscomp$6_opt_iterable$$.next()).done;) {
        this.add($entry$$.value);
      }
    }
    this.size = this.map_.size;
  };
  $PolyfillSet$$.prototype.add = function $$PolyfillSet$$$$add$($value$$) {
    $value$$ = 0 === $value$$ ? 0 : $value$$;
    this.map_.set($value$$, $value$$);
    this.size = this.map_.size;
    return this;
  };
  $PolyfillSet$$.prototype.delete = function $$PolyfillSet$$$$delete$($result$jscomp$5_value$$) {
    $result$jscomp$5_value$$ = this.map_.delete($result$jscomp$5_value$$);
    this.size = this.map_.size;
    return $result$jscomp$5_value$$;
  };
  $PolyfillSet$$.prototype.clear = function $$PolyfillSet$$$$clear$() {
    this.map_.clear();
    this.size = 0;
  };
  $PolyfillSet$$.prototype.has = function $$PolyfillSet$$$$has$($value$$) {
    return this.map_.has($value$$);
  };
  $PolyfillSet$$.prototype.entries = function $$PolyfillSet$$$$entries$() {
    return this.map_.entries();
  };
  $PolyfillSet$$.prototype.values = function $$PolyfillSet$$$$values$() {
    return this.map_.values();
  };
  $PolyfillSet$$.prototype.keys = $PolyfillSet$$.prototype.values;
  $PolyfillSet$$.prototype[Symbol.iterator] = $PolyfillSet$$.prototype.values;
  $PolyfillSet$$.prototype.forEach = function $$PolyfillSet$$$$forEach$($callback$$, $opt_thisArg$$) {
    var $set$$ = this;
    this.map_.forEach(function($value$$) {
      return $callback$$.call($opt_thisArg$$, $value$$, $value$$, $set$$);
    });
  };
  return $PolyfillSet$$;
}, "es6", "es3");
$jscomp.polyfill("Object.entries", function($orig$$) {
  return $orig$$ ? $orig$$ : function($obj$$) {
    var $result$$ = [], $key$$;
    for ($key$$ in $obj$$) {
      $jscomp.owns($obj$$, $key$$) && $result$$.push([$key$$, $obj$$[$key$$]]);
    }
    return $result$$;
  };
}, "es8", "es3");
$jscomp.polyfill("Object.values", function($orig$$) {
  return $orig$$ ? $orig$$ : function($obj$$) {
    var $result$$ = [], $key$$;
    for ($key$$ in $obj$$) {
      $jscomp.owns($obj$$, $key$$) && $result$$.push($obj$$[$key$$]);
    }
    return $result$$;
  };
}, "es8", "es3");
var hamonengine = {debug:!0, verbose:!0};
var bitflag = function $bitflag$() {
};
bitflag.toggle = function $bitflag$toggle$($value$$, $bitToToggle$$, $state$$) {
  return void 0 !== $state$$ ? $state$$ ? $value$$ | 1 << $bitToToggle$$ : $value$$ & ~(1 << $bitToToggle$$) : $value$$ ^ 1 << $bitToToggle$$;
};
bitflag.isSet = function $bitflag$isSet$($value$$, $bitToCheck_valueToCheck$$) {
  $bitToCheck_valueToCheck$$ = 1 << $bitToCheck_valueToCheck$$;
  return ($value$$ & $bitToCheck_valueToCheck$$) === $bitToCheck_valueToCheck$$;
};
var connect = function $connect$($options$$) {
  $options$$ = void 0 === $options$$ ? {} : $options$$;
  this._timeout = $options$$.timeout;
};
connect.get = function $connect$get$($url$$, $$jscomp$destructuring$var0_timeout$$) {
  var $$jscomp$destructuring$var1_responseType$$ = void 0 === $$jscomp$destructuring$var0_timeout$$ ? {} : $$jscomp$destructuring$var0_timeout$$;
  $$jscomp$destructuring$var0_timeout$$ = $$jscomp$destructuring$var1_responseType$$.timeout;
  $$jscomp$destructuring$var1_responseType$$ = $$jscomp$destructuring$var1_responseType$$.responseType;
  if (!$url$$) {
    throw "Invalid url '" + $url$$ + "'";
  }
  var $xhr$$ = new XMLHttpRequest;
  if (!$xhr$$) {
    throw "Unable to create XMLHttpRequest";
  }
  void 0 !== $$jscomp$destructuring$var0_timeout$$ && ($xhr$$.timeout = $$jscomp$destructuring$var0_timeout$$);
  void 0 !== $$jscomp$destructuring$var1_responseType$$ && ($xhr$$.responseType = $$jscomp$destructuring$var1_responseType$$);
  return new Promise(function($resolve$$, $reject$$) {
    $xhr$$.addEventListener("load", function($e$$) {
      var $status$$ = $xhr$$.status;
      0 === $status$$ || 200 <= $status$$ && 400 > $status$$ ? $resolve$$({data:$xhr$$.response, status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$}) : $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.addEventListener("error", function($e$$) {
      return $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.open("GET", $url$$);
    $xhr$$.send();
  });
};
connect.post = function $connect$post$($url$$, $data$$, $$jscomp$destructuring$var2_timeout$$) {
  var $$jscomp$destructuring$var3_responseType$$ = void 0 === $$jscomp$destructuring$var2_timeout$$ ? {} : $$jscomp$destructuring$var2_timeout$$;
  $$jscomp$destructuring$var2_timeout$$ = $$jscomp$destructuring$var3_responseType$$.timeout;
  var $contentType$$ = $$jscomp$destructuring$var3_responseType$$.contentType, $accept$$ = $$jscomp$destructuring$var3_responseType$$.accept;
  $$jscomp$destructuring$var3_responseType$$ = $$jscomp$destructuring$var3_responseType$$.responseType;
  if (!$url$$) {
    throw "Invalid url '" + $url$$ + "'";
  }
  var $xhr$$ = new XMLHttpRequest;
  if (!$xhr$$) {
    throw "Unable to create XMLHttpRequest";
  }
  void 0 !== $$jscomp$destructuring$var2_timeout$$ && ($xhr$$.timeout = $$jscomp$destructuring$var2_timeout$$);
  $$jscomp$destructuring$var3_responseType$$ || ($xhr$$.responseType = $$jscomp$destructuring$var3_responseType$$);
  return new Promise(function($resolve$$, $reject$$) {
    $xhr$$.addEventListener("load", function($e$$) {
      var $status$$ = $xhr$$.status;
      0 === $status$$ || 200 <= $status$$ && 400 > $status$$ ? $resolve$$({data:$xhr$$.response, status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$}) : $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.addEventListener("error", function($e$$) {
      return $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.open("POST", $url$$);
    void 0 !== $contentType$$ ? $xhr$$.setRequestHeader("Content-Type", $contentType$$) : $xhr$$.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    void 0 !== $accept$$ ? $xhr$$.setRequestHeader("Accept", $accept$$) : $xhr$$.setRequestHeader("Accept", "application/x-www-form-urlencoded");
    $xhr$$.send($data$$);
  });
};
$jscomp.global.Object.defineProperties(connect.prototype, {timeout:{configurable:!0, enumerable:!0, get:function() {
  return this._timeout;
}}});
var MILLISECONDS = 1000, fpscounter = function $fpscounter$($options$$) {
  this._spf = this._fps = this._frameCounter = this._globalStartTime = 0;
  this._minFPS = MILLISECONDS;
  this._maxFPS = 0;
};
fpscounter.prototype.start = function $fpscounter$$start$() {
  this._globalStartTime = Date.now();
  this._spf = this._fps = this._frameCounter = 0;
  this._minFPS = MILLISECONDS;
  this._maxFPS = 0;
};
fpscounter.prototype.begin = function $fpscounter$$begin$() {
  this._frameStartTime = Date.now();
};
fpscounter.prototype.end = function $fpscounter$$end$() {
  if (0 === this._startTime) {
    throw "[fpscounter.end] Begin was not called before end.";
  }
  var $frameEndTime$$ = Date.now();
  this._frameCounter++;
  this._spf = ($frameEndTime$$ - this._frameStartTime) * MILLISECONDS;
  $frameEndTime$$ > this._globalStartTime + MILLISECONDS && (this._fps = Math.round(MILLISECONDS * this._frameCounter / ($frameEndTime$$ - this._globalStartTime)), this._minFPS = Math.min(this._minFPS, this._fps), this._maxFPS = Math.max(this._maxFPS, this._fps), this._globalStartTime = $frameEndTime$$, this._frameCounter = 0);
};
$jscomp.global.Object.defineProperties(fpscounter.prototype, {SPF:{configurable:!0, enumerable:!0, get:function() {
  return this._spf;
}}, FPS:{configurable:!0, enumerable:!0, get:function() {
  return this._fps;
}}, minFPS:{configurable:!0, enumerable:!0, get:function() {
  return this._minFPS;
}}, maxFPS:{configurable:!0, enumerable:!0, get:function() {
  return this._maxFPS;
}}});
var listenerPool = function $listenerPool$($options$$) {
  this._listeners = [];
};
listenerPool.prototype.register = function $listenerPool$$register$($listener$$) {
  this._listeners.push($listener$$);
};
listenerPool.prototype.invoke = function $listenerPool$$invoke$($event$$, $args$$) {
  this._listeners.forEach(function($listener$$) {
    return $listener$$[$event$$] && $listener$$[$event$$]($args$$);
  });
};
$jscomp.global.Object.defineProperties(listenerPool.prototype, {listeners:{configurable:!0, enumerable:!0, get:function() {
  return this._listeners;
}}});
hamonengine.util = hamonengine.util || {};
(function() {
  hamonengine.util.sort = function $hamonengine$util$sort$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._compareFunc = $options$$.compareFunc ? $options$$.compareFunc : hamonengine.util.sort.sort.ascending;
  };
  hamonengine.util.sort.prototype.quickSort = function $hamonengine$util$sort$$quickSort$($arr$$) {
    hamonengine.util.sort.iquicksort(this._compareFunc, $arr$$, 0, $arr$$.length - 1);
  };
  hamonengine.util.sort.ascending = function $hamonengine$util$sort$ascending$($a$$, $b$$) {
    return $a$$ === $b$$ ? 0 : $a$$ < $b$$ ? -1 : 1;
  };
  hamonengine.util.sort.descending = function $hamonengine$util$sort$descending$($a$$, $b$$) {
    return $a$$ === $b$$ ? 0 : $a$$ < $b$$ ? 1 : -1;
  };
  hamonengine.util.sort.iquicksort = function $hamonengine$util$sort$iquicksort$($compareFunction$$, $arr$$, $left$$, $right$$) {
    for (var $i$$ = $left$$, $j$$ = $right$$, $pivot$$ = $arr$$[Math.truncate(($left$$ + $right$$) / 2)]; $i$$ <= $j$$;) {
      for (; 0 > $compareFunction$$($arr$$[$i$$], $pivot$$);) {
        $i$$++;
      }
      for (; 0 < $compareFunction$$($arr$$[$j$$], $pivot$$);) {
        $j$$--;
      }
      if ($i$$ <= $j$$) {
        var $tmp$$ = $arr$$[$i$$];
        $arr$$[$i$$] = $arr$$[$j$$];
        $arr$$[$j$$] = $tmp$$;
        $i$$++;
        $j$$--;
      }
    }
    $left$$ < $j$$ && hamonengine.util.sort.iquicksort($compareFunction$$, $arr$$, $left$$, $j$$);
    $i$$ < $right$$ && hamonengine.util.sort.iquicksort($compareFunction$$, $arr$$, $i$$, $right$$);
  };
})();
var worker = function $worker$($options$$) {
  $options$$ = void 0 === $options$$ ? {} : $options$$;
  $options$$ instanceof worker && ($options$$ = {blob:$options$$.blob, method:$options$$.method});
  if (!$options$$.method) {
    throw console.error("[worker.constructor] Unable to create a workert: options.method is undefined!"), "Cannot create the worker";
  }
  this._method = $options$$.method;
  this._blob = $options$$.blob || new Blob(["onmessage = " + $options$$.method.toString() + ";"], {type:"text/javascript"});
  this._url = URL.createObjectURL(this._blob);
  this._worker = new Worker(this._url);
};
worker.create = function $worker$create$($method$$) {
  return new worker({method:$method$$});
};
worker.prototype.run = function $worker$$run$($data$$) {
  var $$jscomp$async$this$$ = this;
  return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
    return $$jscomp$generator$context$$.return(new Promise(function($resolve$$, $reject$$) {
      $$jscomp$async$this$$.worker.onmessage = function $$$jscomp$async$this$$$worker$onmessage$($e$$) {
        $resolve$$($e$$.data);
        URL.revokeObjectURL($$jscomp$async$this$$.url);
      };
      $$jscomp$async$this$$.worker.onerror = function $$$jscomp$async$this$$$worker$onerror$($e$$) {
        $reject$$($e$$);
        URL.revokeObjectURL($$jscomp$async$this$$.url);
      };
      $$jscomp$async$this$$.worker.postMessage($data$$);
    }));
  });
};
$jscomp.global.Object.defineProperties(worker.prototype, {blob:{configurable:!0, enumerable:!0, get:function() {
  return this._blob;
}}, method:{configurable:!0, enumerable:!0, get:function() {
  return this._method;
}}, url:{configurable:!0, enumerable:!0, get:function() {
  return this._url;
}}, worker:{configurable:!0, enumerable:!0, get:function() {
  return this._worker;
}}});
hamonengine.math = hamonengine.math || {};
(function() {
  var $m$$ = Math.maxUInt32;
  hamonengine.math.LCGRandom = function $hamonengine$math$LCGRandom$($seed$$) {
    this._seed = $seed$$;
  };
  hamonengine.math.LCGRandom.prototype.random = function $hamonengine$math$LCGRandom$$random$() {
    return this._seed = (214013 * this._seed + 2531011) % $m$$;
  };
})();
var ROTATION_TYPE = {CW:0, CCW:1};
hamonengine.math = hamonengine.math || {};
(function() {
  Math.PI2 = 6.283185307179586476925286766559;
  Math.PI3_2 = 3 * Math.PI / 2;
  Math.PI_2 = Math.PI / 2;
  Math.HalfPI = 1.5707963267948966192313216916398;
  Math.QuarterPI = 4.7123889803846898576939650749193;
  Math.maxInt32 = 2147483647;
  Math.maxUInt32 = 4294967296;
  Math.bitRound = function $Math$bitRound$($x$$) {
    return 0.5 + $x$$ << 0;
  };
  Math.truncate = function $Math$truncate$($x$$) {
    return $x$$ >= Math.maxInt32 ? Math.maxInt32 : ~~$x$$;
  };
  Math.sqr = function $Math$sqr$($x$$) {
    return $x$$ * $x$$;
  };
  Math.toDegrees = function $Math$toDegrees$($degrees$$) {
    return $degrees$$ * Math.PI / 180;
  };
  Math.toRadians = function $Math$toRadians$($radians$$) {
    return 180 * $radians$$ / Math.PI;
  };
})();
hamonengine.math = hamonengine.math || {};
(function() {
  hamonengine.math.vector2 = function $hamonengine$math$vector2$($x$$, $y$$) {
    this.x = void 0 === $x$$ ? 0.0 : $x$$;
    this.y = void 0 === $y$$ ? 0.0 : $y$$;
  };
  hamonengine.math.vector2.clone = function $hamonengine$math$vector2$clone$($vector$$) {
    return new hamonengine.math.vector2($vector$$.x, $vector$$.y);
  };
  hamonengine.math.vector2.prototype.clone = function $hamonengine$math$vector2$$clone$() {
    return hamonengine.math.vector2.clone(this);
  };
  hamonengine.math.vector2.prototype.toString = function $hamonengine$math$vector2$$toString$() {
    return "{x: '" + this.x + "', y: '" + this.y + "'}";
  };
  hamonengine.math.vector2.prototype.normalize = function $hamonengine$math$vector2$$normalize$() {
    var $l$$ = this.length;
    return 0 < $l$$ ? new hamonengine.math.vector2(this.x / $l$$, this.y / $l$$) : new hamonengine.math.vector2;
  };
  hamonengine.math.vector2.prototype.normal = function $hamonengine$math$vector2$$normal$($rotationType$$) {
    $rotationType$$ = void 0 === $rotationType$$ ? ROTATION_TYPE.CCW : $rotationType$$;
    var $l$$ = this.length;
    return 0 < $l$$ ? $rotationType$$ === ROTATION_TYPE.CCW ? new hamonengine.math.vector2(-this.y / $l$$, this.x / $l$$) : new hamonengine.math.vector2(this.y / $l$$, -this.x / $l$$) : new hamonengine.math.vector2;
  };
  hamonengine.math.vector2.prototype.mirror = function $hamonengine$math$vector2$$mirror$() {
    return new hamonengine.math.vector2(-this.x, this.y);
  };
  hamonengine.math.vector2.prototype.flip = function $hamonengine$math$vector2$$flip$() {
    return new hamonengine.math.vector2(this.x, -this.y);
  };
  hamonengine.math.vector2.prototype.invert = function $hamonengine$math$vector2$$invert$() {
    return new hamonengine.math.vector2(-this.x, -this.y);
  };
  hamonengine.math.vector2.prototype.add = function $hamonengine$math$vector2$$add$($v$$) {
    return new hamonengine.math.vector2(this.x + $v$$.x, this.y + $v$$.y);
  };
  hamonengine.math.vector2.prototype.subtract = function $hamonengine$math$vector2$$subtract$($v$$) {
    return new hamonengine.math.vector2(this.x - $v$$.x, this.y - $v$$.y);
  };
  hamonengine.math.vector2.prototype.multiply = function $hamonengine$math$vector2$$multiply$($vos$$) {
    return $vos$$ instanceof hamonengine.math.vector2 ? this.multiplyVector($vos$$) : this.multiplyScalar($vos$$);
  };
  hamonengine.math.vector2.prototype.multiplyScalar = function $hamonengine$math$vector2$$multiplyScalar$($s$$) {
    return new hamonengine.math.vector2(this.x * $s$$, this.y * $s$$);
  };
  hamonengine.math.vector2.prototype.multiplyVector = function $hamonengine$math$vector2$$multiplyVector$($v$$) {
    return new hamonengine.math.vector2(this.x * $v$$.x, this.y * $v$$.y);
  };
  hamonengine.math.vector2.prototype.dot = function $hamonengine$math$vector2$$dot$($v$$) {
    return this.x * $v$$.x + this.y * $v$$.y;
  };
  hamonengine.math.vector2.prototype.cross = function $hamonengine$math$vector2$$cross$($v$$) {
    return new hamonengine.math.vector3(0, 0, this.x * $v$$.y - this.y * $v$$.x);
  };
  hamonengine.math.vector2.prototype.equals = function $hamonengine$math$vector2$$equals$($v$$) {
    return this.x === $v$$.x && this.y === $v$$.y;
  };
  $jscomp.global.Object.defineProperties(hamonengine.math.vector2.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return (Math.atan2(this.y, this.x) + Math.PI2) % Math.PI2;
  }}, midPoint:{configurable:!0, enumerable:!0, get:function() {
    return new hamonengine.math.vector2(this.x / 2, this.y / 2);
  }}, min:{configurable:!0, enumerable:!0, get:function() {
    return this.x < this.y ? this.x : this.y;
  }}, max:{configurable:!0, enumerable:!0, get:function() {
    return this.x > this.y ? this.x : this.y;
  }}});
  hamonengine.math.vector2.X_AXIS_NORMAL = new hamonengine.math.vector2(1, 0);
  hamonengine.math.vector2.Y_AXIS_NORMAL = new hamonengine.math.vector2(0, 1);
})();
hamonengine.math = hamonengine.math || {};
(function() {
  hamonengine.math.vector3 = function $hamonengine$math$vector3$($x$$, $y$$, $z$$) {
    this.x = void 0 === $x$$ ? 0.0 : $x$$;
    this.y = void 0 === $y$$ ? 0.0 : $y$$;
    this.z = void 0 === $z$$ ? 0.0 : $z$$;
  };
  hamonengine.math.vector3.clone = function $hamonengine$math$vector3$clone$($vector$$) {
    return new hamonengine.math.vector3($vector$$.x, $vector$$.y, $vector$$.z);
  };
  hamonengine.math.vector3.prototype.clone = function $hamonengine$math$vector3$$clone$() {
    return hamonengine.math.vector3.clone(this);
  };
  hamonengine.math.vector3.prototype.toString = function $hamonengine$math$vector3$$toString$() {
    return "{x: '" + this.x + "', y: '" + this.y + "', z: '" + this.z + "'}";
  };
  hamonengine.math.vector3.prototype.normalize = function $hamonengine$math$vector3$$normalize$() {
    var $l$$ = this.length;
    return 0 < $l$$ ? new hamonengine.math.vector3(this.x / $l$$, this.y / $l$$, this.z / $l$$) : new hamonengine.math.vector3;
  };
  hamonengine.math.vector3.prototype.invert = function $hamonengine$math$vector3$$invert$() {
    return new hamonengine.math.vector2(-this.x, -this.y, -this.z);
  };
  hamonengine.math.vector3.prototype.add = function $hamonengine$math$vector3$$add$($v$$) {
    return new hamonengine.math.vector3(this.x + $v$$.x, this.y + $v$$.y, this.z + $v$$.z);
  };
  hamonengine.math.vector3.prototype.subtract = function $hamonengine$math$vector3$$subtract$($v$$) {
    return new hamonengine.math.vector3(this.x - $v$$.x, this.y - $v$$.y, this.z - $v$$.z);
  };
  hamonengine.math.vector3.prototype.multiplyScalar = function $hamonengine$math$vector3$$multiplyScalar$($s$$) {
    return new hamonengine.math.vector3(this.x * $s$$, this.y * $s$$, this.z * $s$$);
  };
  hamonengine.math.vector3.prototype.multiplyVector = function $hamonengine$math$vector3$$multiplyVector$($v$$) {
    return new hamonengine.math.vector3(this.x * $v$$.x, this.y * $v$$.y, this.z * $v$$.z);
  };
  hamonengine.math.vector3.prototype.dot = function $hamonengine$math$vector3$$dot$($v$$) {
    return this.x * $v$$.x + this.y * $v$$.y + this.z * $v$$.z;
  };
  hamonengine.math.vector3.prototype.cross = function $hamonengine$math$vector3$$cross$($v$$) {
    return new hamonengine.math.vector3(this.y * $v$$.z - this.z * $v$$.y, $v$$.x * this.z - this.x * $v$$.z, this.x * $v$$.y - this.y * $v$$.x);
  };
  hamonengine.math.vector3.prototype.equals = function $hamonengine$math$vector3$$equals$($v$$) {
    return this.x === $v$$.x && this.y === $v$$.y && this.z === $v$$.z;
  };
  $jscomp.global.Object.defineProperties(hamonengine.math.vector3.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }}, midPoint:{configurable:!0, enumerable:!0, get:function() {
    return new hamonengine.math.vector3(this.x / 2, this.y / 2, this.z / 2);
  }}, min:{configurable:!0, enumerable:!0, get:function() {
    var $min$$ = this.x < this.y ? this.x : this.y;
    return $min$$ < this.z ? $min$$ : this.z;
  }}, max:{configurable:!0, enumerable:!0, get:function() {
    var $max$$ = this.x > this.y ? this.x : this.y;
    return $max$$ > this.z ? $max$$ : this.z;
  }}});
  hamonengine.math.vector3.X_AXIS_NORMAL = new hamonengine.math.vector3(1, 0, 0);
  hamonengine.math.vector3.Y_AXIS_NORMAL = new hamonengine.math.vector3(0, 1, 0);
  hamonengine.math.vector3.Z_AXIS_NORMAL = new hamonengine.math.vector3(0, 0, 1);
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.album = function $hamonengine$audio$album$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.audio.album && ($options$$ = {audioResource:$options$$._audioResource, tracks:$options$$._tracks, trackIndex:$options$$._trackIndex, url:$options$$._url, name:$options$$._name});
    this._audioResource = $options$$.audioResource || new hamonengine.audio.audioext;
    this._tracks = $options$$.tracks || {};
    this._trackIndex = $options$$.trackIndex || [];
    this._url = $options$$.url || "";
    this._name = $options$$.name || "";
    hamonengine.debug && (console.debug("[hamonengine.audio.album.constructor] Name: '" + this._name + "'"), console.debug("[hamonengine.audio.album.constructor] Url: '" + this._url + "'"));
  };
  hamonengine.audio.album.prototype.clone = function $hamonengine$audio$album$$clone$() {
    return new hamonengine.audio.album(this);
  };
  hamonengine.audio.album.prototype.load = function $hamonengine$audio$album$$load$($albumMetadata$$) {
    var $$jscomp$async$this$$ = this, $albumMetadataResponse$$, $i$$, $trackData$$;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      switch($$jscomp$generator$context$$.nextAddress) {
        case 1:
          $albumMetadata$$ = $albumMetadata$$ || $$jscomp$async$this$$._url;
          if ("string" !== typeof $albumMetadata$$) {
            $$jscomp$generator$context$$.jumpTo(2);
            break;
          }
          return $$jscomp$generator$context$$.yield(connect.get($albumMetadata$$), 3);
        case 3:
          $albumMetadataResponse$$ = $$jscomp$generator$context$$.yieldResult, $albumMetadata$$ = JSON.parse($albumMetadataResponse$$.data);
        case 2:
          return $$jscomp$async$this$$._name = $$jscomp$async$this$$._name || $albumMetadata$$.name, $$jscomp$generator$context$$.yield($$jscomp$async$this$$._audioResource.load($albumMetadata$$.albumUrl), 4);
        case 4:
          for ($i$$ = 0; $i$$ < $albumMetadata$$.tracks.length; $i$$++) {
            $trackData$$ = $albumMetadata$$.tracks[$i$$], $$jscomp$async$this$$._trackIndex.push($trackData$$.name), $$jscomp$async$this$$._tracks[$trackData$$.name] = new hamonengine.audio.track({audioext:$$jscomp$async$this$$._audioResource.clone(), name:$trackData$$.name, trackBegin:$trackData$$.begin, trackEnd:$trackData$$.end});
          }
          return $$jscomp$generator$context$$.return(Promise.resolve());
      }
    });
  };
  hamonengine.audio.album.prototype.getTrack = function $hamonengine$audio$album$$getTrack$($name$$) {
    return this._tracks[$name$$].clone();
  };
  hamonengine.audio.album.prototype.getTrackByOrdinal = function $hamonengine$audio$album$$getTrackByOrdinal$($index$$) {
    return this._tracks[this._trackIndex[$index$$]].clone();
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.album.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, length:{configurable:!0, enumerable:!0, get:function() {
    return this._trackIndex.length;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._audioResource.isLoaded();
  }}});
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.audioext = function $hamonengine$audio$audioext$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.audio.audioext && ($options$$ = {audio:$options$$._audio, src:$options$$._src, loop:$options$$._loop, buffer:$options$$._buffer, resourceState:$options$$._resourceState, audioCtx:$options$$._audio ? $options$$._audioCtx : null, gainNode:$options$$._audio ? $options$$._gainNode : null, panNode:$options$$._audio ? $options$$._panNode : null, mediaSource:$options$$._audio ? $options$$._mediaSource : null});
    this._loop = void 0 !== $options$$.loop ? $options$$.loop : !1;
    this._src = $options$$.src;
    this._audio = $options$$.audio;
    this._buffer = $options$$.buffer;
    this._fallbackSourceURLs = [];
    if (this.audio) {
      var $sourceElements$$ = this.audio.children;
      if (0 < $sourceElements$$.length) {
        for (var $i$$ = 0; $i$$ < $sourceElements$$.length; $i$$++) {
          this._fallbackSourceURLs.push($sourceElements$$[$i$$].src);
        }
      }
    }
    this._resourceState = $options$$.resourceState || 0;
    this._playingState = 5;
    this._startTime = 0;
    this._mediaSource = $options$$.mediaSource;
    this._audioNodes = [];
    this._audioCtx = $options$$.audioCtx || new AudioContext;
    this._gainNode = $options$$.gainNode || this._audioCtx.createGain();
    this._panNode = $options$$.panNode || new StereoPannerNode(this._audioCtx, {pan:0});
    this._audioListenerDelegate = null;
    hamonengine.debug && (console.debug("[hamonengine.audio.audioext.constructor] ResourceState: {" + this._resourceState + "}"), console.debug("[hamonengine.audio.audioext.constructor] PlayingState: {" + this._playingState + "}"));
  };
  hamonengine.audio.audioext.prototype.clone = function $hamonengine$audio$audioext$$clone$() {
    return new hamonengine.audio.audioext(this);
  };
  hamonengine.audio.audioext.prototype.load = function $hamonengine$audio$audioext$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this, $handleSuccess$$, $handleFailure$$, $$jscomp$destructuring$var4$$, $data$$, $buffer$jscomp$0$$, $error$jscomp$0$$;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      switch($$jscomp$generator$context$$.nextAddress) {
        case 1:
          if ($$jscomp$async$this$$.isLoaded) {
            return $$jscomp$generator$context$$.return(Promise.resolve($$jscomp$async$this$$));
          }
          $$jscomp$async$this$$.audio ? ($src$$ = $src$$ ? $src$$ : $$jscomp$async$this$$.audio.src, $$jscomp$async$this$$.audio.load()) : $src$$ = $src$$ ? $src$$ : $$jscomp$async$this$$.src;
          $$jscomp$async$this$$._resourceState = 1;
          $handleSuccess$$ = function $$handleSuccess$$$($buffer$$) {
            $$jscomp$async$this$$.audio ? $$jscomp$async$this$$._mediaSource || ($$jscomp$async$this$$._mediaSource = $$jscomp$async$this$$.context.createMediaElementSource($$jscomp$async$this$$.audio), $$jscomp$async$this$$._mediaSource.connect($$jscomp$async$this$$._gainNode).connect($$jscomp$async$this$$._panNode).connect($$jscomp$async$this$$.context.destination)) : $$jscomp$async$this$$._buffer = $buffer$$;
            $$jscomp$async$this$$._src = $src$$;
            $$jscomp$async$this$$._resourceState = 2;
            hamonengine.debug && console.debug("[hamonengine.audio.audioext.load] Audio '" + $$jscomp$async$this$$.src + "' has loaded successfully.");
            return Promise.resolve($$jscomp$async$this$$);
          };
          $handleFailure$$ = function $$handleFailure$$$($error$$) {
            $$jscomp$async$this$$._resourceState = 3;
            $$jscomp$async$this$$._buffer = null;
            return Promise.reject("The audio '" + $src$$ + "' could not be loaded.  Due to '" + ($error$$ instanceof String ? $error$$ : $error$$.statusText || $error$$) + "'.");
          };
          if ($$jscomp$async$this$$.audio) {
            return $$jscomp$async$this$$.audio.addEventListener("error", function($error$$) {
              return $handleFailure$$($error$$);
            }, !1), $$jscomp$async$this$$.audio.addEventListener("stalled", function($error$$) {
              return $handleFailure$$($error$$);
            }, !1), $$jscomp$async$this$$.audio.addEventListener("ended", function() {
              return $$jscomp$async$this$$.onAudioEnd();
            }, !1), 0 === $$jscomp$async$this$$.audio.readyState ? ($$jscomp$async$this$$.audio.addEventListener("loadeddata", function() {
              return $handleSuccess$$();
            }, !1), $$jscomp$generator$context$$.return(Promise.resolve($$jscomp$async$this$$))) : $$jscomp$generator$context$$.return($handleSuccess$$());
          }
          $$jscomp$generator$context$$.setCatchFinallyBlocks(3);
          return $$jscomp$generator$context$$.yield(connect.get($src$$, {responseType:"arraybuffer"}), 5);
        case 5:
          return $$jscomp$destructuring$var4$$ = $$jscomp$generator$context$$.yieldResult, $data$$ = $$jscomp$destructuring$var4$$.data, $$jscomp$generator$context$$.yield($$jscomp$async$this$$.context.decodeAudioData($data$$), 6);
        case 6:
          return $buffer$jscomp$0$$ = $$jscomp$generator$context$$.yieldResult, $$jscomp$generator$context$$.return($handleSuccess$$($buffer$jscomp$0$$));
        case 3:
          return $error$jscomp$0$$ = $$jscomp$generator$context$$.enterCatchBlock(), $$jscomp$generator$context$$.return($handleFailure$$($error$jscomp$0$$));
      }
    });
  };
  hamonengine.audio.audioext.prototype.play = function $hamonengine$audio$audioext$$play$($begin$$, $end$$) {
    var $$jscomp$async$this$$ = this, $i$$;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      if (1 == $$jscomp$generator$context$$.nextAddress) {
        if ($$jscomp$async$this$$.isPlaying) {
          return $$jscomp$generator$context$$.jumpTo(0);
        }
        $$jscomp$async$this$$._startTime = $$jscomp$async$this$$.context.currentTime;
        return "suspended" !== $$jscomp$async$this$$.context.state ? $$jscomp$generator$context$$.jumpTo(3) : $$jscomp$generator$context$$.yield($$jscomp$async$this$$.context.resume(), 3);
      }
      if ($$jscomp$async$this$$.isPaused) {
        return $$jscomp$async$this$$._playingState = 4, $$jscomp$generator$context$$.return();
      }
      $$jscomp$async$this$$._playingState = 4;
      if ($$jscomp$async$this$$.audio) {
        return $$jscomp$async$this$$.audio.currentTime = $begin$$, $$jscomp$generator$context$$.return($$jscomp$async$this$$.audio.play());
      }
      $$jscomp$async$this$$._mediaSource = $$jscomp$async$this$$.context.createBufferSource();
      $$jscomp$async$this$$._mediaSource.connect($$jscomp$async$this$$._gainNode).connect($$jscomp$async$this$$._panNode);
      $$jscomp$async$this$$._mediaSource.addEventListener("ended", function($e$$) {
        return $$jscomp$async$this$$.onAudioEnd($e$$);
      }, !1);
      for ($i$$ = 0; $i$$ < $$jscomp$async$this$$._audioNodes.length; $i$$++) {
        $$jscomp$async$this$$._mediaSource.connect($$jscomp$async$this$$._audioNodes[$i$$]);
      }
      $$jscomp$async$this$$._mediaSource.connect($$jscomp$async$this$$.context.destination);
      $end$$ = $end$$ || $$jscomp$async$this$$.duration;
      $$jscomp$async$this$$._mediaSource.buffer = $$jscomp$async$this$$.buffer;
      ($$jscomp$async$this$$._mediaSource.loop = $$jscomp$async$this$$.loop) ? ($$jscomp$async$this$$._mediaSource.loopStart = $begin$$, $$jscomp$async$this$$._mediaSource.loopEnd = $end$$, $$jscomp$async$this$$._mediaSource.start(0, $begin$$)) : $$jscomp$async$this$$._mediaSource.start(0, $begin$$, $end$$ - $begin$$);
      return $$jscomp$generator$context$$.return(Promise.resolve());
    });
  };
  hamonengine.audio.audioext.prototype.pause = function $hamonengine$audio$audioext$$pause$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      if ($$jscomp$async$this$$.isPlaying) {
        return $$jscomp$async$this$$._playingState = 6, $$jscomp$generator$context$$.return($$jscomp$async$this$$.context.suspend());
      }
      $$jscomp$generator$context$$.jumpToEnd();
    });
  };
  hamonengine.audio.audioext.prototype.stop = function $hamonengine$audio$audioext$$stop$($$jscomp$destructuring$var5_$$) {
    $$jscomp$destructuring$var5_$$ = void 0 === $$jscomp$destructuring$var5_$$ ? {} : $$jscomp$destructuring$var5_$$;
    var $suspend$$ = void 0 === $$jscomp$destructuring$var5_$$.suspend ? !0 : $$jscomp$destructuring$var5_$$.suspend, $$jscomp$async$this$$ = this;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      if (1 == $$jscomp$generator$context$$.nextAddress) {
        $$jscomp$async$this$$._playingState = 5;
        if (!$$jscomp$async$this$$.audio) {
          return $$jscomp$async$this$$._mediaSource && ($$jscomp$async$this$$._mediaSource.disconnect(), $$jscomp$async$this$$._mediaSource.stop(0), $$jscomp$async$this$$._mediaSource._userStopped = !0, $$jscomp$async$this$$._mediaSource = null), $$jscomp$generator$context$$.jumpTo(2);
        }
        $$jscomp$async$this$$.audio.currentTime = 0;
        return $$jscomp$generator$context$$.yield($$jscomp$async$this$$.audio.pause(), 2);
      }
      return $$jscomp$generator$context$$.return($suspend$$ ? $$jscomp$async$this$$.context.suspend() : Promise.resolve());
    });
  };
  hamonengine.audio.audioext.prototype.connect = function $hamonengine$audio$audioext$$connect$($audioNode$$) {
    this._mediaSource && this._mediaSource instanceof HTMLAudioElement && this._mediaSource.connect($audioNode$$);
    this._audioNodes.push($audioNode$$);
    return $audioNode$$;
  };
  hamonengine.audio.audioext.prototype.disconnect = function $hamonengine$audio$audioext$$disconnect$($audioNode$$) {
    this._mediaSource && this._mediaSource instanceof HTMLAudioElement && this._mediaSource.disconnect($audioNode$$);
    this._audioNodes = this._audioNodes.filter(function($node$$) {
      return $node$$ !== $audioNode$$;
    });
    return $audioNode$$;
  };
  hamonengine.audio.audioext.prototype.onAudioEnd = function $hamonengine$audio$audioext$$onAudioEnd$($e$$) {
    $e$$ = $e$$ && $e$$.currentTarget && $e$$.currentTarget._userStopped || !1;
    4 !== this._playingState || $e$$ || this.loop || (this._playingState = 5, this.audioListenerDelegate && this.audioListenerDelegate.onAudioEnd && this.audioListenerDelegate.onAudioEnd());
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.audioext.prototype, {context:{configurable:!0, enumerable:!0, get:function() {
    return this._audioCtx;
  }}, buffer:{configurable:!0, enumerable:!0, get:function() {
    return this._buffer;
  }}, audio:{configurable:!0, enumerable:!0, get:function() {
    return this._audio;
  }}, src:{configurable:!0, enumerable:!0, get:function() {
    return this._src;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return 2 === this._resourceState;
  }}, isPlaying:{configurable:!0, enumerable:!0, get:function() {
    return 4 === this._playingState;
  }}, isStopped:{configurable:!0, enumerable:!0, get:function() {
    return 5 === this._playingState;
  }}, isPaused:{configurable:!0, enumerable:!0, get:function() {
    return 6 === this._playingState;
  }}, fallbackSourceURLs:{configurable:!0, enumerable:!0, get:function() {
    return this._fallbackSourceURLs;
  }}, duration:{configurable:!0, enumerable:!0, get:function() {
    return this.audio ? this.audio.duration : this.buffer && this.buffer.duration || 0;
  }}, currentTime:{configurable:!0, enumerable:!0, get:function() {
    return this.audio ? this.audio.currentTime : this.isPlaying ? this.context.currentTime - this._startTime : 0;
  }}, loop:{configurable:!0, enumerable:!0, get:function() {
    return this._loop;
  }, set:function($v$$) {
    this._loop = $v$$;
    this.audio && (this.audio.loop = $v$$);
    this._mediaSource && (this._mediaSource.loop = $v$$);
  }}, muted:{configurable:!0, enumerable:!0, get:function() {
    return 0 === this._gainNode.gain.value;
  }, set:function($v$$) {
    $v$$ ? (this._preMutedVolume = this.volume, this.volume = 0) : void 0 !== this._preMutedVolume && (this.volume = this._preMutedVolume, delete this._preMutedVolume);
  }}, volume:{configurable:!0, enumerable:!0, get:function() {
    return this._gainNode.gain.value;
  }, set:function($v$$) {
    this._gainNode.gain.value = 1.0 < $v$$ ? 1.0 : $v$$;
  }}, audioListenerDelegate:{configurable:!0, enumerable:!0, get:function() {
    return this._audioListenerDelegate;
  }, set:function($v$$) {
    this._audioListenerDelegate = $v$$;
  }}});
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.playlist = function $hamonengine$audio$playlist$($options$$) {
    var $$jscomp$this$$ = this;
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.audio.playlist && ($options$$ = {tracks:$options$$._tracks.map(function($track$$) {
      return $track$$.clone();
    }), index:$options$$._index, loop:$options$$._loop, autoplay:$options$$._autoplay});
    this._name = $options$$.name;
    this._tracks = [];
    this._index = $options$$.index || 0;
    this._loop = $options$$.loop || 0;
    this._autoplay = void 0 !== $options$$.autoplay ? $options$$.autoplay : !1;
    this._autoplayFilters = $options$$.autoplayFilters || [];
    this._volume = 1.0;
    this._listenerPool = new listenerPool;
    ($options$$.tracks || []).forEach(function($track$$) {
      return $$jscomp$this$$.addTrack($track$$);
    });
    hamonengine.debug && (console.debug("[hamonengine.audio.playlist.constructor] Name: " + this._name), console.debug("[hamonengine.audio.playlist.constructor] Track Index: " + this._index), console.debug("[hamonengine.audio.playlist.constructor] Loop: " + (this._loop ? "true" : "false")), console.debug("[hamonengine.audio.playlist.constructor] Autoplay: " + (this._autoplay ? "true" : "false")));
  };
  hamonengine.audio.playlist.prototype.clone = function $hamonengine$audio$playlist$$clone$() {
    return new hamonengine.audio.playlist(this);
  };
  hamonengine.audio.playlist.prototype.register = function $hamonengine$audio$playlist$$register$($listener$$) {
    this._listenerPool.register($listener$$);
  };
  hamonengine.audio.playlist.prototype.load = function $hamonengine$audio$playlist$$load$() {
    var $$jscomp$async$this$$ = this, $unloadedTracks$$, $i$$;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      $unloadedTracks$$ = [];
      for ($i$$ = 0; $i$$ < $$jscomp$async$this$$._tracks.length; $i$$++) {
        $$jscomp$async$this$$._tracks[$i$$].isLoaded || $unloadedTracks$$.push($$jscomp$async$this$$._tracks[$i$$].load());
      }
      return 0 < $unloadedTracks$$.length ? $$jscomp$generator$context$$.return(Promise.all($unloadedTracks$$)) : $$jscomp$generator$context$$.return(Promise.resolve());
    });
  };
  hamonengine.audio.playlist.prototype.play = function $hamonengine$audio$playlist$$play$($trackname$$) {
    $trackname$$ = void 0 === $trackname$$ ? "" : $trackname$$;
    if (!this.currentTrack.isPlaying) {
      if ("" !== $trackname$$) {
        var $index$$ = this._tracks.findIndex(function($track$$) {
          return $track$$.name === $trackname$$;
        });
        -1 < $index$$ && (this.index = $index$$);
      }
      this.currentTrack.volume = this.volume;
      this.currentTrack.play();
      this._listenerPool.invoke("onPlaylistPlay", {track:this.currentTrack});
    }
  };
  hamonengine.audio.playlist.prototype.pause = function $hamonengine$audio$playlist$$pause$() {
    this.currentTrack.pause();
    this._listenerPool.invoke("onPlaylistPause", {track:this.currentTrack});
  };
  hamonengine.audio.playlist.prototype.stop = function $hamonengine$audio$playlist$$stop$($$jscomp$destructuring$var7_$jscomp$destructuring$var8_reason$$) {
    $$jscomp$destructuring$var7_$jscomp$destructuring$var8_reason$$ = void 0 === $$jscomp$destructuring$var7_$jscomp$destructuring$var8_reason$$ ? {} : $$jscomp$destructuring$var7_$jscomp$destructuring$var8_reason$$;
    $$jscomp$destructuring$var7_$jscomp$destructuring$var8_reason$$ = void 0 === $$jscomp$destructuring$var7_$jscomp$destructuring$var8_reason$$.reason ? "invoked" : $$jscomp$destructuring$var7_$jscomp$destructuring$var8_reason$$.reason;
    this.currentTrack.stop();
    this.index = 0;
    this._listenerPool.invoke("onPlaylistStop", {track:this.currentTrack, reason:$$jscomp$destructuring$var7_$jscomp$destructuring$var8_reason$$});
  };
  hamonengine.audio.playlist.prototype.next = function $hamonengine$audio$playlist$$next$() {
    this.currentTrack.isPlaying ? (this.currentTrack.stop(), this.index++, this.currentTrack.play()) : this.index++;
    this._listenerPool.invoke("onPlaylistNext", {track:this.currentTrack});
  };
  hamonengine.audio.playlist.prototype.prev = function $hamonengine$audio$playlist$$prev$() {
    this.currentTrack.isPlaying ? (this.currentTrack.stop(), this.index--, this.currentTrack.play()) : this.index--;
    this._listenerPool.invoke("onPlaylistPrevious", {track:this.currentTrack});
  };
  hamonengine.audio.playlist.prototype.addTrack = function $hamonengine$audio$playlist$$addTrack$($track$$) {
    $track$$.register(this);
    this._tracks.push($track$$);
  };
  hamonengine.audio.playlist.createAutoPlayFadeFilter = function $hamonengine$audio$playlist$createAutoPlayFadeFilter$($$jscomp$destructuring$var10_$$) {
    $$jscomp$destructuring$var10_$$ = void 0 === $$jscomp$destructuring$var10_$$ ? {} : $$jscomp$destructuring$var10_$$;
    var $fadeOutStart$$ = void 0 === $$jscomp$destructuring$var10_$$.fadeOutStart ? 0.01 : $$jscomp$destructuring$var10_$$.fadeOutStart, $rateOfFade$$ = void 0 === $$jscomp$destructuring$var10_$$.rateOfFade ? 0 : $$jscomp$destructuring$var10_$$.rateOfFade;
    return function($$jscomp$destructuring$var11_playList$$) {
      var $remainingTime_volume$$ = $$jscomp$destructuring$var11_playList$$.remainingTime, $currentTrack$$ = $$jscomp$destructuring$var11_playList$$.currentTrack;
      $$jscomp$destructuring$var11_playList$$ = $$jscomp$destructuring$var11_playList$$.playList;
      var $fadeOutStartInterval$$ = $currentTrack$$.duration * $fadeOutStart$$;
      $remainingTime_volume$$ < $fadeOutStartInterval$$ && ($remainingTime_volume$$ = 0 < $rateOfFade$$ ? $currentTrack$$.volume - $rateOfFade$$ : $remainingTime_volume$$ / ($currentTrack$$.volume * $fadeOutStartInterval$$), 0 < $remainingTime_volume$$ ? $currentTrack$$.volume = $remainingTime_volume$$ : ($currentTrack$$.stop({suspend:!1}), $$jscomp$destructuring$var11_playList$$.next(), $$jscomp$destructuring$var11_playList$$.play()));
    };
  };
  hamonengine.audio.playlist.prototype.onTrackBegin = function $hamonengine$audio$playlist$$onTrackBegin$($$jscomp$destructuring$var13$$) {
  };
  hamonengine.audio.playlist.prototype.onTrackEnd = function $hamonengine$audio$playlist$$onTrackEnd$($$jscomp$destructuring$var15_track$$) {
    $$jscomp$destructuring$var15_track$$ = $$jscomp$destructuring$var15_track$$.track;
    this.autoplay && $$jscomp$destructuring$var15_track$$ === this.currentTrack && (this.loop || this.index < this._tracks.length - 1 ? (this.next(), this.play()) : this.stop({reason:"playlistend"}));
  };
  hamonengine.audio.playlist.prototype.onTrackUpdate = function $hamonengine$audio$playlist$$onTrackUpdate$($$jscomp$destructuring$var17_remainingTime$$) {
    var $track$$ = $$jscomp$destructuring$var17_remainingTime$$.track, $elapsedTime$$ = $$jscomp$destructuring$var17_remainingTime$$.elapsedTime;
    $$jscomp$destructuring$var17_remainingTime$$ = $$jscomp$destructuring$var17_remainingTime$$.remainingTime;
    if (0 < this._autoplayFilters.length) {
      for (var $nextTrack$$ = this._tracks[this.index + 1 % this._tracks.length], $i$$ = 0; $i$$ < this._autoplayFilters.length; $i$$++) {
        this._autoplayFilters[$i$$]({elapsedTime:$elapsedTime$$, remainingTime:$$jscomp$destructuring$var17_remainingTime$$, currentTrack:$track$$, nextTrack:$nextTrack$$, playList:this});
      }
    }
    this._listenerPool.invoke("onPlaylistUpdate", {track:$track$$, elapsedTime:$elapsedTime$$, remainingTime:$$jscomp$destructuring$var17_remainingTime$$, playlist:this});
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.playlist.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }, set:function($v$$) {
    this._name = $v$$;
  }}, index:{configurable:!0, enumerable:!0, get:function() {
    return this._index;
  }, set:function($index$jscomp$78_v$$) {
    $index$jscomp$78_v$$ %= this._tracks.length;
    this._index = 0 > $index$jscomp$78_v$$ ? this._tracks.length + $index$jscomp$78_v$$ : $index$jscomp$78_v$$;
  }}, isPlaying:{configurable:!0, enumerable:!0, get:function() {
    return this.currentTrack.isPlaying;
  }}, currentTrack:{configurable:!0, enumerable:!0, get:function() {
    return this._tracks[this.index];
  }}, loop:{configurable:!0, enumerable:!0, get:function() {
    return this._loop;
  }, set:function($v$$) {
    this._loop = $v$$;
  }}, autoplay:{configurable:!0, enumerable:!0, get:function() {
    return this._autoplay;
  }, set:function($v$$) {
    this._autoplay = $v$$;
  }}, volume:{configurable:!0, enumerable:!0, get:function() {
    return this._volume;
  }, set:function($v$$) {
    this._volume = $v$$;
  }}});
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.track = function $hamonengine$audio$track$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.audio.track && ($options$$ = {name:$options$$._name, audioext:$options$$._audioext.clone(), src:$options$$._src, trackBegin:$options$$._trackBegin, trackEnd:$options$$._trackEnd});
    this._name = $options$$.name;
    this._audioext = $options$$.audioext || new hamonengine.audio.audioext({audio:$options$$.audio, src:$options$$.src});
    this._trackBegin = $options$$.trackBegin || 0;
    this._trackEnd = $options$$.trackEnd;
    this._listenerPool = new listenerPool;
    hamonengine.debug && (console.debug("[hamonengine.audio.track.constructor] Name: " + this._name), console.debug("[hamonengine.audio.track.constructor] Track Begin: " + this._trackBegin), console.debug("[hamonengine.audio.track.constructor] Track End: {" + this._trackEnd + "}"));
  };
  hamonengine.audio.track.prototype.clone = function $hamonengine$audio$track$$clone$() {
    return new hamonengine.audio.track(this);
  };
  hamonengine.audio.track.prototype.register = function $hamonengine$audio$track$$register$($listener$$) {
    this._listenerPool.register($listener$$);
  };
  hamonengine.audio.track.prototype.load = function $hamonengine$audio$track$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      return $$jscomp$generator$context$$.return($$jscomp$async$this$$._audioext.load($src$$));
    });
  };
  hamonengine.audio.track.prototype.play = function $hamonengine$audio$track$$play$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      $$jscomp$async$this$$._audioext.audioListenerDelegate = $$jscomp$async$this$$;
      return $$jscomp$generator$context$$.return($$jscomp$async$this$$._audioext.play($$jscomp$async$this$$._trackBegin, $$jscomp$async$this$$._trackEnd));
    });
  };
  hamonengine.audio.track.prototype.pause = function $hamonengine$audio$track$$pause$() {
    return this._audioext.pause();
  };
  hamonengine.audio.track.prototype.stop = function $hamonengine$audio$track$$stop$($$jscomp$destructuring$var19_$$) {
    $$jscomp$destructuring$var19_$$ = void 0 === $$jscomp$destructuring$var19_$$ ? {} : $$jscomp$destructuring$var19_$$;
    var $suspend$$ = void 0 === $$jscomp$destructuring$var19_$$.suspend ? !0 : $$jscomp$destructuring$var19_$$.suspend, $$jscomp$async$this$$ = this;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      return $$jscomp$generator$context$$.return($$jscomp$async$this$$._audioext.stop({suspend:$suspend$$}));
    });
  };
  hamonengine.audio.track.prototype.onTrackBegin = function $hamonengine$audio$track$$onTrackBegin$() {
    this._listenerPool.invoke("onTrackBegin", {track:this});
  };
  hamonengine.audio.track.prototype.onAudioEnd = function $hamonengine$audio$track$$onAudioEnd$() {
    this.loop ? this.play() : this._listenerPool.invoke("onTrackEnd", {track:this});
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.track.prototype, {src:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.src;
  }}, name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }, set:function($v$$) {
    this._name = $v$$;
  }}, context:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.context;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.isLoaded;
  }}, isPlaying:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.isPlaying;
  }}, duration:{configurable:!0, enumerable:!0, get:function() {
    return (this._trackEnd || this._audioext.duration) - this._trackBegin;
  }}, fallbackSourceURLs:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.fallbackSourceURLs;
  }}, autoplay:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.autoplay;
  }, set:function($v$$) {
    this._audioext.autoplay = $v$$;
  }}, loop:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.loop;
  }, set:function($v$$) {
    this._audioext.loop = $v$$;
  }}, muted:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.muted;
  }, set:function($v$$) {
    this._audioext.muted = $v$$;
  }}, volume:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.volume;
  }, set:function($v$$) {
    this._audioext.volume = $v$$;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.interval = function $hamonengine$geometry$interval$($min$$, $max$$) {
    this.min = void 0 === $min$$ ? 0.0 : $min$$;
    this.max = void 0 === $max$$ ? 0.0 : $max$$;
  };
  hamonengine.geometry.interval.clone = function $hamonengine$geometry$interval$clone$($interval$$) {
    return new hamonengine.geometry.interval($interval$$.min, $interval$$.max);
  };
  hamonengine.geometry.interval.prototype.clone = function $hamonengine$geometry$interval$$clone$() {
    return hamonengine.geometry.interval.clone(this);
  };
  hamonengine.geometry.interval.prototype.toString = function $hamonengine$geometry$interval$$toString$() {
    return "{min: '" + this.min + "', max: '" + this.max + "'}";
  };
  hamonengine.geometry.interval.prototype.mirror = function $hamonengine$geometry$interval$$mirror$() {
    return new hamonengine.geometry.interval(this.max, this.min);
  };
  hamonengine.geometry.interval.prototype.add = function $hamonengine$geometry$interval$$add$($l$$) {
    return new hamonengine.geometry.interval(this.min + $l$$.min, this.max + $l$$.max);
  };
  hamonengine.geometry.interval.prototype.subtract = function $hamonengine$geometry$interval$$subtract$($l$$) {
    return new hamonengine.geometry.interval(this.min - $l$$.min, this.max - $l$$.max);
  };
  hamonengine.geometry.interval.prototype.multiplyScalar = function $hamonengine$geometry$interval$$multiplyScalar$($s$$) {
    return new hamonengine.geometry.interval(this.min * $s$$, this.max * $s$$);
  };
  hamonengine.geometry.interval.prototype.overlap = function $hamonengine$geometry$interval$$overlap$($i$$) {
    if (this.isPoint && $i$$.isPoint) {
      return this.min === $i$$.min ? new hamonengine.geometry.interval(0, 0) : new hamonengine.geometry.interval(NaN, NaN);
    }
    if (this.isPoint || $i$$.isPoint) {
      var $min$jscomp$2_p$$ = this;
      this.isPoint || ($min$jscomp$2_p$$ = $i$$, $i$$ = this);
      var $max$$ = NaN, $isPointOnLine_max$4$$ = NaN;
      $i$$.contains($min$jscomp$2_p$$) && ($min$jscomp$2_p$$.min - $i$$.min < $i$$.max - $min$jscomp$2_p$$.min ? ($max$$ = $i$$.min, $isPointOnLine_max$4$$ = $min$jscomp$2_p$$.min) : ($max$$ = $min$jscomp$2_p$$.min, $isPointOnLine_max$4$$ = $i$$.max));
      return new hamonengine.geometry.interval($max$$, $isPointOnLine_max$4$$);
    }
    $max$$ = $min$jscomp$2_p$$ = NaN;
    this.isPoint || $i$$.isPoint || ($isPointOnLine_max$4$$ = function $$isPointOnLine_max$4$$$($point$$, $interval$$) {
      return $point$$ >= $interval$$.min && $point$$ <= $interval$$.max;
    }, $isPointOnLine_max$4$$(this.min, $i$$) ? $min$jscomp$2_p$$ = this.min : $isPointOnLine_max$4$$($i$$.min, this) && ($min$jscomp$2_p$$ = $i$$.min), $isPointOnLine_max$4$$(this.max, $i$$) ? $max$$ = this.max : $isPointOnLine_max$4$$($i$$.max, this) && ($max$$ = $i$$.max));
    return new hamonengine.geometry.interval($min$jscomp$2_p$$, $max$$);
  };
  hamonengine.geometry.interval.prototype.contains = function $hamonengine$geometry$interval$$contains$($i$$) {
    return $i$$.min >= this.min && $i$$.max <= this.max;
  };
  hamonengine.geometry.interval.prototype.getOrientation = function $hamonengine$geometry$interval$$getOrientation$($i$$) {
    var $tMidPoint$$ = this.midPoint;
    $i$$ = $i$$.midPoint;
    return $i$$ === $tMidPoint$$ ? 0 : $i$$ < $tMidPoint$$ ? -1 : 1;
  };
  hamonengine.geometry.interval.prototype.getDistance = function $hamonengine$geometry$interval$$getDistance$($i$$) {
    return Math.abs(this.midPoint - $i$$.midPoint);
  };
  hamonengine.geometry.interval.prototype.getMinimumDistance = function $hamonengine$geometry$interval$$getMinimumDistance$($i$$) {
    return this.getDistanceParams($i$$).min;
  };
  hamonengine.geometry.interval.prototype.getMaximumDistance = function $hamonengine$geometry$interval$$getMaximumDistance$($i$$) {
    return this.getDistanceParams($i$$).max;
  };
  hamonengine.geometry.interval.prototype.getDistanceParams = function $hamonengine$geometry$interval$$getDistanceParams$($i$jscomp$25_max$$) {
    var $min$$ = Math.abs(this.min - $i$jscomp$25_max$$.min);
    $i$jscomp$25_max$$ = Math.abs(this.max - $i$jscomp$25_max$$.max);
    return {min:$min$$ < $i$jscomp$25_max$$ ? $min$$ : $i$jscomp$25_max$$, max:$min$$ > $i$jscomp$25_max$$ ? $min$$ : $i$jscomp$25_max$$};
  };
  hamonengine.geometry.interval.prototype.getPointDistance = function $hamonengine$geometry$interval$$getPointDistance$($i$$, $direction$$) {
    var $p$$ = this;
    this.isPoint || ($p$$ = $i$$, $i$$ = this);
    return 0 < $direction$$ ? $i$$.max - $p$$.max : $p$$.max - $i$$.min;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.interval.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.abs(this.max - this.min);
  }}, isLine:{configurable:!0, enumerable:!0, get:function() {
    return !isNaN(this.min) && !isNaN(this.max);
  }}, isPoint:{configurable:!0, enumerable:!0, get:function() {
    return this.isLine && this.min === this.max;
  }}, midPoint:{configurable:!0, enumerable:!0, get:function() {
    return this.isPoint ? this.min : (this.max - this.min) / 2;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.lineSegment = function $hamonengine$geometry$lineSegment$($x$$, $y$$, $x2$$, $y2$$, $options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._coords = $options$$.coords || [void 0 === $x$$ ? 0 : $x$$, void 0 === $y$$ ? 0 : $y$$, void 0 === $x2$$ ? 0 : $x2$$, void 0 === $y2$$ ? 0 : $y2$$];
    this._offset = $options$$.offset || 0;
    this._normalOrientation = void 0 !== $options$$.normalOrientation ? $options$$.normalOrientation : ROTATION_TYPE.CW;
    this._direction = new hamonengine.math.vector2(this.x2 - this.x, this.y2 - this.y);
  };
  hamonengine.geometry.lineSegment.prototype.clone = function $hamonengine$geometry$lineSegment$$clone$() {
    return new hamonengine.geometry.lineSegment(this.x, this.y, this.x2, this.y2, {coords:[].concat($jscomp.arrayFromIterable(this._coords)), offset:this._offset});
  };
  hamonengine.geometry.lineSegment.prototype.toString = function $hamonengine$geometry$lineSegment$$toString$() {
    return "({x1: " + this.x + ", y1: " + this.y + "}, {x2: " + this.x2 + ", y2: " + this.y2 + "})";
  };
  hamonengine.geometry.lineSegment.prototype.toVertices = function $hamonengine$geometry$lineSegment$$toVertices$() {
    return [new hamonengine.math.vector2(this.x, this.y), new hamonengine.math.vector2(this.x2, this.y2)];
  };
  hamonengine.geometry.lineSegment.prototype.toPolygon = function $hamonengine$geometry$lineSegment$$toPolygon$() {
    return new hamonengine.geometry.polygon({vertices:this.toVertices()});
  };
  hamonengine.geometry.lineSegment.prototype.equals = function $hamonengine$geometry$lineSegment$$equals$($l$$) {
    return this.x === $l$$.x && this.y === $l$$.y && this.x2 === $l$$.x2 && this.y2 === $l$$.y2 || this.x === $l$$.x2 && this.y === $l$$.y2 && this.x2 === $l$$.x && this.y2 === $l$$.y;
  };
  hamonengine.geometry.lineSegment.prototype.sharesEndPoint = function $hamonengine$geometry$lineSegment$$sharesEndPoint$($l$$) {
    return this.x2 === $l$$.x && this.y2 === $l$$.y || this.x === $l$$.x2 && this.y === $l$$.y2;
  };
  hamonengine.geometry.lineSegment.prototype.sharesPoints = function $hamonengine$geometry$lineSegment$$sharesPoints$($l$$) {
    return this.x === $l$$.x && this.y === $l$$.y || this.x2 === $l$$.x2 && this.y2 === $l$$.y2 || this.sharesEndPoint($l$$);
  };
  hamonengine.geometry.lineSegment.prototype.translate = function $hamonengine$geometry$lineSegment$$translate$($translateVector$$) {
    $translateVector$$ = $translateVector$$ || new hamonengine.math.vector2(0, 0);
    return new hamonengine.geometry.lineSegment(this.x + $translateVector$$.x, this.y + $translateVector$$.y, this.x2 + $translateVector$$.x, this.y2 + $translateVector$$.y);
  };
  hamonengine.geometry.lineSegment.prototype.rotate = function $hamonengine$geometry$lineSegment$$rotate$($theta_x$$, $offsetVector$$, $$jscomp$destructuring$var21_sinTheta_y2$$) {
    var $$jscomp$destructuring$var22_cosTheta$$ = void 0 === $$jscomp$destructuring$var21_sinTheta_y2$$ ? {} : $$jscomp$destructuring$var21_sinTheta_y2$$;
    $$jscomp$destructuring$var21_sinTheta_y2$$ = $$jscomp$destructuring$var22_cosTheta$$.sinTheta;
    $$jscomp$destructuring$var22_cosTheta$$ = $$jscomp$destructuring$var22_cosTheta$$.cosTheta;
    $theta_x$$ = $theta_x$$ || 0.0;
    $offsetVector$$ = $offsetVector$$ || new hamonengine.math.vector2(0, 0);
    $$jscomp$destructuring$var21_sinTheta_y2$$ = $$jscomp$destructuring$var21_sinTheta_y2$$ || Math.sin($theta_x$$);
    $$jscomp$destructuring$var22_cosTheta$$ = $$jscomp$destructuring$var22_cosTheta$$ || Math.cos($theta_x$$);
    var $xOffset_y$$ = this.x - $offsetVector$$.x, $x2$$ = this.y - $offsetVector$$.y, $xOffset2$$ = this.x2 - $offsetVector$$.x, $yOffset2$$ = this.y2 - $offsetVector$$.y;
    hamonengine.geometry.settings.coordinateSystem === COORDINATE_SYSTEM.RHS ? ($theta_x$$ = $xOffset_y$$ * $$jscomp$destructuring$var22_cosTheta$$ - $x2$$ * $$jscomp$destructuring$var21_sinTheta_y2$$, $xOffset_y$$ = $xOffset_y$$ * $$jscomp$destructuring$var21_sinTheta_y2$$ + $x2$$ * $$jscomp$destructuring$var22_cosTheta$$, $x2$$ = $xOffset2$$ * $$jscomp$destructuring$var22_cosTheta$$ - $yOffset2$$ * $$jscomp$destructuring$var21_sinTheta_y2$$, $$jscomp$destructuring$var21_sinTheta_y2$$ = $xOffset2$$ * 
    $$jscomp$destructuring$var21_sinTheta_y2$$ + $yOffset2$$ * $$jscomp$destructuring$var22_cosTheta$$) : ($theta_x$$ = $xOffset_y$$ * $$jscomp$destructuring$var22_cosTheta$$ + $x2$$ * $$jscomp$destructuring$var21_sinTheta_y2$$, $xOffset_y$$ = -($xOffset_y$$ * $$jscomp$destructuring$var21_sinTheta_y2$$) + $x2$$ * $$jscomp$destructuring$var22_cosTheta$$, $x2$$ = $xOffset2$$ * $$jscomp$destructuring$var22_cosTheta$$ + $yOffset2$$ * $$jscomp$destructuring$var21_sinTheta_y2$$, $$jscomp$destructuring$var21_sinTheta_y2$$ = 
    -($xOffset2$$ * $$jscomp$destructuring$var21_sinTheta_y2$$) + $yOffset2$$ * $$jscomp$destructuring$var22_cosTheta$$);
    $theta_x$$ += $offsetVector$$.x;
    $xOffset_y$$ += $offsetVector$$.y;
    $x2$$ += $offsetVector$$.x;
    $$jscomp$destructuring$var21_sinTheta_y2$$ += $offsetVector$$.y;
    return new hamonengine.geometry.lineSegment($theta_x$$, $xOffset_y$$, $x2$$, $$jscomp$destructuring$var21_sinTheta_y2$$);
  };
  hamonengine.geometry.lineSegment.prototype.rotateAtCenter = function $hamonengine$geometry$lineSegment$$rotateAtCenter$($theta$$) {
    return this.rotate($theta$$, this.center);
  };
  hamonengine.geometry.lineSegment.prototype.scale = function $hamonengine$geometry$lineSegment$$scale$($scaleVector_y2$$, $offsetVector$$, $$jscomp$destructuring$var23_x$$) {
    var $$jscomp$destructuring$var24_y$$ = void 0 === $$jscomp$destructuring$var23_x$$ ? {} : $$jscomp$destructuring$var23_x$$;
    $$jscomp$destructuring$var23_x$$ = $$jscomp$destructuring$var24_y$$.xFlipped;
    $$jscomp$destructuring$var24_y$$ = $$jscomp$destructuring$var24_y$$.yFlipped;
    $scaleVector_y2$$ = $scaleVector_y2$$ || new hamonengine.math.vector2(0, 0);
    $offsetVector$$ = $offsetVector$$ || new hamonengine.math.vector2(0, 0);
    $$jscomp$destructuring$var23_x$$ = $$jscomp$destructuring$var23_x$$ || 0 > $scaleVector_y2$$.x;
    $$jscomp$destructuring$var24_y$$ = $$jscomp$destructuring$var24_y$$ || 0 > $scaleVector_y2$$.y;
    if (!$$jscomp$destructuring$var23_x$$ && $$jscomp$destructuring$var24_y$$ || $$jscomp$destructuring$var23_x$$ & !$$jscomp$destructuring$var24_y$$) {
      $$jscomp$destructuring$var23_x$$ = this.x2 * $scaleVector_y2$$.x + $offsetVector$$.x;
      $$jscomp$destructuring$var24_y$$ = this.y2 * $scaleVector_y2$$.y + $offsetVector$$.y;
      var $x2$$ = this.x * $scaleVector_y2$$.x + $offsetVector$$.x;
      $scaleVector_y2$$ = this.y * $scaleVector_y2$$.y + $offsetVector$$.y;
    } else {
      $$jscomp$destructuring$var23_x$$ = this.x * $scaleVector_y2$$.x + $offsetVector$$.x, $$jscomp$destructuring$var24_y$$ = this.y * $scaleVector_y2$$.y + $offsetVector$$.y, $x2$$ = this.x2 * $scaleVector_y2$$.x + $offsetVector$$.x, $scaleVector_y2$$ = this.y2 * $scaleVector_y2$$.y + $offsetVector$$.y;
    }
    return new hamonengine.geometry.lineSegment($$jscomp$destructuring$var23_x$$, $$jscomp$destructuring$var24_y$$, $x2$$, $scaleVector_y2$$);
  };
  hamonengine.geometry.lineSegment.prototype.scaleAtCenter = function $hamonengine$geometry$lineSegment$$scaleAtCenter$($scaleVector$$) {
    return this.scale($scaleVector$$, this.center.subtract(this.center.multiplyVector($scaleVector$$)));
  };
  hamonengine.geometry.lineSegment.prototype.isCollision = function $hamonengine$geometry$lineSegment$$isCollision$($shape$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.math.vector2 : $direction$$;
    return $shape$$ instanceof hamonengine.geometry.rect ? this.isCollisionRect($shape$$, $direction$$) : $shape$$ instanceof hamonengine.geometry.polygon ? this.isCollisionPolygon($shape$$, $direction$$) : new hamonengine.math.vector2(0, 0);
  };
  hamonengine.geometry.lineSegment.prototype.isCollisionPolygon = function $hamonengine$geometry$lineSegment$$isCollisionPolygon$($distance_polygon_shapeProject$$, $axes_direction$$) {
    void 0 === $axes_direction$$ && new hamonengine.math.vector2;
    $distance_polygon_shapeProject$$ instanceof hamonengine.geometry.polygon || console.warn("[hamonengine.geometry.lineSegment.isCollisionPolygon] The polygon parameter is not of type hamonengine.geometry.polygon!");
    $axes_direction$$ = $distance_polygon_shapeProject$$.normals;
    for (var $i$$ = 0; $i$$ < $axes_direction$$.length; $i$$++) {
      var $thisProjection$$ = this.project($axes_direction$$[$i$$]), $otherProjection$$ = $distance_polygon_shapeProject$$.project($axes_direction$$[$i$$]);
      if (!$thisProjection$$.overlap($otherProjection$$).isLine) {
        return new hamonengine.math.vector2;
      }
    }
    $axes_direction$$ = this.normal;
    $distance_polygon_shapeProject$$ = $distance_polygon_shapeProject$$.project($axes_direction$$);
    $i$$ = this.project($axes_direction$$);
    if (!$distance_polygon_shapeProject$$.overlap($i$$).isLine) {
      return new hamonengine.math.vector2;
    }
    $distance_polygon_shapeProject$$ = $distance_polygon_shapeProject$$.getPointDistance($i$$, $axes_direction$$);
    $distance_polygon_shapeProject$$ = $distance_polygon_shapeProject$$ < hamonengine.geometry.settings.collisionDetection.floor ? 0.0 : $distance_polygon_shapeProject$$;
    return $axes_direction$$.multiply($distance_polygon_shapeProject$$);
  };
  hamonengine.geometry.lineSegment.prototype.isCollisionRect = function $hamonengine$geometry$lineSegment$$isCollisionRect$($rect_shapeProject$$, $checkCollision$jscomp$1_direction$jscomp$10_distance$$) {
    $checkCollision$jscomp$1_direction$jscomp$10_distance$$ = void 0 === $checkCollision$jscomp$1_direction$jscomp$10_distance$$ ? new hamonengine.math.vector2 : $checkCollision$jscomp$1_direction$jscomp$10_distance$$;
    $rect_shapeProject$$ instanceof hamonengine.geometry.rect || console.warn("[hamonengine.geometry.lineSegment.isCollisionRect] The rect parameter is not of type hamonengine.geometry.rect!");
    $checkCollision$jscomp$1_direction$jscomp$10_distance$$ = function $$checkCollision$jscomp$1_direction$jscomp$10_distance$$$($thisProjection$$, $otherProjection$$) {
      return $thisProjection$$.overlap($otherProjection$$).isLine ? !0 : !1;
    };
    var $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$ = new hamonengine.geometry.interval($rect_shapeProject$$.y, $rect_shapeProject$$.y + $rect_shapeProject$$.height);
    if (!$checkCollision$jscomp$1_direction$jscomp$10_distance$$(this.project(hamonengine.math.vector2.Y_AXIS_NORMAL), $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$)) {
      return new hamonengine.math.vector2;
    }
    $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$ = new hamonengine.geometry.interval($rect_shapeProject$$.x, $rect_shapeProject$$.x + $rect_shapeProject$$.width);
    if (!$checkCollision$jscomp$1_direction$jscomp$10_distance$$(this.project(hamonengine.math.vector2.X_AXIS_NORMAL), $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$)) {
      return new hamonengine.math.vector2;
    }
    $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$ = this.normal;
    $rect_shapeProject$$ = $rect_shapeProject$$.project($X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$);
    var $lineProject$$ = this.project($X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$);
    if (!$checkCollision$jscomp$1_direction$jscomp$10_distance$$($rect_shapeProject$$, $lineProject$$)) {
      return new hamonengine.math.vector2;
    }
    $checkCollision$jscomp$1_direction$jscomp$10_distance$$ = $rect_shapeProject$$.getPointDistance($lineProject$$, $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$);
    $checkCollision$jscomp$1_direction$jscomp$10_distance$$ = $checkCollision$jscomp$1_direction$jscomp$10_distance$$ < hamonengine.geometry.settings.collisionDetection.floor ? 0.0 : $checkCollision$jscomp$1_direction$jscomp$10_distance$$;
    return $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$.multiply($checkCollision$jscomp$1_direction$jscomp$10_distance$$);
  };
  hamonengine.geometry.lineSegment.prototype.project = function $hamonengine$geometry$lineSegment$$project$($projection_unitVector$$) {
    var $min$$;
    var $max$$ = $min$$ = $projection_unitVector$$.dot({x:this.x, y:this.y});
    $projection_unitVector$$ = $projection_unitVector$$.dot({x:this.x2, y:this.y2});
    $projection_unitVector$$ < $min$$ ? $min$$ = $projection_unitVector$$ : $projection_unitVector$$ > $max$$ && ($max$$ = $projection_unitVector$$);
    return new hamonengine.geometry.interval($min$$, $max$$);
  };
  hamonengine.geometry.lineSegment.prototype.move = function $hamonengine$geometry$lineSegment$$move$($coords$$, $offset$$) {
    $offset$$ = $offset$$ ? $offset$$._offset + ($offset$$.sharesEndPoint(this) ? 2 : 4) : 0;
    $coords$$[$offset$$ + 0] = this.x;
    $coords$$[$offset$$ + 1] = this.y;
    $coords$$[$offset$$ + 2] = this.x2;
    $coords$$[$offset$$ + 3] = this.y2;
    this._coords = $coords$$;
    this._offset = $offset$$;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.lineSegment.prototype, {x:{configurable:!0, enumerable:!0, get:function() {
    return this._coords[this._offset + 0];
  }, set:function($v$$) {
    this._coords[this._offset + 0] = $v$$;
  }}, y:{configurable:!0, enumerable:!0, get:function() {
    return this._coords[this._offset + 1];
  }, set:function($v$$) {
    this._coords[this._offset + 1] = $v$$;
  }}, x2:{configurable:!0, enumerable:!0, get:function() {
    return this._coords[this._offset + 2];
  }, set:function($v$$) {
    this._coords[this._offset + 2] = $v$$;
  }}, y2:{configurable:!0, enumerable:!0, get:function() {
    return this._coords[this._offset + 3];
  }, set:function($v$$) {
    this._coords[this._offset + 3] = $v$$;
  }}, length:{configurable:!0, enumerable:!0, get:function() {
    return this._direction.length;
  }}, center:{configurable:!0, enumerable:!0, get:function() {
    return this._direction.midPoint;
  }}, slope:{configurable:!0, enumerable:!0, get:function() {
    return this._direction.y / this._direction.x;
  }}, normal:{configurable:!0, enumerable:!0, get:function() {
    return this._direction.normal(this.normalOrientation);
  }}, normals:{configurable:!0, enumerable:!0, get:function() {
    return [this.normal];
  }}, normalOrientation:{configurable:!0, enumerable:!0, get:function() {
    return this._normalOrientation;
  }, set:function($v$$) {
    this._normalOrientation = $v$$;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.polyChain = function $hamonengine$geometry$polyChain$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.geometry.polyChain && ($options$$ = {lines:$options$$.lines});
    this._lines = [];
    this._coords = [];
    this._normals = $options$$.normals || [];
    this._dirty = DIRTY_FLAG.ALL;
    if ($options$$.lines && 0 < $options$$.lines.length) {
      for (var $i$$ = 0; $i$$ < $options$$.lines.length; $i$$++) {
        $options$$.lines[$i$$].move(this._coords, 0 < $options$$.lines.length ? $options$$.lines[$i$$ - 1] : null), this._lines.push($options$$.lines[$i$$]);
      }
    }
  };
  hamonengine.geometry.polyChain.prototype.clone = function $hamonengine$geometry$polyChain$$clone$() {
    return new hamonengine.geometry.polyChain({lines:this.lines});
  };
  hamonengine.geometry.polyChain.prototype.toString = function $hamonengine$geometry$polyChain$$toString$() {
    return this.lines.reduce(function($prevLine$$, $currentLine$$) {
      return $prevLine$$.toString() + ", " + $currentLine$$.toString();
    });
  };
  hamonengine.geometry.polyChain.prototype.toVertices = function $hamonengine$geometry$polyChain$$toVertices$() {
    for (var $vertices$$ = [], $i$$ = 0; $i$$ + 1 < this._coords.length; $i$$ += 2) {
      var $nextOffset$$ = ($i$$ + 2) % this._coords.length;
      this._coords[$i$$] === this._coords[$nextOffset$$] && this._coords[$i$$ + 1] === this._coords[$nextOffset$$ + 1] || $vertices$$.push(new hamonengine.math.vector2(this._coords[$i$$], this._coords[$i$$ + 1]));
    }
    return $vertices$$;
  };
  hamonengine.geometry.polyChain.prototype.toPolygon = function $hamonengine$geometry$polyChain$$toPolygon$() {
    return new hamonengine.geometry.polygon({vertices:this.toVertices()});
  };
  hamonengine.geometry.polyChain.prototype.addVertex = function $hamonengine$geometry$polyChain$$addVertex$($x$$, $y$$) {
    var $offset$$ = 2 <= this._coords.length ? this._coords.length - 2 : 0;
    if (this._coords[$offset$$] !== $x$$ || this._coords[$offset$$ + 1] !== $y$$) {
      this._coords.push($x$$), this._coords.push($y$$), this._dirty = DIRTY_FLAG.ALL, 2 < this._coords.length && this.lines.push(new hamonengine.geometry.lineSegment(0, 0, 0, 0, {coords:this._coords, offset:$offset$$}));
    }
  };
  hamonengine.geometry.polyChain.prototype.addLine = function $hamonengine$geometry$polyChain$$addLine$($line$$) {
    var $previousLine$$ = 0 < this.lines.length ? this.lines[this.lines.length - 1] : null;
    if ($previousLine$$ && !$previousLine$$.sharesEndPoint($line$$)) {
      var $bridgingLine$$ = new hamonengine.geometry.lineSegment($previousLine$$.x2, $previousLine$$.y2, $line$$.x, $line$$.y);
      $bridgingLine$$.move(this._coords, $previousLine$$);
      this.lines.push($bridgingLine$$);
      $previousLine$$ = $bridgingLine$$;
    }
    $line$$.move(this._coords, $previousLine$$);
    this.lines.push($line$$);
    this._dirty = DIRTY_FLAG.ALL;
  };
  hamonengine.geometry.polyChain.prototype.translate = function $hamonengine$geometry$polyChain$$translate$($translateVector$$) {
    $translateVector$$ = $translateVector$$ || new hamonengine.math.vector2(0, 0);
    return new hamonengine.geometry.polyChain({lines:this.lines.map(function($line$$) {
      return $line$$.translate($translateVector$$);
    })});
  };
  hamonengine.geometry.polyChain.prototype.rotate = function $hamonengine$geometry$polyChain$$rotate$($theta$$, $offsetVector$$) {
    $theta$$ = $theta$$ || 0.0;
    $offsetVector$$ = $offsetVector$$ || new hamonengine.math.vector2(0, 0);
    var $sinTheta$$ = Math.sin($theta$$), $cosTheta$$ = Math.cos($theta$$);
    return new hamonengine.geometry.polyChain({lines:this.lines.map(function($line$$) {
      return $line$$.rotate($theta$$, $offsetVector$$, {sinTheta:$sinTheta$$, cosTheta:$cosTheta$$});
    })});
  };
  hamonengine.geometry.polyChain.prototype.scale = function $hamonengine$geometry$polyChain$$scale$($scaleVector$$, $offsetVector$$) {
    $scaleVector$$ = $scaleVector$$ || new hamonengine.math.vector2(0, 0);
    $offsetVector$$ = $offsetVector$$ || new hamonengine.math.vector2(0, 0);
    var $xFlipped$$ = 0 > $scaleVector$$.x, $yFlipped$$ = 0 > $scaleVector$$.y;
    return new hamonengine.geometry.polyChain({lines:this.lines.map(function($line$$) {
      return $line$$.scale($scaleVector$$, $offsetVector$$, {xFlipped:$xFlipped$$, yFlipped:$yFlipped$$});
    })});
  };
  hamonengine.geometry.polyChain.prototype.isCollision = function $hamonengine$geometry$polyChain$$isCollision$($shape$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.math.vector2 : $direction$$;
    for (var $correctionMTV$$ = new hamonengine.math.vector2, $i$$ = 0; $i$$ < this.lines.length; $i$$++) {
      var $mtv$$ = $shape$$.isCollision(this.lines[$i$$], $direction$$);
      0 < $mtv$$.length && ($correctionMTV$$ = $correctionMTV$$.add($mtv$$));
    }
    return $correctionMTV$$;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.polyChain.prototype, {lines:{configurable:!0, enumerable:!0, get:function() {
    return this._lines;
  }}, normals:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, DIRTY_FLAG.NORMAL) && (this._normals = this.lines.map(function($line$$) {
      return $line$$.normal;
    }), bitflag.toggle(this._dirty, DIRTY_FLAG.NORMAL, !1));
    return this._normals;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.polygon = function $hamonengine$geometry$polygon$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.geometry.polygon && ($options$$ = {vertices:[].concat($jscomp.arrayFromIterable($options$$.vertices))});
    this._vertices = $options$$.vertices || [];
    this._edges = [];
    this._normals = [];
    this._dimensions = {center:null, max:null, min:null, minVertex:null, maxVertex:null, };
    this._dirty = DIRTY_FLAG.ALL;
    this._shapeType = SHAPE_TYPE.UNKNOWN;
  };
  hamonengine.geometry.polygon.prototype.clone = function $hamonengine$geometry$polygon$$clone$() {
    return new hamonengine.geometry.polygon(this);
  };
  hamonengine.geometry.polygon.prototype.toString = function $hamonengine$geometry$polygon$$toString$() {
    for (var $vertexString$$ = "", $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      $vertexString$$ += ("" !== $vertexString$$ ? "," : "") + this.vertices[$i$$].toString();
    }
    return "[" + $vertexString$$ + "]";
  };
  hamonengine.geometry.polygon.prototype.toRect = function $hamonengine$geometry$polygon$$toRect$() {
    return new hamonengine.geometry.rect(this.min.x, this.min.y, this.max.x - this.min.x, this.max.y - this.min.y);
  };
  hamonengine.geometry.polygon.prototype.addVertex = function $hamonengine$geometry$polygon$$addVertex$($x$$, $y$$) {
    this._vertices.push(new hamonengine.math.vector2($x$$, $y$$));
    this._dirty = DIRTY_FLAG.ALL;
  };
  hamonengine.geometry.polygon.prototype.addLine = function $hamonengine$geometry$polygon$$addLine$($line$$) {
    this._vertices.push.apply(this._vertices, $jscomp.arrayFromIterable($line$$.toVertices()));
    this._dirty = DIRTY_FLAG.ALL;
  };
  hamonengine.geometry.polygon.prototype.reverse = function $hamonengine$geometry$polygon$$reverse$() {
    for (var $newVertices$$ = [], $i$$ = this.vertices.length - 1; 0 <= $i$$; $i$$--) {
      $newVertices$$.push(this.vertices[$i$$]);
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.translate = function $hamonengine$geometry$polygon$$translate$($translateVector$$) {
    $translateVector$$ = $translateVector$$ || new hamonengine.math.vector2(0, 0);
    for (var $newVertices$$ = [], $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      $newVertices$$.push(this.vertices[$i$$].add($translateVector$$));
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.rotate = function $hamonengine$geometry$polygon$$rotate$($cosTheta$jscomp$2_theta$$, $offsetVector$$) {
    $cosTheta$jscomp$2_theta$$ = $cosTheta$jscomp$2_theta$$ || 0.0;
    $offsetVector$$ = $offsetVector$$ || new hamonengine.math.vector2(0, 0);
    var $sinTheta$$ = Math.sin($cosTheta$jscomp$2_theta$$);
    $cosTheta$jscomp$2_theta$$ = Math.cos($cosTheta$jscomp$2_theta$$);
    for (var $newVertices$$ = [], $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      var $xOffset$jscomp$1_y$$ = this.vertices[$i$$].x - $offsetVector$$.x, $yOffset$$ = this.vertices[$i$$].y - $offsetVector$$.y;
      if (hamonengine.geometry.settings.coordinateSystem === COORDINATE_SYSTEM.RHS) {
        var $x$$ = $xOffset$jscomp$1_y$$ * $cosTheta$jscomp$2_theta$$ - $yOffset$$ * $sinTheta$$;
        $xOffset$jscomp$1_y$$ = $xOffset$jscomp$1_y$$ * $sinTheta$$ + $yOffset$$ * $cosTheta$jscomp$2_theta$$;
      } else {
        $x$$ = $xOffset$jscomp$1_y$$ * $cosTheta$jscomp$2_theta$$ + $yOffset$$ * $sinTheta$$, $xOffset$jscomp$1_y$$ = -($xOffset$jscomp$1_y$$ * $sinTheta$$) + $yOffset$$ * $cosTheta$jscomp$2_theta$$;
      }
      $newVertices$$.push(new hamonengine.math.vector2($x$$ + $offsetVector$$.x, $xOffset$jscomp$1_y$$ + $offsetVector$$.y));
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.rotateAtCenter = function $hamonengine$geometry$polygon$$rotateAtCenter$($theta$$) {
    return this.rotate($theta$$, this.center);
  };
  hamonengine.geometry.polygon.prototype.scale = function $hamonengine$geometry$polygon$$scale$($scaleVector$$, $offsetVector$$) {
    $scaleVector$$ = $scaleVector$$ || new hamonengine.math.vector2(0, 0);
    $offsetVector$$ = $offsetVector$$ || new hamonengine.math.vector2(0, 0);
    var $i$5_i$jscomp$35_xFlipped$$ = 0 > $scaleVector$$.x, $yFlipped$$ = 0 > $scaleVector$$.y, $newVertices$$ = [];
    if (!$i$5_i$jscomp$35_xFlipped$$ && $yFlipped$$ || $i$5_i$jscomp$35_xFlipped$$ & !$yFlipped$$) {
      for ($i$5_i$jscomp$35_xFlipped$$ = this.vertices.length - 1; 0 <= $i$5_i$jscomp$35_xFlipped$$; $i$5_i$jscomp$35_xFlipped$$--) {
        $newVertices$$.push(this.vertices[$i$5_i$jscomp$35_xFlipped$$].multiplyVector($scaleVector$$).add($offsetVector$$));
      }
    } else {
      for ($i$5_i$jscomp$35_xFlipped$$ = 0; $i$5_i$jscomp$35_xFlipped$$ < this.vertices.length; $i$5_i$jscomp$35_xFlipped$$++) {
        $newVertices$$.push(this.vertices[$i$5_i$jscomp$35_xFlipped$$].multiplyVector($scaleVector$$).add($offsetVector$$));
      }
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.scaleAtCenter = function $hamonengine$geometry$polygon$$scaleAtCenter$($scaleVector$$) {
    return this.scale($scaleVector$$, this.center.subtract(this.center.multiplyVector($scaleVector$$)));
  };
  hamonengine.geometry.polygon.prototype.mirror = function $hamonengine$geometry$polygon$$mirror$($state$$) {
    return $state$$ ? this.scaleAtCenter(new hamonengine.math.vector2(-1, 1)) : this;
  };
  hamonengine.geometry.polygon.prototype.flip = function $hamonengine$geometry$polygon$$flip$($state$$) {
    return $state$$ ? this.scaleAtCenter(new hamonengine.math.vector2(1, -1)) : this;
  };
  hamonengine.geometry.polygon.prototype.isCollision = function $hamonengine$geometry$polygon$$isCollision$($shape$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.math.vector2 : $direction$$;
    return $shape$$ instanceof hamonengine.geometry.rect ? $shape$$.toPolygon().isCollisionPolygon(this, $direction$$) : $shape$$ instanceof hamonengine.geometry.polygon ? this.isCollisionPolygon($shape$$, $direction$$) : $shape$$ instanceof hamonengine.geometry.lineSegment || $shape$$ instanceof hamonengine.geometry.polyChain ? $shape$$.isCollision(this, $direction$$) : new hamonengine.math.vector2(0, 0);
  };
  hamonengine.geometry.polygon.prototype.isCollisionPolygon = function $hamonengine$geometry$polygon$$isCollisionPolygon$($mtv$jscomp$1_polygon$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.math.vector2 : $direction$$;
    if (!($mtv$jscomp$1_polygon$$ instanceof hamonengine.geometry.polygon)) {
      throw "Parameter polygon is not of type hamonengine.geometry.polygon.";
    }
    for (var $mnimumOverlappingLength$$ = NaN, $mtvAxis$$, $axes$$ = $mtv$jscomp$1_polygon$$.normals, $i$6_i$$ = 0; $i$6_i$$ < $axes$$.length; $i$6_i$$++) {
      var $thisProjection$7_thisProjection$$ = this.project($axes$$[$i$6_i$$]), $otherProjection$8_otherProjection$$ = $mtv$jscomp$1_polygon$$.project($axes$$[$i$6_i$$]), $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$ = $thisProjection$7_thisProjection$$.overlap($otherProjection$8_otherProjection$$);
      if (!$overlapping_overlapping$9_overlappingLength_overlappingLength$10$$.isLine) {
        return new hamonengine.math.vector2;
      }
      $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$ = $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$.length;
      if ($thisProjection$7_thisProjection$$.contains($otherProjection$8_otherProjection$$) || $otherProjection$8_otherProjection$$.contains($thisProjection$7_thisProjection$$)) {
        $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$ += $thisProjection$7_thisProjection$$.getMinimumDistance($otherProjection$8_otherProjection$$);
      }
      if (isNaN($mnimumOverlappingLength$$) || $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$ < $mnimumOverlappingLength$$) {
        $mnimumOverlappingLength$$ = $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$, $mtvAxis$$ = $axes$$[$i$6_i$$];
      }
    }
    $axes$$ = this.normals;
    for ($i$6_i$$ = 0; $i$6_i$$ < $axes$$.length; $i$6_i$$++) {
      $thisProjection$7_thisProjection$$ = this.project($axes$$[$i$6_i$$]);
      $otherProjection$8_otherProjection$$ = $mtv$jscomp$1_polygon$$.project($axes$$[$i$6_i$$]);
      $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$ = $thisProjection$7_thisProjection$$.overlap($otherProjection$8_otherProjection$$);
      if (!$overlapping_overlapping$9_overlappingLength_overlappingLength$10$$.isLine) {
        return new hamonengine.math.vector2;
      }
      $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$ = $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$.length;
      if ($thisProjection$7_thisProjection$$.contains($otherProjection$8_otherProjection$$) || $otherProjection$8_otherProjection$$.contains($thisProjection$7_thisProjection$$)) {
        $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$ += $thisProjection$7_thisProjection$$.getMinimumDistance($otherProjection$8_otherProjection$$);
      }
      if (isNaN($mnimumOverlappingLength$$) || $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$ < $mnimumOverlappingLength$$) {
        $mnimumOverlappingLength$$ = $overlapping_overlapping$9_overlappingLength_overlappingLength$10$$, $mtvAxis$$ = $axes$$[$i$6_i$$];
      }
    }
    $mnimumOverlappingLength$$ = $mnimumOverlappingLength$$ < hamonengine.geometry.settings.collisionDetection.floor ? 0.0 : $mnimumOverlappingLength$$;
    $mtv$jscomp$1_polygon$$ = $mtvAxis$$.multiply($mnimumOverlappingLength$$);
    0 <= $mtv$jscomp$1_polygon$$.dot($direction$$) && ($mtv$jscomp$1_polygon$$ = $mtv$jscomp$1_polygon$$.invert());
    return $mtv$jscomp$1_polygon$$;
  };
  hamonengine.geometry.polygon.prototype.isContained = function $hamonengine$geometry$polygon$$isContained$($shape$$) {
    return new hamonengine.math.vector2;
  };
  hamonengine.geometry.polygon.prototype.project = function $hamonengine$geometry$polygon$$project$($unitVector$$) {
    var $min$$ = 0, $max$$ = 0;
    if (0 < this.vertices.length) {
      $max$$ = $min$$ = $unitVector$$.dot(this.vertices[0]);
      for (var $i$$ = 1; $i$$ < this.vertices.length; $i$$++) {
        var $projection$$ = $unitVector$$.dot(this.vertices[$i$$]);
        $projection$$ < $min$$ ? $min$$ = $projection$$ : $projection$$ > $max$$ && ($max$$ = $projection$$);
      }
    }
    return new hamonengine.geometry.interval($min$$, $max$$);
  };
  hamonengine.geometry.polygon.calcEdges = function $hamonengine$geometry$polygon$calcEdges$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $edges$$ = [], $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      $edges$$.push($vertices$$[($i$$ + 1) % $vertices$$.length].subtract($vertices$$[$i$$]));
    }
    return $edges$$;
  };
  hamonengine.geometry.polygon.calcNormals = function $hamonengine$geometry$polygon$calcNormals$($edges$$) {
    $edges$$ = void 0 === $edges$$ ? [] : $edges$$;
    return $edges$$.map(function($edge$$) {
      return $edge$$.normal(ROTATION_TYPE.CW);
    });
  };
  hamonengine.geometry.polygon.calcDimensions = function $hamonengine$geometry$polygon$calcDimensions$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $minVertex$$ = null, $maxVertex$$ = null, $xMax$$ = NaN, $xMin$$ = NaN, $yMax$$ = NaN, $yMin$$ = NaN, $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      $xMax$$ = $xMax$$ > $vertices$$[$i$$].x ? $xMax$$ : $vertices$$[$i$$].x;
      $xMin$$ = $xMin$$ < $vertices$$[$i$$].x ? $xMin$$ : $vertices$$[$i$$].x;
      $yMax$$ = $yMax$$ > $vertices$$[$i$$].y ? $yMax$$ : $vertices$$[$i$$].y;
      $yMin$$ = $yMin$$ < $vertices$$[$i$$].y ? $yMin$$ : $vertices$$[$i$$].y;
      if (null === $minVertex$$ || $minVertex$$.x > $vertices$$[$i$$].x && $minVertex$$.y > $vertices$$[$i$$].y) {
        $minVertex$$ = $vertices$$[$i$$];
      }
      if (null === $maxVertex$$ || $maxVertex$$.x < $vertices$$[$i$$].x && $maxVertex$$.y < $vertices$$[$i$$].y) {
        $maxVertex$$ = $vertices$$[$i$$];
      }
    }
    return {max:new hamonengine.math.vector2($xMax$$, $yMax$$), min:new hamonengine.math.vector2($xMin$$, $yMin$$), center:new hamonengine.math.vector2($xMin$$ + ($xMax$$ - $xMin$$) / 2, $yMin$$ + ($yMax$$ - $yMin$$) / 2), minVertex:$minVertex$$, maxVertex:$maxVertex$$};
  };
  hamonengine.geometry.polygon.calcShapeType = function $hamonengine$geometry$polygon$calcShapeType$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $signCounter$$ = 0, $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      var $p2_v2$$ = $vertices$$[($i$$ + 1) % $vertices$$.length], $p3$$ = $vertices$$[($i$$ + 2) % $vertices$$.length], $v1$$ = $p2_v2$$.subtract($vertices$$[$i$$]);
      $p2_v2$$ = $p3$$.subtract($p2_v2$$);
      $signCounter$$ += 0 < $p2_v2$$.cross($v1$$).z ? 1 : -1;
    }
    return $vertices$$.length === $signCounter$$ ? SHAPE_TYPE.CONVEX : SHAPE_TYPE.CONCAVE;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.polygon.prototype, {vertices:{configurable:!0, enumerable:!0, get:function() {
    return this._vertices;
  }}, edges:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, DIRTY_FLAG.EDGE) && (this._edges = hamonengine.geometry.polygon.calcEdges(this.vertices), this._dirty = bitflag.toggle(this._dirty, DIRTY_FLAG.EDGE, !1));
    return this._edges;
  }}, normals:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, DIRTY_FLAG.NORMAL) && (this._normals = hamonengine.geometry.polygon.calcNormals(this.edges), this._dirty = bitflag.toggle(this._dirty, DIRTY_FLAG.NORMAL, !1));
    return this._normals;
  }}, center:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, DIRTY_FLAG.DIMS) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), this._dirty = bitflag.toggle(this._dirty, DIRTY_FLAG.DIMS, !1));
    return this._dimensions.center;
  }}, max:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, DIRTY_FLAG.DIMS) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), this._dirty = bitflag.toggle(this._dirty, DIRTY_FLAG.DIMS, !1));
    return this._dimensions.max;
  }}, min:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, DIRTY_FLAG.DIMS) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), this._dirty = bitflag.toggle(this._dirty, DIRTY_FLAG.DIMS, !1));
    return this._dimensions.min;
  }}, minVertex:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, DIRTY_FLAG.DIMS) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), this._dirty = bitflag.toggle(this._dirty, DIRTY_FLAG.DIMS, !1));
    return this._dimensions.minVertex;
  }}, maxVertex:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, DIRTY_FLAG.DIMS) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), this._dirty = bitflag.toggle(this._dirty, DIRTY_FLAG.DIMS, !1));
    return this._dimensions.maxVertex;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this.max.x - this.min.x;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this.max.y - this.min.y;
  }}, shapeType:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, DIRTY_FLAG.SHAPE) && (this._shapeType = hamonengine.geometry.polygon.calcShapeType(this.vertices), this._dirty = bitflag.toggle(this._dirty, DIRTY_FLAG.SHAPE, !1));
    return this._shapeType;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.rect = function $hamonengine$geometry$rect$($x$$, $y$$, $width$$, $height$$) {
    this.x = void 0 === $x$$ ? 0 : $x$$;
    this.y = void 0 === $y$$ ? 0 : $y$$;
    this.width = void 0 === $width$$ ? 0 : $width$$;
    this.height = void 0 === $height$$ ? 0 : $height$$;
  };
  hamonengine.geometry.rect.prototype.clone = function $hamonengine$geometry$rect$$clone$() {
    return new hamonengine.geometry.rect(this.x, this.y, this.width, this.height);
  };
  hamonengine.geometry.rect.prototype.toString = function $hamonengine$geometry$rect$$toString$() {
    return "{x: " + this.x + ", y: " + this.y + ", width: " + this.width + ", height: " + this.height + "}";
  };
  hamonengine.geometry.rect.prototype.toPolygon = function $hamonengine$geometry$rect$$toPolygon$() {
    return new hamonengine.geometry.polygon({vertices:[new hamonengine.math.vector2(this.x, this.y), new hamonengine.math.vector2(this.x + this.width, this.y), new hamonengine.math.vector2(this.x + this.width, this.y + this.height), new hamonengine.math.vector2(this.x, this.y + this.height)]});
  };
  hamonengine.geometry.rect.prototype.translate = function $hamonengine$geometry$rect$$translate$($translateVector$$) {
    $translateVector$$ = $translateVector$$ || new hamonengine.math.vector2(0, 0);
    return new hamonengine.geometry.rect(this.x + $translateVector$$.x, this.y + $translateVector$$.y, this.width, this.height);
  };
  hamonengine.geometry.rect.prototype.isCollision = function $hamonengine$geometry$rect$$isCollision$($shape$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.math.vector2 : $direction$$;
    return $shape$$ instanceof hamonengine.geometry.rect ? this.isCollisionRect($shape$$, $direction$$) : $shape$$ instanceof hamonengine.geometry.polygon ? $shape$$.isCollision(this, $direction$$) : $shape$$ instanceof hamonengine.math.vector2 ? this.isCollisionPoint($shape$$) : $shape$$ instanceof hamonengine.geometry.lineSegment || $shape$$ instanceof hamonengine.geometry.polyChain ? $shape$$.isCollision(this, $direction$$) : new hamonengine.math.vector2(0, 0);
  };
  hamonengine.geometry.rect.prototype.isCollisionRect = function $hamonengine$geometry$rect$$isCollisionRect$($otherRect_other_XAxisProjection$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.math.vector2 : $direction$$;
    $otherRect_other_XAxisProjection$$ instanceof hamonengine.geometry.rect || console.warn("[hamonengine.geometry.rect.isCollision] The otherRect parameter is not of type hamonengine.geometry.rect!");
    var $mnimumOverlappingLength$jscomp$1_mtv$$ = NaN, $this_XAxisProjection_this_YAxisProjection$$ = new hamonengine.geometry.interval(this.y, this.y + this.height), $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ = new hamonengine.geometry.interval($otherRect_other_XAxisProjection$$.y, $otherRect_other_XAxisProjection$$.y + $otherRect_other_XAxisProjection$$.height), $overlappingYAxis_overlappingYAxisLength$$ = $this_XAxisProjection_this_YAxisProjection$$.overlap($other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$);
    if (!$overlappingYAxis_overlappingYAxisLength$$.isLine) {
      return new hamonengine.math.vector2;
    }
    $overlappingYAxis_overlappingYAxisLength$$ = $overlappingYAxis_overlappingYAxisLength$$.length;
    if ($this_XAxisProjection_this_YAxisProjection$$.contains($other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$) || $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.contains($this_XAxisProjection_this_YAxisProjection$$)) {
      $overlappingYAxis_overlappingYAxisLength$$ += $this_XAxisProjection_this_YAxisProjection$$.getMinimumDistance($other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$);
    }
    if (isNaN($mnimumOverlappingLength$jscomp$1_mtv$$) || $overlappingYAxis_overlappingYAxisLength$$ < $mnimumOverlappingLength$jscomp$1_mtv$$) {
      $mnimumOverlappingLength$jscomp$1_mtv$$ = $overlappingYAxis_overlappingYAxisLength$$;
      var $mtvAxis$$ = hamonengine.math.vector2.Y_AXIS_NORMAL;
    }
    $this_XAxisProjection_this_YAxisProjection$$ = new hamonengine.geometry.interval(this.x, this.x + this.width);
    $otherRect_other_XAxisProjection$$ = new hamonengine.geometry.interval($otherRect_other_XAxisProjection$$.x, $otherRect_other_XAxisProjection$$.x + $otherRect_other_XAxisProjection$$.width);
    $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ = $this_XAxisProjection_this_YAxisProjection$$.overlap($otherRect_other_XAxisProjection$$);
    if (!$other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.isLine) {
      return new hamonengine.math.vector2;
    }
    $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ = $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.length;
    if ($this_XAxisProjection_this_YAxisProjection$$.contains($otherRect_other_XAxisProjection$$) || $otherRect_other_XAxisProjection$$.contains($this_XAxisProjection_this_YAxisProjection$$)) {
      $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ += $this_XAxisProjection_this_YAxisProjection$$.getMinimumDistance($otherRect_other_XAxisProjection$$);
    }
    if (isNaN($mnimumOverlappingLength$jscomp$1_mtv$$) || $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ < $mnimumOverlappingLength$jscomp$1_mtv$$) {
      $mnimumOverlappingLength$jscomp$1_mtv$$ = $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$, $mtvAxis$$ = hamonengine.math.vector2.X_AXIS_NORMAL;
    }
    $mnimumOverlappingLength$jscomp$1_mtv$$ = $mnimumOverlappingLength$jscomp$1_mtv$$ < hamonengine.geometry.settings.collisionDetection.floor ? 0.0 : $mnimumOverlappingLength$jscomp$1_mtv$$;
    $mnimumOverlappingLength$jscomp$1_mtv$$ = $mtvAxis$$.multiply($mnimumOverlappingLength$jscomp$1_mtv$$);
    0 <= $mnimumOverlappingLength$jscomp$1_mtv$$.dot($direction$$) && ($mnimumOverlappingLength$jscomp$1_mtv$$ = $mnimumOverlappingLength$jscomp$1_mtv$$.invert());
    return $mnimumOverlappingLength$jscomp$1_mtv$$;
  };
  hamonengine.geometry.rect.prototype.isCollisionPoint = function $hamonengine$geometry$rect$$isCollisionPoint$($minY2_point$$) {
    var $outsideDirection$$ = new hamonengine.math.vector2;
    if ($minY2_point$$.x >= this.x && $minY2_point$$.x <= this.right && $minY2_point$$.y >= this.y && $minY2_point$$.y <= this.bottom) {
      var $minX_minY$$ = $minY2_point$$.x - this.x, $minX2$$ = this.right - $minY2_point$$.x;
      $outsideDirection$$.x = $minX_minY$$ < $minX2$$ ? $minX_minY$$ : $minX2$$;
      $minX_minY$$ = $minY2_point$$.y - this.y;
      $minY2_point$$ = this.bottom - $minY2_point$$.y;
      $outsideDirection$$.y = $minX_minY$$ < $minY2_point$$ ? $minX_minY$$ : $minY2_point$$;
    }
    return $outsideDirection$$;
  };
  hamonengine.geometry.rect.prototype.isContained = function $hamonengine$geometry$rect$$isContained$($position$$, $rect$$) {
    $rect$$ instanceof hamonengine.geometry.rect || console.warn("[hamonengine.geometry.rect.isContained] The rect parameter is not of type hamonengine.geometry.rect!");
    var $outsideDirection$$ = new hamonengine.math.vector2, $xOffset$$ = $position$$.x + $rect$$.x, $yOffset$$ = $position$$.y + $rect$$.y;
    $xOffset$$ < this.x ? (hamonengine.debug && console.debug("[hamonengine.geometry.rect.isContained] Outside -x: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.x = -1) : $position$$.x + $rect$$.right > this.right && (hamonengine.debug && console.debug("[hamonengine.geometry.rect.isContained] Outside +x: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.x = 1);
    $yOffset$$ < this.y ? (hamonengine.debug && console.debug("[hamonengine.geometry.rect.isContained] Outside -y: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.y = -1) : $position$$.y + $rect$$.bottom > this.bottom && (hamonengine.debug && console.debug("[hamonengine.geometry.rect.isContained] Outside +y: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.y = 1);
    return $outsideDirection$$;
  };
  hamonengine.geometry.rect.prototype.project = function $hamonengine$geometry$rect$$project$($unitVector$$) {
    var $min$$ = max = $unitVector$$.dot(new hamonengine.math.vector2(this.x, this.y)), $calcProjections$$ = function $$calcProjections$$$($dotProduct_vector$$) {
      $dotProduct_vector$$ = $unitVector$$.dot($dotProduct_vector$$);
      $dotProduct_vector$$ < $min$$ ? $min$$ = $dotProduct_vector$$ : $dotProduct_vector$$ > max && (max = $dotProduct_vector$$);
    };
    $calcProjections$$(new hamonengine.math.vector2(this.x + this.width, this.y));
    $calcProjections$$(new hamonengine.math.vector2(this.x + this.width, this.y + this.height));
    $calcProjections$$(new hamonengine.math.vector2(this.x, this.y + this.height));
    return new hamonengine.geometry.interval($min$$, max);
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.rect.prototype, {right:{configurable:!0, enumerable:!0, get:function() {
    return this.x + this.width;
  }}, bottom:{configurable:!0, enumerable:!0, get:function() {
    return this.y + this.height;
  }}});
})();
var COORDINATE_SYSTEM = {LHS:0, RHS:1}, COLLISION_TYPES = {NONE:0, EDGE:1, INSIDE:2}, SHAPE_TYPE = {UNKNOWN:0, CONVEX:1, CONCAVE:2};
hamonengine.geometry = hamonengine.geometry || {};
hamonengine.geometry.settings = hamonengine.geometry.settings || {collisionDetection:{floor:0.01, limit:15}, coordinateSystem:COORDINATE_SYSTEM.RHS};
hamonengine.graphics = hamonengine.graphics || {};
var BLENDING_OPS = {REPLACE:0, ADD:1, MULTIPLY:2, OR:3, AND:4, XOR:5, DIFFERENCE:6}, TEXT_DRAW_TYPE = {STROKE:0, FILL:1}, DIRTY_FLAG = {NORMAL:0, DIMS:1, EDGE:2, SHAPE:3, ALL:15};
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.imageext = function $hamonengine$graphics$imageext$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.graphics.imageext && ($options$$ = {image:$options$$._image, });
    this._image = $options$$.image || new Image;
    this._state = 0;
    this._backbufferCtx = this._backbufferResource = null;
    hamonengine.debug && hamonengine.verbose && console.debug("[hamonengine.graphics.imageext.constructor] Starting State: {" + this._state + "}");
  };
  hamonengine.graphics.imageext.prototype.clone = function $hamonengine$graphics$imageext$$clone$() {
    return new hamonengine.graphics.imageext(this);
  };
  hamonengine.graphics.imageext.prototype.load = function $hamonengine$graphics$imageext$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      "" !== $src$$ && ($$jscomp$async$this$$._image.src = $src$$);
      $$jscomp$async$this$$._state = 1;
      return $$jscomp$generator$context$$.return(new Promise(function($resolve$$, $reject$$) {
        $$jscomp$async$this$$.complete ? ($$jscomp$async$this$$._state = 2, $resolve$$()) : ($$jscomp$async$this$$.image.addEventListener("load", function() {
          $$jscomp$async$this$$._state = 2;
          hamonengine.debug && console.debug("[hamonengine.graphics.imageext.load] Image '" + $src$$ + "' has loaded successfully.");
          $resolve$$();
        }, !1), $$jscomp$async$this$$.image.addEventListener("error", function($error$$) {
          $$jscomp$async$this$$._state = 3;
          $reject$$("The image '" + ($error$$ && $error$$.path && 0 < $error$$.path.length && $error$$.path[0].src || "") + "' could not be loaded.");
        }, !1));
      }));
    });
  };
  hamonengine.graphics.imageext.prototype.getImageData = function $hamonengine$graphics$imageext$$getImageData$($region$$) {
    this._backbufferResource = this._backbufferResource || hamonengine.graphics.layer.createNewCanvas(this.rawImage.width, this.rawImage.height);
    this._backbufferCtx = this._backbufferCtx || this._backbufferResource.getContext("2d");
    this._backbufferCtx.drawImage(this.rawImage, 0, 0);
    $region$$ = $region$$ || new hamonengine.geometry.rect;
    return this._backbufferCtx.getImageData($region$$.x, $region$$.y, $region$$.width || this.rawImage.width, $region$$.height || this.rawImage.height);
  };
  hamonengine.graphics.imageext.prototype.blendColorRegion = function $hamonengine$graphics$imageext$$blendColorRegion$($r$$, $g$$, $b$$, $a$$, $region$$, $blendingOps_data$$) {
    $r$$ = void 0 === $r$$ ? 0 : $r$$;
    $g$$ = void 0 === $g$$ ? 0 : $g$$;
    $b$$ = void 0 === $b$$ ? 0 : $b$$;
    $a$$ = void 0 === $a$$ ? 0 : $a$$;
    $region$$ = void 0 === $region$$ ? null : $region$$;
    $blendingOps_data$$ = void 0 === $blendingOps_data$$ ? BLENDING_OPS.REPLACE : $blendingOps_data$$;
    if (this.complete) {
      var $sourceData$$ = this.getImageData($region$$), $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
        return 0 < $s$$ ? $s$$ : $d$$;
      };
      switch($blendingOps_data$$) {
        case BLENDING_OPS.ADD:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ + $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.MULTIPLY:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ * $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.AND:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ & $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.OR:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ | $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.XOR:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ ^ $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.DIFFERENCE:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ - $d$$, 255) : $d$$;
          };
      }
      $blendingOps_data$$ = $sourceData$$.data;
      for (var $i$$ = 0; $i$$ < $blendingOps_data$$.length; $i$$ += 4) {
        $blendingOps_data$$[$i$$] = $blendingMethod$$($r$$, $blendingOps_data$$[$i$$]), $blendingOps_data$$[$i$$ + 1] = $blendingMethod$$($g$$, $blendingOps_data$$[$i$$ + 1]), $blendingOps_data$$[$i$$ + 2] = $blendingMethod$$($b$$, $blendingOps_data$$[$i$$ + 2]), $blendingOps_data$$[$i$$ + 3] = $blendingMethod$$($a$$, $blendingOps_data$$[$i$$ + 3]);
      }
      this._backbufferCtx.putImageData($sourceData$$, $region$$.x, $region$$.y);
    }
  };
  hamonengine.graphics.imageext.prototype.adjustColorChannel = function $hamonengine$graphics$imageext$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$, $region$$) {
    $r$$ = void 0 === $r$$ ? 1.0 : $r$$;
    $g$$ = void 0 === $g$$ ? 1.0 : $g$$;
    $b$$ = void 0 === $b$$ ? 1.0 : $b$$;
    $a$$ = void 0 === $a$$ ? 1.0 : $a$$;
    $region$$ = void 0 === $region$$ ? null : $region$$;
    if (this.complete) {
      for (var $sourceData$$ = this.getImageData($region$$), $data$$ = $sourceData$$.data, $i$$ = 0; $i$$ < $data$$.length; $i$$ += 4) {
        $data$$[$i$$] = Math.bitRound($data$$[$i$$] * $r$$), $data$$[$i$$ + 1] = Math.bitRound($data$$[$i$$ + 1] * $g$$), $data$$[$i$$ + 2] = Math.bitRound($data$$[$i$$ + 2] * $b$$), $data$$[$i$$ + 3] = Math.bitRound($data$$[$i$$ + 3] * $a$$);
      }
      this._backbufferCtx.putImageData($sourceData$$, $region$$.x, $region$$.y, $region$$.x, $region$$.y, $region$$.width, $region$$.height);
    }
  };
  hamonengine.graphics.imageext.prototype.bitblit = function $hamonengine$graphics$imageext$$bitblit$($destData_imageData$$, $srcRegion$$, $destRegion$$, $transparency$$) {
    if (this.complete && $destData_imageData$$.complete) {
      $destData_imageData$$ instanceof hamonengine.graphics.imageext && ($destData_imageData$$ = $destData_imageData$$.rawImage);
      $transparency$$ = Math.max(Math.min(void 0 === $transparency$$ ? 1.0 : $transparency$$, 1.0), 0.0);
      var $destImageData$$ = this.getImageData($destRegion$$), $srcData$$ = hamonengine.graphics.layer.createNewCanvas($destData_imageData$$.width, $destData_imageData$$.height).getContext("2d");
      $srcData$$.drawImage($destData_imageData$$, 0, 0);
      $srcData$$ = $srcData$$.getImageData($srcRegion$$.x, $srcRegion$$.y, $srcRegion$$.width, $srcRegion$$.height);
      $destData_imageData$$ = $destImageData$$.data;
      $srcData$$ = $srcData$$.data;
      for (var $row$$ = 0; $row$$ < $destRegion$$.height && !($row$$ >= $srcRegion$$.height); $row$$++) {
        for (var $col$$ = 0; $col$$ < $destRegion$$.width && !($col$$ >= $srcRegion$$.width); $col$$++) {
          var $destIndex$$ = 4 * ($row$$ * $destRegion$$.width + $col$$), $srcIndex$$ = 4 * ($row$$ * $srcRegion$$.width + $col$$), $transparencyComplement$$ = 0 < $srcData$$[$srcIndex$$ + 3] ? 1.0 - $transparency$$ : 1.0;
          $destData_imageData$$[$destIndex$$] = Math.bitRound($destData_imageData$$[$destIndex$$] * $transparencyComplement$$ + $srcData$$[$srcIndex$$] * $transparency$$);
          $destData_imageData$$[$destIndex$$ + 1] = Math.bitRound($destData_imageData$$[$destIndex$$ + 1] * $transparencyComplement$$ + $srcData$$[$srcIndex$$ + 1] * $transparency$$);
          $destData_imageData$$[$destIndex$$ + 2] = Math.bitRound($destData_imageData$$[$destIndex$$ + 2] * $transparencyComplement$$ + $srcData$$[$srcIndex$$ + 2] * $transparency$$);
        }
      }
      this._backbufferCtx.putImageData($destImageData$$, $destRegion$$.x, $destRegion$$.y);
    }
  };
  hamonengine.graphics.imageext.prototype.draw = function $hamonengine$graphics$imageext$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this.width : $width$$;
    $height$$ = void 0 === $height$$ ? this.height : $height$$;
    $layer$$.drawImage(this, $x$$, $y$$, this.width, this.height, destinationX, destinationY, $width$$, $height$$);
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.imageext.prototype, {src:{configurable:!0, enumerable:!0, get:function() {
    return this._image.src;
  }}, complete:{configurable:!0, enumerable:!0, get:function() {
    return this._image.complete;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return 2 === this._state;
  }}, image:{configurable:!0, enumerable:!0, get:function() {
    return this._backbufferResource ? this._backbufferResource : this._image;
  }}, rawImage:{configurable:!0, enumerable:!0, get:function() {
    return this._image;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this.image.width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this.image.height;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.layer = function $hamonengine$graphics$layer$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._canvasId = $options$$.canvasId || "";
    this._name = $options$$.name || "";
    this._alpha = void 0 !== $options$$.alpha ? $options$$.alpha : !1;
    this._backgroundColor = $options$$.backgroundColor || "black";
    this._allowEventBinding = void 0 !== $options$$.allowEventBinding ? $options$$.allowEventBinding : !1;
    this._wrapVertical = void 0 !== $options$$.wrapVertical ? $options$$.wrapVertical : !1;
    this._wrapHorizontal = void 0 !== $options$$.wrapHorizontal ? $options$$.wrapHorizontal : !1;
    this._clipToViewPort = void 0 !== $options$$.clipToViewPort ? $options$$.clipToViewPort : !0;
    this._enableImageSmoothing = void 0 !== $options$$.enableImageSmoothing ? $options$$.enableImageSmoothing : !0;
    this._invertYAxis = void 0 !== $options$$.invertYAxis ? $options$$.invertYAxis : !1;
    this._invertXAxis = void 0 !== $options$$.invertXAxis ? $options$$.invertXAxis : !1;
    var $canvas$$ = $options$$.canvas;
    if (!this._canvasId && !$canvas$$) {
      throw console.error("[hamonengine.graphics.layer.constructor] Invalid canvasId '" + this._canvasId + "' or canvas. Unable to create the layer!"), "Cannot create the layer";
    }
    $canvas$$ ? (this._canvas = $canvas$$, this._canvasId = $canvas$$.id, this._name = $options$$.name || $canvas$$.getAttribute("name")) : this._canvas = document.getElementById(this._canvasId);
    if (!this._canvas) {
      throw console.error("[hamonengine.graphics.layer.constructor] Invalid canvas: '" + this._canvasId + "' unable to create the layer!"), "Cannot create the layer";
    }
    try {
      this._alpha ? this._canvasContext = this._canvas.getContext("2d", {alpha:this._alpha}) : (this._workAround = !0, this._canvasContext = this._canvas.getContext("2d"));
    } catch ($err$$) {
    }
    this.enableImageSmoothing($options$$.enableImageSmoothing);
    if (!this._canvasContext) {
      throw console.error("[hamonengine.graphics.layer.constructor] Unable to get the 2d context: '" + this._canvasId + "' unable to create the layer!"), "Cannot create the layer";
    }
    this._viewPort = $options$$.viewPort || new hamonengine.geometry.rect(0, 0, this._canvas.width, this._canvas.height);
    this._wasReset = !1;
    this._allowSaveStateEnabled = !0;
    this._viewPortBorderColor = "";
    hamonengine.debug && (console.debug("[hamonengine.graphics.layer.constructor] Canvas Id: " + this._canvasId), console.debug("[hamonengine.graphics.layer.constructor] Name: " + this._name), console.debug("[hamonengine.graphics.layer.constructor] Alpha: " + this._alpha), console.debug("[hamonengine.graphics.layer.constructor] AllowEventBinding: " + this._allowEventBinding), console.debug("[hamonengine.graphics.layer.constructor] WrapVertical: " + this._wrapVertical), console.debug("[hamonengine.graphics.layer.constructor] WrapHorizontal: " + 
    this._wrapHorizontal), console.debug("[hamonengine.graphics.layer.constructor] ClipToViewPort: " + this._clipToViewPort));
  };
  hamonengine.graphics.layer.createNewCanvas = function $hamonengine$graphics$layer$createNewCanvas$($width$$, $height$$, $id$$, $name$$) {
    $id$$ = void 0 === $id$$ ? "" : $id$$;
    $name$$ = void 0 === $name$$ ? "" : $name$$;
    var $canvas$$ = document.createElement("canvas");
    $canvas$$.setAttribute("width", $width$$);
    $canvas$$.setAttribute("height", $height$$);
    $id$$ && $canvas$$.setAttribute("id", $id$$);
    $name$$ && $canvas$$.setAttribute("name", $name$$);
    return $canvas$$;
  };
  hamonengine.graphics.layer.prototype.clone = function $hamonengine$graphics$layer$$clone$($canvasId_newLayer$$, $name$$, $elementToAttach$$) {
    $elementToAttach$$ = void 0 === $elementToAttach$$ ? null : $elementToAttach$$;
    var $newCanvas$$ = hamonengine.graphics.layer.createNewCanvas(this.width, this.height, $canvasId_newLayer$$, $name$$);
    $elementToAttach$$ && $elementToAttach$$.insertBefore($newCanvas$$, null);
    $canvasId_newLayer$$ = new hamonengine.graphics.layer({canvasId:$canvasId_newLayer$$, name:$name$$, canvas:$newCanvas$$, alpha:this.alpha, allowEventBinding:this.allowEventBinding, wrapVertical:this.wrapVertical, wrapHorizontal:this.wrapHorizontal, clipToViewPort:this.clipToViewPort, enableImageSmoothing:this._enableImageSmoothing, invertYAxis:this.invertYAxis, invertXAxis:this.invertXAxis, viewPort:this.viewPort});
    $canvasId_newLayer$$._allowSaveStateEnabled = this._allowSaveStateEnabled;
    $canvasId_newLayer$$._viewPortBorderColor = this._viewPortBorderColor;
    return $canvasId_newLayer$$;
  };
  hamonengine.graphics.layer.prototype.enableImageSmoothing = function $hamonengine$graphics$layer$$enableImageSmoothing$($enable$$) {
    $enable$$ = void 0 === $enable$$ ? !0 : $enable$$;
    hamonengine.debug && console.debug("[hamonengine.graphics.layer.constructor] EnableImageSmoothing: " + $enable$$);
    this._enableImageSmoothing = $enable$$;
    try {
      this.context.webkitImageSmoothingEnabled = $enable$$, this.context.mozImageSmoothingEnabled = $enable$$, this.context.imageSmoothingEnabled = $enable$$;
    } catch ($err$$) {
    }
  };
  hamonengine.graphics.layer.prototype.clear = function $hamonengine$graphics$layer$$clear$($x$$, $y$$, $width$$, $height$$) {
    $x$$ = void 0 === $x$$ ? this.viewPort.x : $x$$;
    $y$$ = void 0 === $y$$ ? this.viewPort.y : $y$$;
    $width$$ = void 0 === $width$$ ? this.viewPort.width : $width$$;
    $height$$ = void 0 === $height$$ ? this.viewPort.height : $height$$;
    this._wasReset = !1;
    this.context.clearRect($x$$, $y$$, $width$$, $height$$);
    if (this._workAround) {
      var $originalFillStyle$$ = this.context.fillStyle;
      this.context.fillStyle = this._backgroundColor;
      this.context.fillRect($x$$, $y$$, $width$$, $height$$);
      this.context.fillStyle = $originalFillStyle$$;
    }
  };
  hamonengine.graphics.layer.prototype.reset = function $hamonengine$graphics$layer$$reset$() {
    this._wasReset || (this.context.resetTransform(), this._wasReset = !0);
  };
  hamonengine.graphics.layer.prototype.save = function $hamonengine$graphics$layer$$save$() {
    this.allowSaveState && this.context.save();
  };
  hamonengine.graphics.layer.prototype.restore = function $hamonengine$graphics$layer$$restore$() {
    this.allowSaveState && this.context.restore();
  };
  hamonengine.graphics.layer.prototype.fillLayerImage = function $hamonengine$graphics$layer$$fillLayerImage$($image$$, $x$$, $y$$) {
    $x$$ = void 0 === $x$$ ? this.viewPort.x : $x$$;
    $y$$ = void 0 === $y$$ ? this.viewPort.y : $y$$;
    this.context.drawImage($image$$, $x$$, $y$$, this.viewPort.width, this.viewPort.height);
  };
  hamonengine.graphics.layer.prototype.beginPainting = function $hamonengine$graphics$layer$$beginPainting$() {
    this.clear();
    this.borderColor && (this.context.strokeStyle = this.borderColor, this.context.strokeRect(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height));
    !this.clipToViewPort || 0 === this.viewPort.x && 0 === this.viewPort.y && this.viewPort.width === this.width && this.viewPort.height === this.height || (this.context.beginPath(), this.context.rect(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height), this.context.clip());
  };
  hamonengine.graphics.layer.prototype.endPainting = function $hamonengine$graphics$layer$$endPainting$() {
    this.reset();
  };
  hamonengine.graphics.layer.prototype.drawLayer = function $hamonengine$graphics$layer$$drawLayer$($layer$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$) {
    $destinationWidth$$ = void 0 === $destinationWidth$$ ? this.width : $destinationWidth$$;
    $destinationHeight$$ = void 0 === $destinationHeight$$ ? this.height : $destinationHeight$$;
    if (!($layer$$ instanceof hamonengine.graphics.layer)) {
      throw "Parameter layer is not of type hamonengine.graphics.layer.";
    }
    this.context.drawImage($layer$$.canvas, void 0 === $destinationX$$ ? 0 : $destinationX$$, void 0 === $destinationY$$ ? 0 : $destinationY$$, $destinationWidth$$, $destinationHeight$$);
  };
  hamonengine.graphics.layer.prototype.drawText = function $hamonengine$graphics$layer$$drawText$($text$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var25_color$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var26_metrics_metrics$11$$ = void 0 === $$jscomp$destructuring$var25_color$$ ? {} : $$jscomp$destructuring$var25_color$$;
    $$jscomp$destructuring$var25_color$$ = void 0 === $$jscomp$destructuring$var26_metrics_metrics$11$$.color ? "white" : $$jscomp$destructuring$var26_metrics_metrics$11$$.color;
    var $textDrawType$$ = void 0 === $$jscomp$destructuring$var26_metrics_metrics$11$$.textDrawType ? TEXT_DRAW_TYPE.FILL : $$jscomp$destructuring$var26_metrics_metrics$11$$.textDrawType, $textOffset$$ = void 0 === $$jscomp$destructuring$var26_metrics_metrics$11$$.textOffset ? "left" : $$jscomp$destructuring$var26_metrics_metrics$11$$.textOffset;
    this.context.font = void 0 === $$jscomp$destructuring$var26_metrics_metrics$11$$.font ? "16px serif" : $$jscomp$destructuring$var26_metrics_metrics$11$$.font;
    this.context.textBaseline = "top";
    switch($textOffset$$) {
      case "center":
        $$jscomp$destructuring$var26_metrics_metrics$11$$ = this.context.measureText($text$$);
        $sourceX$$ -= $$jscomp$destructuring$var26_metrics_metrics$11$$.width / 2;
        break;
      case "left":
        break;
      case "right":
        $$jscomp$destructuring$var26_metrics_metrics$11$$ = this.context.measureText($text$$);
        $sourceX$$ -= $$jscomp$destructuring$var26_metrics_metrics$11$$.width;
        break;
      default:
        $sourceX$$ -= parseInt($textOffset$$);
    }
    $textDrawType$$ === TEXT_DRAW_TYPE.STROKE ? (this.context.strokeStyle = $$jscomp$destructuring$var25_color$$, this.context.strokeText($text$$, $sourceX$$, $sourceY$$)) : (this.context.fillStyle = $$jscomp$destructuring$var25_color$$, this.context.fillText($text$$, $sourceX$$, $sourceY$$));
  };
  hamonengine.graphics.layer.prototype.drawImage = function $hamonengine$graphics$layer$$drawImage$($image$$, $sourceX$$, $sourceY$$, $sourceWidth$$, $sourceHeight$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$) {
    $image$$.complete && this.context.drawImage($image$$ instanceof hamonengine.graphics.imageext ? $image$$.image : $image$$, $sourceX$$, $sourceY$$, $sourceWidth$$, $sourceHeight$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$);
  };
  hamonengine.graphics.layer.prototype.drawVector = function $hamonengine$graphics$layer$$drawVector$($vector$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var27_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var28_color$$ = void 0 === $$jscomp$destructuring$var27_lineWidth$$ ? {} : $$jscomp$destructuring$var27_lineWidth$$;
    $$jscomp$destructuring$var27_lineWidth$$ = void 0 === $$jscomp$destructuring$var28_color$$.lineWidth ? 1 : $$jscomp$destructuring$var28_color$$.lineWidth;
    $$jscomp$destructuring$var28_color$$ = void 0 === $$jscomp$destructuring$var28_color$$.color ? "white" : $$jscomp$destructuring$var28_color$$.color;
    if (!($vector$$ instanceof hamonengine.math.vector2 || $vector$$ instanceof hamonengine.math.vector3)) {
      throw "Parameter vector is not of type hamonengine.math.vector2 or of type hamonengine.math.vector3.";
    }
    this.context.lineWidth = $$jscomp$destructuring$var27_lineWidth$$;
    this.context.strokeStyle = $$jscomp$destructuring$var28_color$$;
    this.context.beginPath();
    this.context.moveTo($sourceX$$, $sourceY$$);
    this.context.lineTo($sourceX$$ + $vector$$.x, $sourceY$$ + $vector$$.y);
    this.context.stroke();
  };
  hamonengine.graphics.layer.prototype.drawLineSegment = function $hamonengine$graphics$layer$$drawLineSegment$($lineSegment$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var29_lineWidth$$) {
    var $$jscomp$destructuring$var30_color$$ = void 0 === $$jscomp$destructuring$var29_lineWidth$$ ? {} : $$jscomp$destructuring$var29_lineWidth$$;
    $$jscomp$destructuring$var29_lineWidth$$ = void 0 === $$jscomp$destructuring$var30_color$$.lineWidth ? 1 : $$jscomp$destructuring$var30_color$$.lineWidth;
    var $drawNormals$$ = void 0 === $$jscomp$destructuring$var30_color$$.drawNormals ? !0 : $$jscomp$destructuring$var30_color$$.drawNormals;
    $$jscomp$destructuring$var30_color$$ = void 0 === $$jscomp$destructuring$var30_color$$.color ? "white" : $$jscomp$destructuring$var30_color$$.color;
    if (!($lineSegment$$ instanceof hamonengine.geometry.lineSegment)) {
      throw "Parameter lineSegment is not of type hamonengine.geometry.lineSegment.";
    }
    this.simpleDrawCoords($lineSegment$$._coords, 4, $lineSegment$$._offset, void 0 === $sourceX$$ ? 0 : $sourceX$$, void 0 === $sourceY$$ ? 0 : $sourceY$$, {lineWidth:$$jscomp$destructuring$var29_lineWidth$$, color:$$jscomp$destructuring$var30_color$$, normals:$drawNormals$$ ? $lineSegment$$.normals : []});
  };
  hamonengine.graphics.layer.prototype.drawPolyChain = function $hamonengine$graphics$layer$$drawPolyChain$($polyChain$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var31_lineWidth$$) {
    var $$jscomp$destructuring$var32_color$$ = void 0 === $$jscomp$destructuring$var31_lineWidth$$ ? {} : $$jscomp$destructuring$var31_lineWidth$$;
    $$jscomp$destructuring$var31_lineWidth$$ = void 0 === $$jscomp$destructuring$var32_color$$.lineWidth ? 1 : $$jscomp$destructuring$var32_color$$.lineWidth;
    var $drawNormals$$ = void 0 === $$jscomp$destructuring$var32_color$$.drawNormals ? !0 : $$jscomp$destructuring$var32_color$$.drawNormals;
    $$jscomp$destructuring$var32_color$$ = void 0 === $$jscomp$destructuring$var32_color$$.color ? "white" : $$jscomp$destructuring$var32_color$$.color;
    if (!($polyChain$$ instanceof hamonengine.geometry.polyChain)) {
      throw "Parameter polyChain is not of type hamonengine.geometry.polyChain.";
    }
    this.simpleDrawCoords($polyChain$$._coords, $polyChain$$._coords.length, 0, void 0 === $sourceX$$ ? 0 : $sourceX$$, void 0 === $sourceY$$ ? 0 : $sourceY$$, {lineWidth:$$jscomp$destructuring$var31_lineWidth$$, color:$$jscomp$destructuring$var32_color$$, normals:$drawNormals$$ ? $polyChain$$.normals : []});
  };
  hamonengine.graphics.layer.prototype.simpleDrawCoords = function $hamonengine$graphics$layer$$simpleDrawCoords$($coordinates$$, $length$$, $index$jscomp$79_offset$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var33_normals$$) {
    $length$$ = void 0 === $length$$ ? 0 : $length$$;
    $index$jscomp$79_offset$$ = void 0 === $index$jscomp$79_offset$$ ? 0 : $index$jscomp$79_offset$$;
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var34_edges$$ = void 0 === $$jscomp$destructuring$var33_normals$$ ? {} : $$jscomp$destructuring$var33_normals$$, $color$jscomp$6_i$$ = void 0 === $$jscomp$destructuring$var34_edges$$.color ? "white" : $$jscomp$destructuring$var34_edges$$.color;
    $$jscomp$destructuring$var33_normals$$ = void 0 === $$jscomp$destructuring$var34_edges$$.normals ? [] : $$jscomp$destructuring$var34_edges$$.normals;
    if (!(0 != $coordinates$$.length % 2 || $index$jscomp$79_offset$$ + 1 > $coordinates$$.length)) {
      this.context.lineWidth = void 0 === $$jscomp$destructuring$var34_edges$$.lineWidth ? 1 : $$jscomp$destructuring$var34_edges$$.lineWidth;
      this.context.strokeStyle = $color$jscomp$6_i$$;
      this.context.beginPath();
      $length$$ = $index$jscomp$79_offset$$ + $length$$ > $coordinates$$.length ? $coordinates$$.length : $index$jscomp$79_offset$$ + $length$$;
      $$jscomp$destructuring$var34_edges$$ = [];
      for ($color$jscomp$6_i$$ = $index$jscomp$79_offset$$; $color$jscomp$6_i$$ < $length$$; $color$jscomp$6_i$$ += 2) {
        var $v1$jscomp$13_x$$ = Math.bitRound($sourceX$$ + $coordinates$$[$color$jscomp$6_i$$]), $normal_y$$ = Math.bitRound($sourceY$$ + $coordinates$$[$color$jscomp$6_i$$ + 1]);
        this.invertYAxis && ($normal_y$$ = this.viewPort.height - $normal_y$$);
        this.invertXAxis && ($v1$jscomp$13_x$$ = this.viewPort.width - $v1$jscomp$13_x$$);
        if ($color$jscomp$6_i$$ === $index$jscomp$79_offset$$) {
          this.context.moveTo($v1$jscomp$13_x$$, $normal_y$$);
          var $edgeIndex_lastPoint$$ = new hamonengine.math.vector2($v1$jscomp$13_x$$, $normal_y$$);
        } else {
          this.context.lineTo($v1$jscomp$13_x$$, $normal_y$$), $v1$jscomp$13_x$$ = new hamonengine.math.vector2($v1$jscomp$13_x$$, $normal_y$$), $$jscomp$destructuring$var34_edges$$.push($v1$jscomp$13_x$$.subtract($edgeIndex_lastPoint$$)), $edgeIndex_lastPoint$$ = $v1$jscomp$13_x$$;
        }
      }
      this.context.stroke();
      if (hamonengine.debug && 0 < $$jscomp$destructuring$var33_normals$$.length) {
        for (this.context.strokeStyle = "white", $edgeIndex_lastPoint$$ = 0; $index$jscomp$79_offset$$ < $length$$ && $edgeIndex_lastPoint$$ < $$jscomp$destructuring$var34_edges$$.length && $edgeIndex_lastPoint$$ < $$jscomp$destructuring$var33_normals$$.length; $index$jscomp$79_offset$$ += 2, $edgeIndex_lastPoint$$++) {
          $color$jscomp$6_i$$ = Math.bitRound($sourceX$$ + $coordinates$$[$index$jscomp$79_offset$$] + $$jscomp$destructuring$var34_edges$$[$edgeIndex_lastPoint$$].x / 2);
          $v1$jscomp$13_x$$ = Math.bitRound($sourceY$$ + $coordinates$$[$index$jscomp$79_offset$$ + 1] + $$jscomp$destructuring$var34_edges$$[$edgeIndex_lastPoint$$].y / 2);
          this.invertYAxis && ($v1$jscomp$13_x$$ = this.viewPort.height - $v1$jscomp$13_x$$);
          this.invertXAxis && ($color$jscomp$6_i$$ = this.viewPort.width - $color$jscomp$6_i$$);
          this.context.beginPath();
          this.context.moveTo($color$jscomp$6_i$$, $v1$jscomp$13_x$$);
          $normal_y$$ = $$jscomp$destructuring$var33_normals$$[$edgeIndex_lastPoint$$];
          var $normalSize$$ = Math.bitRound($$jscomp$destructuring$var34_edges$$[$edgeIndex_lastPoint$$].length / 2);
          this.invertYAxis && ($normal_y$$.y = -$normal_y$$.y);
          this.invertXAxis && ($normal_y$$.x = -$normal_y$$.x);
          this.context.lineTo($color$jscomp$6_i$$ + $normal_y$$.x * $normalSize$$, $v1$jscomp$13_x$$ + $normal_y$$.y * $normalSize$$);
          this.context.stroke();
        }
      }
    }
  };
  hamonengine.graphics.layer.prototype.drawRect = function $hamonengine$graphics$layer$$drawRect$($rect$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var35_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var36_fillColor$$ = void 0 === $$jscomp$destructuring$var35_lineWidth$$ ? {} : $$jscomp$destructuring$var35_lineWidth$$;
    $$jscomp$destructuring$var35_lineWidth$$ = void 0 === $$jscomp$destructuring$var36_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var36_fillColor$$.lineWidth;
    var $color$$ = void 0 === $$jscomp$destructuring$var36_fillColor$$.color ? "white" : $$jscomp$destructuring$var36_fillColor$$.color, $fill$$ = void 0 === $$jscomp$destructuring$var36_fillColor$$.fill ? !1 : $$jscomp$destructuring$var36_fillColor$$.fill;
    $$jscomp$destructuring$var36_fillColor$$ = void 0 === $$jscomp$destructuring$var36_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var36_fillColor$$.fillColor;
    this.simpleDrawRect($rect$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var35_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var36_fillColor$$});
    var $wrappingPosition$$ = new hamonengine.math.vector2;
    if (this.wrapHorizontal) {
      var $xOffset$14_xOffset$jscomp$3_yOffset$$ = $sourceX$$ + $rect$$.x - this.viewPort.x;
      0 >= $xOffset$14_xOffset$jscomp$3_yOffset$$ && (this.simpleDrawRect($rect$$, this.viewPort.width + $xOffset$14_xOffset$jscomp$3_yOffset$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var35_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var36_fillColor$$}), $wrappingPosition$$.x = this.viewPort.width + $xOffset$14_xOffset$jscomp$3_yOffset$$);
      $sourceX$$ + $rect$$.width >= this.viewPort.width && ($xOffset$14_xOffset$jscomp$3_yOffset$$ = this.viewPort.width - ($sourceX$$ + $rect$$.x), this.simpleDrawRect($rect$$, this.viewPort.x - $xOffset$14_xOffset$jscomp$3_yOffset$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var35_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var36_fillColor$$}), $wrappingPosition$$.x = this.viewPort.x - $xOffset$14_xOffset$jscomp$3_yOffset$$);
    }
    this.wrapVertical && ($xOffset$14_xOffset$jscomp$3_yOffset$$ = $sourceY$$ + $rect$$.y - this.viewPort.y, 0 >= $xOffset$14_xOffset$jscomp$3_yOffset$$ && (this.simpleDrawRect($rect$$, $sourceX$$, this.viewPort.height + $xOffset$14_xOffset$jscomp$3_yOffset$$, {lineWidth:$$jscomp$destructuring$var35_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var36_fillColor$$}), $wrappingPosition$$.y = this.viewPort.height + $xOffset$14_xOffset$jscomp$3_yOffset$$), $sourceY$$ + $rect$$.height >= 
    this.viewPort.height && ($sourceY$$ = this.viewPort.height - ($sourceY$$ + $rect$$.y), this.simpleDrawRect($rect$$, $sourceX$$, this.viewPort.y - $sourceY$$, {lineWidth:$$jscomp$destructuring$var35_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var36_fillColor$$}), $wrappingPosition$$.y = this.viewPort.y - $sourceY$$));
    this.wrapVertical && this.wrapHorizontal && $wrappingPosition$$.x && $wrappingPosition$$.y && this.simpleDrawRect($rect$$, $wrappingPosition$$.x, $wrappingPosition$$.y, {lineWidth:$$jscomp$destructuring$var35_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var36_fillColor$$});
  };
  hamonengine.graphics.layer.prototype.simpleDrawRect = function $hamonengine$graphics$layer$$simpleDrawRect$($rect$$, $sourceX$jscomp$7_x$$, $sourceY$jscomp$7_y$$, $$jscomp$destructuring$var37_fill$$) {
    var $$jscomp$destructuring$var38_fillColor$$ = void 0 === $$jscomp$destructuring$var37_fill$$ ? {} : $$jscomp$destructuring$var37_fill$$, $lineWidth$$ = void 0 === $$jscomp$destructuring$var38_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var38_fillColor$$.lineWidth, $color$$ = void 0 === $$jscomp$destructuring$var38_fillColor$$.color ? "white" : $$jscomp$destructuring$var38_fillColor$$.color;
    $$jscomp$destructuring$var37_fill$$ = void 0 === $$jscomp$destructuring$var38_fillColor$$.fill ? !1 : $$jscomp$destructuring$var38_fillColor$$.fill;
    $$jscomp$destructuring$var38_fillColor$$ = void 0 === $$jscomp$destructuring$var38_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var38_fillColor$$.fillColor;
    if (!($rect$$ instanceof hamonengine.geometry.rect)) {
      throw "Parameter rect is not of type hamonengine.geometry.rect.";
    }
    this.context.lineWidth = $lineWidth$$;
    this.context.strokeStyle = $color$$;
    this.context.fillStyle = $$jscomp$destructuring$var38_fillColor$$;
    $sourceX$jscomp$7_x$$ = $rect$$.x + (void 0 === $sourceX$jscomp$7_x$$ ? 0 : $sourceX$jscomp$7_x$$);
    $sourceY$jscomp$7_y$$ = $rect$$.y + (void 0 === $sourceY$jscomp$7_y$$ ? 0 : $sourceY$jscomp$7_y$$);
    this.invertYAxis && ($sourceY$jscomp$7_y$$ = this.viewPort.height - $sourceY$jscomp$7_y$$);
    this.invertXAxis && ($sourceX$jscomp$7_x$$ = this.viewPort.width - $sourceX$jscomp$7_x$$);
    this.context.beginPath();
    this.context.moveTo($sourceX$jscomp$7_x$$, $sourceY$jscomp$7_y$$);
    this.context.strokeRect($sourceX$jscomp$7_x$$, $sourceY$jscomp$7_y$$, $rect$$.width, $rect$$.height);
    this.context.closePath();
    $$jscomp$destructuring$var37_fill$$ && this.context.fillRect($sourceX$jscomp$7_x$$, $sourceY$jscomp$7_y$$, $rect$$.width, $rect$$.height);
    this.context.stroke();
  };
  hamonengine.graphics.layer.prototype.drawPolygon = function $hamonengine$graphics$layer$$drawPolygon$($polygon$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var39_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var40_fillColor$$ = void 0 === $$jscomp$destructuring$var39_lineWidth$$ ? {} : $$jscomp$destructuring$var39_lineWidth$$;
    $$jscomp$destructuring$var39_lineWidth$$ = void 0 === $$jscomp$destructuring$var40_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var40_fillColor$$.lineWidth;
    var $color$$ = void 0 === $$jscomp$destructuring$var40_fillColor$$.color ? "white" : $$jscomp$destructuring$var40_fillColor$$.color, $drawNormals$$ = void 0 === $$jscomp$destructuring$var40_fillColor$$.drawNormals ? !1 : $$jscomp$destructuring$var40_fillColor$$.drawNormals, $fill$$ = void 0 === $$jscomp$destructuring$var40_fillColor$$.fill ? !1 : $$jscomp$destructuring$var40_fillColor$$.fill;
    $$jscomp$destructuring$var40_fillColor$$ = void 0 === $$jscomp$destructuring$var40_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var40_fillColor$$.fillColor;
    this.simpleDrawPolygon($polygon$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var39_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var40_fillColor$$});
    var $wrappingPosition$$ = new hamonengine.math.vector2;
    if (this.wrapHorizontal) {
      var $xOffset$16_xOffset$jscomp$4_yOffset$$ = $sourceX$$ + $polygon$$.min.x - this.viewPort.x;
      0 >= $xOffset$16_xOffset$jscomp$4_yOffset$$ && (this.simpleDrawPolygon($polygon$$, this.viewPort.width + $xOffset$16_xOffset$jscomp$4_yOffset$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var39_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var40_fillColor$$}), $wrappingPosition$$.x = this.viewPort.width + $xOffset$16_xOffset$jscomp$4_yOffset$$);
      $sourceX$$ + $polygon$$.width >= this.viewPort.width && ($xOffset$16_xOffset$jscomp$4_yOffset$$ = this.viewPort.width - ($sourceX$$ + $polygon$$.min.x), this.simpleDrawPolygon($polygon$$, this.viewPort.x - $xOffset$16_xOffset$jscomp$4_yOffset$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var39_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var40_fillColor$$}), $wrappingPosition$$.x = this.viewPort.x - $xOffset$16_xOffset$jscomp$4_yOffset$$);
    }
    this.wrapVertical && ($xOffset$16_xOffset$jscomp$4_yOffset$$ = $sourceY$$ + $polygon$$.min.y - this.viewPort.y, 0 >= $xOffset$16_xOffset$jscomp$4_yOffset$$ && (this.simpleDrawPolygon($polygon$$, $sourceX$$, this.viewPort.height + $xOffset$16_xOffset$jscomp$4_yOffset$$, {lineWidth:$$jscomp$destructuring$var39_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var40_fillColor$$}), $wrappingPosition$$.y = this.viewPort.height + $xOffset$16_xOffset$jscomp$4_yOffset$$), 
    $sourceY$$ + $polygon$$.height >= this.viewPort.height && ($sourceY$$ = this.viewPort.height - ($sourceY$$ + $polygon$$.min.y), this.simpleDrawPolygon($polygon$$, $sourceX$$, this.viewPort.y - $sourceY$$, {lineWidth:$$jscomp$destructuring$var39_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var40_fillColor$$}), $wrappingPosition$$.y = this.viewPort.y - $sourceY$$));
    this.wrapVertical && this.wrapHorizontal && $wrappingPosition$$.x && $wrappingPosition$$.y && this.simpleDrawPolygon($polygon$$, $wrappingPosition$$.x, $wrappingPosition$$.y, {lineWidth:$$jscomp$destructuring$var39_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var40_fillColor$$});
  };
  hamonengine.graphics.layer.prototype.simpleDrawPolygon = function $hamonengine$graphics$layer$$simpleDrawPolygon$($polygon$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var41_drawNormals$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$ = void 0 === $$jscomp$destructuring$var41_drawNormals$$ ? {} : $$jscomp$destructuring$var41_drawNormals$$, $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$ = void 0 === $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.lineWidth ? 1 : $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.lineWidth, $color$jscomp$10_vertex_x$$ = void 0 === $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.color ? 
    "white" : $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.color;
    $$jscomp$destructuring$var41_drawNormals$$ = void 0 === $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.drawNormals ? !1 : $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.drawNormals;
    var $fill$$ = void 0 === $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.fill ? !1 : $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.fill;
    $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$ = void 0 === $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.fillColor ? "white" : $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.fillColor;
    if (!($polygon$$ instanceof hamonengine.geometry.polygon)) {
      throw "Parameter polygon is not of type hamonengine.geometry.polygon.";
    }
    this.context.lineWidth = $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$;
    this.context.strokeStyle = $color$jscomp$10_vertex_x$$;
    this.context.fillStyle = $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$;
    this.context.beginPath();
    for ($edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$ = 0; $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$ < $polygon$$.vertices.length; $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$++) {
      $color$jscomp$10_vertex_x$$ = Math.bitRound($sourceX$$ + $polygon$$.vertices[$edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$].x), $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$ = Math.bitRound($sourceY$$ + $polygon$$.vertices[$edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$].y), this.invertYAxis && ($$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$ = this.viewPort.height - $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$), 
      this.invertXAxis && ($color$jscomp$10_vertex_x$$ = this.viewPort.width - $color$jscomp$10_vertex_x$$), 0 === $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$ ? this.context.moveTo($color$jscomp$10_vertex_x$$, $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$) : this.context.lineTo($color$jscomp$10_vertex_x$$, $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$);
    }
    this.context.closePath();
    $fill$$ && this.context.fill();
    this.context.stroke();
    if (hamonengine.debug && $$jscomp$destructuring$var41_drawNormals$$) {
      for (this.context.strokeStyle = "white", $$jscomp$destructuring$var41_drawNormals$$ = 0; $$jscomp$destructuring$var41_drawNormals$$ < $polygon$$.vertices.length; $$jscomp$destructuring$var41_drawNormals$$++) {
        $color$jscomp$10_vertex_x$$ = $polygon$$.vertices[$$jscomp$destructuring$var41_drawNormals$$], $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$ = $polygon$$.edges[$$jscomp$destructuring$var41_drawNormals$$], $fill$$ = Math.bitRound($sourceX$$ + $color$jscomp$10_vertex_x$$.x + $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$.x / 2), $color$jscomp$10_vertex_x$$ = Math.bitRound($sourceY$$ + $color$jscomp$10_vertex_x$$.y + $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$.y / 
        2), this.invertYAxis && ($color$jscomp$10_vertex_x$$ = this.viewPort.height - $color$jscomp$10_vertex_x$$), this.invertXAxis && ($fill$$ = this.viewPort.width - $fill$$), this.context.beginPath(), this.context.moveTo($fill$$, $color$jscomp$10_vertex_x$$), $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$ = $polygon$$.normals[$$jscomp$destructuring$var41_drawNormals$$], $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$ = Math.bitRound($edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$.length / 
        2), this.invertYAxis && ($$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.y = -$$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.y), this.invertXAxis && ($$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.x = -$$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.x), this.context.lineTo($fill$$ + $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.x * $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$, 
        $color$jscomp$10_vertex_x$$ + $$jscomp$destructuring$var42_fillColor$jscomp$3_normal$jscomp$1_y$$.y * $edge$jscomp$1_index$jscomp$80_lineWidth$jscomp$7_normalSize$$), this.context.stroke();
      }
    }
  };
  hamonengine.graphics.layer.prototype.drawShape = function $hamonengine$graphics$layer$$drawShape$($shape$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var43_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var44_fillColor$$ = void 0 === $$jscomp$destructuring$var43_lineWidth$$ ? {} : $$jscomp$destructuring$var43_lineWidth$$;
    $$jscomp$destructuring$var43_lineWidth$$ = void 0 === $$jscomp$destructuring$var44_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var44_fillColor$$.lineWidth;
    var $color$$ = void 0 === $$jscomp$destructuring$var44_fillColor$$.color ? "white" : $$jscomp$destructuring$var44_fillColor$$.color, $drawNormals$$ = void 0 === $$jscomp$destructuring$var44_fillColor$$.drawNormals ? !1 : $$jscomp$destructuring$var44_fillColor$$.drawNormals, $fill$$ = void 0 === $$jscomp$destructuring$var44_fillColor$$.fill ? !1 : $$jscomp$destructuring$var44_fillColor$$.fill;
    $$jscomp$destructuring$var44_fillColor$$ = void 0 === $$jscomp$destructuring$var44_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var44_fillColor$$.fillColor;
    $shape$$ instanceof hamonengine.geometry.rect && this.drawRect($shape$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var43_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var44_fillColor$$});
    $shape$$ instanceof hamonengine.geometry.polygon && this.drawPolygon($shape$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var43_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var44_fillColor$$});
    $shape$$ instanceof hamonengine.geometry.lineSegment && this.drawLineSegment($shape$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var43_lineWidth$$, drawNormals:$drawNormals$$, color:$color$$});
    $shape$$ instanceof hamonengine.geometry.polyChain && this.drawPolyChain($shape$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var43_lineWidth$$, drawNormals:$drawNormals$$, color:$color$$});
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.layer.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, allowEventBinding:{configurable:!0, enumerable:!0, get:function() {
    return this._allowEventBinding;
  }}, context:{configurable:!0, enumerable:!0, get:function() {
    return this._canvasContext;
  }}, canvas:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas;
  }}, clipToViewPort:{configurable:!0, enumerable:!0, get:function() {
    return this._clipToViewPort;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas.width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas.height;
  }}, offsetX:{configurable:!0, enumerable:!0, get:function() {
    return this.canvas.offsetLeft;
  }}, offsetY:{configurable:!0, enumerable:!0, get:function() {
    return this.canvas.offsetTop;
  }}, position:{configurable:!0, enumerable:!0, get:function() {
    var $boundRect$$ = this.canvas.getBoundingClientRect() || {left:0, top:0};
    return new hamonengine.math.vector2($boundRect$$.left, $boundRect$$.top);
  }}, viewPort:{configurable:!0, enumerable:!0, get:function() {
    return this._viewPort;
  }}, wrapHorizontal:{configurable:!0, enumerable:!0, get:function() {
    return this._wrapHorizontal;
  }, set:function($v$$) {
    this._wrapHorizontal = $v$$;
  }}, wrapVertical:{configurable:!0, enumerable:!0, get:function() {
    return this._wrapVertical;
  }, set:function($v$$) {
    this._wrapVertical = $v$$;
  }}, allowSaveState:{configurable:!0, enumerable:!0, get:function() {
    return this._allowSaveStateEnabled;
  }, set:function($v$$) {
    this._allowSaveStateEnabled = $v$$;
  }}, borderColor:{configurable:!0, enumerable:!0, get:function() {
    return this._viewPortBorderColor;
  }, set:function($v$$) {
    this._viewPortBorderColor = $v$$;
  }}, invertYAxis:{configurable:!0, enumerable:!0, get:function() {
    return this._invertYAxis;
  }, set:function($v$$) {
    this._invertYAxis = $v$$;
  }}, invertXAxis:{configurable:!0, enumerable:!0, get:function() {
    return this._invertXAxis;
  }, set:function($v$$) {
    this._invertXAxis = $v$$;
  }}, alpha:{configurable:!0, enumerable:!0, get:function() {
    return this.context.globalAlpha;
  }, set:function($v$$) {
    this.context.globalAlpha = $v$$;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.sprite = function $hamonengine$graphics$sprite$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.graphics.sprite && ($options$$ = {image:$options$$._image && $options$$._image.clone(), dimensions:$options$$._dimensions, theta:$options$$.theta});
    this._name = $options$$.name;
    this._image = $options$$.image || new hamonengine.graphics.imageext;
    this._url = $options$$.url || "";
    this._dimensions = $options$$.dimensions ? $options$$.dimensions : this._image instanceof HTMLImageElement ? new hamonengine.geometry.rect(0, 0, this._image.width, this._image.height) : new hamonengine.geometry.rect;
    this._theta = $options$$.theta || 0.0;
    this._scaleVector = new hamonengine.math.vector2(1.0, 1.0);
    this._spriteOrientation = 0;
    this._showFullImage = this._showDiagnosisLines = !1;
    this._maxWrapping = 0;
    hamonengine.debug && hamonengine.verbose && (console.debug("[hamonengine.graphics.sprite.constructor] Starting Dimensions: {" + this._dimensions.toString() + "}"), console.debug("[hamonengine.graphics.sprite.constructor] Name: " + this._name), console.debug("[hamonengine.graphics.sprite.constructor] Theta: " + this._theta), console.debug("[hamonengine.graphics.sprite.constructor] ScaleVector: {" + this._scaleVector.toString() + "}"));
  };
  hamonengine.graphics.sprite.prototype.copyProperties = function $hamonengine$graphics$sprite$$copyProperties$($properties$$) {
    this._theta = $properties$$.theta;
    this._scaleVector = $properties$$._scaleVector;
    this._spriteOrientation = $properties$$._spriteOrientation;
    this._showDiagnosisLines = $properties$$._showDiagnosisLines;
    this._showFullImage = $properties$$._showFullImage;
  };
  hamonengine.graphics.sprite.prototype.clone = function $hamonengine$graphics$sprite$$clone$() {
    return new hamonengine.graphics.sprite(this);
  };
  hamonengine.graphics.sprite.prototype.load = function $hamonengine$graphics$sprite$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      $src$$ = $src$$ || $$jscomp$async$this$$._url;
      return $$jscomp$generator$context$$.return(new Promise(function($resolve$$, $reject$$) {
        $$jscomp$async$this$$._image instanceof hamonengine.graphics.imageext ? $$jscomp$async$this$$._image.load($src$$).then(function() {
          $$jscomp$async$this$$._dimensions = new hamonengine.geometry.rect(0, 0, $$jscomp$async$this$$._image.width, $$jscomp$async$this$$._image.height);
          $resolve$$($$jscomp$async$this$$);
        }).catch(function($err$$) {
          $reject$$($err$$);
        }) : $resolve$$($$jscomp$async$this$$);
      }));
    });
  };
  hamonengine.graphics.sprite.prototype.rotate = function $hamonengine$graphics$sprite$$rotate$($theta$$) {
    this._theta = $theta$$ || 0.0;
    return this;
  };
  hamonengine.graphics.sprite.prototype.scale = function $hamonengine$graphics$sprite$$scale$($x$$, $y$$) {
    this._scaleVector.x = $x$$;
    this._scaleVector.y = $y$$;
    return this;
  };
  hamonengine.graphics.sprite.prototype.mirror = function $hamonengine$graphics$sprite$$mirror$($state$$) {
    this._spriteOrientation = bitflag.toggle(this._spriteOrientation, 2, $state$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.flip = function $hamonengine$graphics$sprite$$flip$($state$$) {
    this._spriteOrientation = bitflag.toggle(this._spriteOrientation, 1, $state$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.blendColor = function $hamonengine$graphics$sprite$$blendColor$($r$$, $g$$, $b$$, $a$$, $blendingOps$$) {
    $blendingOps$$ = void 0 === $blendingOps$$ ? BLENDING_OPS.REPLACE : $blendingOps$$;
    this._image.blendColorRegion(void 0 === $r$$ ? 0 : $r$$, void 0 === $g$$ ? 0 : $g$$, void 0 === $b$$ ? 0 : $b$$, void 0 === $a$$ ? 0 : $a$$, this._dimensions, $blendingOps$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.adjustColorChannel = function $hamonengine$graphics$sprite$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$) {
    this._image.adjustColorChannel(void 0 === $r$$ ? 1.0 : $r$$, void 0 === $g$$ ? 1.0 : $g$$, void 0 === $b$$ ? 1.0 : $b$$, void 0 === $a$$ ? 1.0 : $a$$, this._dimensions);
    return this;
  };
  hamonengine.graphics.sprite.prototype.bitblit = function $hamonengine$graphics$sprite$$bitblit$($sprite$$, $transparency$$) {
    this._image.bitblit($sprite$$._image, $sprite$$._dimensions, this._dimensions, void 0 === $transparency$$ ? 1.0 : $transparency$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.drawRaw = function $hamonengine$graphics$sprite$$drawRaw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this._dimensions.width : $width$$;
    $height$$ = void 0 === $height$$ ? this._dimensions.height : $height$$;
    this._image.complete && (this.showFullImage ? $layer$$.context.drawImage(this._image.image, Math.bitRound($x$$), Math.bitRound($y$$), Math.bitRound($width$$), Math.bitRound($height$$)) : $layer$$.drawImage(this._image, this._dimensions.x, this._dimensions.y, this._dimensions.width, this._dimensions.height, Math.bitRound($x$$), Math.bitRound($y$$), Math.bitRound($width$$), Math.bitRound($height$$)));
  };
  hamonengine.graphics.sprite.prototype.draw = function $hamonengine$graphics$sprite$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this._dimensions.width : $width$$;
    $height$$ = void 0 === $height$$ ? this._dimensions.height : $height$$;
    $x$$ = Math.bitRound($x$$);
    $y$$ = Math.bitRound($y$$);
    var $xCenterOffset_xCenterOffset$21$$ = Math.bitRound($width$$ / 2) + $x$$, $yCenterOffset_yCenterOffset$22$$ = Math.bitRound($height$$ / 2) + $y$$, $yOrientation$$ = bitflag.isSet(this._spriteOrientation, 1) ? -1 : 1.0, $xOrientation$$ = bitflag.isSet(this._spriteOrientation, 2) ? -1 : 1.0;
    $layer$$.save();
    if (1 !== this._scaleVector.x || 1 !== this._scaleVector.y) {
      $layer$$.context.translate($x$$, $y$$), $layer$$.context.scale(this._scaleVector.x, this._scaleVector.y), $layer$$.context.translate(-$x$$, -$y$$);
    }
    0 < this._spriteOrientation && ($layer$$.context.translate($xCenterOffset_xCenterOffset$21$$, $yCenterOffset_yCenterOffset$22$$), $layer$$.context.scale($xOrientation$$, $yOrientation$$), $layer$$.context.translate(-$xCenterOffset_xCenterOffset$21$$, -$yCenterOffset_yCenterOffset$22$$));
    0.0 !== this.theta && ($layer$$.context.translate($xCenterOffset_xCenterOffset$21$$, $yCenterOffset_yCenterOffset$22$$), $layer$$.context.rotate(this.theta), $layer$$.context.translate(-$xCenterOffset_xCenterOffset$21$$, -$yCenterOffset_yCenterOffset$22$$));
    ($layer$$.wrapHorizontal || $layer$$.wrapVertical) && this.drawSpriteWrapping($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$, $xOrientation$$, $yOrientation$$);
    this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$);
    if (hamonengine.debug && this.showDiagnosisLines) {
      $xCenterOffset_xCenterOffset$21$$ = Math.bitRound($width$$ / 2) + $x$$;
      $yCenterOffset_yCenterOffset$22$$ = Math.bitRound($height$$ / 2) + $y$$;
      if ($layer$$.wrapHorizontal || $layer$$.wrapVertical) {
        $layer$$.context.strokeStyle = "red", $layer$$.context.lineWidth = 2, $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$21$$, $yCenterOffset_yCenterOffset$22$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$21$$ + $layer$$.viewPort.width, $yCenterOffset_yCenterOffset$22$$), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$21$$, $yCenterOffset_yCenterOffset$22$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$21$$ - 
        $layer$$.viewPort.width, $yCenterOffset_yCenterOffset$22$$), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$21$$, $yCenterOffset_yCenterOffset$22$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$21$$, $yCenterOffset_yCenterOffset$22$$ + $layer$$.viewPort.height), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$21$$, $yCenterOffset_yCenterOffset$22$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$21$$, 
        $yCenterOffset_yCenterOffset$22$$ - $layer$$.viewPort.height), $layer$$.context.stroke(), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$ + $layer$$.viewPort.width, $y$$, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$ - $layer$$.viewPort.width, $y$$, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$ + $layer$$.viewPort.height, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$ - 
        $layer$$.viewPort.height, $width$$, $height$$), $layer$$.context.strokeStyle = "white", $layer$$.context.strokeRect($xCenterOffset_xCenterOffset$21$$ - $layer$$.viewPort.width / 2, $yCenterOffset_yCenterOffset$22$$ - $layer$$.viewPort.height / 2, $layer$$.viewPort.width, $layer$$.viewPort.height);
      }
      $layer$$.context.strokeStyle = "red";
      $layer$$.context.strokeRect($x$$, $y$$, $width$$, $height$$);
      $layer$$.context.strokeStyle = "cyan";
      $layer$$.context.strokeRect($layer$$.viewPort.x, $layer$$.viewPort.y, $layer$$.viewPort.width, $layer$$.viewPort.height);
    }
    $layer$$.restore();
  };
  hamonengine.graphics.sprite.prototype.drawSpriteWrapping = function $hamonengine$graphics$sprite$$drawSpriteWrapping$($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$109_xOffset$$, $y$jscomp$89_yOffset$$, $width$$, $height$$, $xOrientation$$, $yOrientation$$) {
    var $cosAngle_wrapLoop$24_wrapLoop$25$$ = Math.cos(-this.theta), $sinAngle$$ = Math.sin(-this.theta), $widthScaled_wrapLoop_wrapLoop$23$$ = $width$$ * this._scaleVector.x, $heightScaled$$ = $height$$ * this._scaleVector.y, $wrappingDirection$$ = new hamonengine.math.vector2;
    if ($layer$$.wrapHorizontal) {
      var $horizontalLength_v1y$$ = $layer$$.viewPort.width / this._scaleVector.x * $xOrientation$$;
      var $v1x$$ = Math.bitRound($cosAngle_wrapLoop$24_wrapLoop$25$$ * $horizontalLength_v1y$$);
      $horizontalLength_v1y$$ = Math.bitRound($sinAngle$$ * $horizontalLength_v1y$$);
      if ($x$jscomp$109_xOffset$$ - $widthScaled_wrapLoop_wrapLoop$23$$ <= $layer$$.viewPort.x) {
        if ($wrappingDirection$$.x = 1, $widthScaled_wrapLoop_wrapLoop$23$$ = Math.abs(parseInt(($x$jscomp$109_xOffset$$ - $widthScaled_wrapLoop_wrapLoop$23$$) / $layer$$.viewPort.width, 10)) + 1, 0 === this._maxWrapping || $widthScaled_wrapLoop_wrapLoop$23$$ < this._maxWrapping) {
          this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$109_xOffset$$ + $v1x$$ * $widthScaled_wrapLoop_wrapLoop$23$$, $y$jscomp$89_yOffset$$ + $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$23$$, $width$$, $height$$), 0 < --$widthScaled_wrapLoop_wrapLoop$23$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$109_xOffset$$ + $v1x$$ * $widthScaled_wrapLoop_wrapLoop$23$$, $y$jscomp$89_yOffset$$ + $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$23$$, 
          $width$$, $height$$);
        }
      } else {
        $x$jscomp$109_xOffset$$ + $widthScaled_wrapLoop_wrapLoop$23$$ >= $layer$$.viewPort.width && ($wrappingDirection$$.x = -1, $widthScaled_wrapLoop_wrapLoop$23$$ = parseInt(($x$jscomp$109_xOffset$$ + $widthScaled_wrapLoop_wrapLoop$23$$) / $layer$$.viewPort.width, 10), 0 === this._maxWrapping || $widthScaled_wrapLoop_wrapLoop$23$$ < this._maxWrapping) && (this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$109_xOffset$$ - $v1x$$ * $widthScaled_wrapLoop_wrapLoop$23$$, $y$jscomp$89_yOffset$$ - 
        $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$23$$, $width$$, $height$$), 0 < --$widthScaled_wrapLoop_wrapLoop$23$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$109_xOffset$$ - $v1x$$ * $widthScaled_wrapLoop_wrapLoop$23$$, $y$jscomp$89_yOffset$$ - $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$23$$, $width$$, $height$$));
      }
    }
    if ($layer$$.wrapVertical) {
      var $v2y_verticalLength$$ = $layer$$.viewPort.height / this._scaleVector.y * $yOrientation$$;
      var $v2x$$ = Math.bitRound($sinAngle$$ * $v2y_verticalLength$$);
      $v2y_verticalLength$$ = Math.bitRound($cosAngle_wrapLoop$24_wrapLoop$25$$ * $v2y_verticalLength$$);
      if ($y$jscomp$89_yOffset$$ - $heightScaled$$ <= $layer$$.viewPort.y) {
        if ($wrappingDirection$$.y = 1, $cosAngle_wrapLoop$24_wrapLoop$25$$ = Math.abs(parseInt(($y$jscomp$89_yOffset$$ - $heightScaled$$) / $layer$$.viewPort.height, 10)) + 1, 0 === this._maxWrapping || $cosAngle_wrapLoop$24_wrapLoop$25$$ < this._maxWrapping) {
          this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$109_xOffset$$ - $v2x$$ * $cosAngle_wrapLoop$24_wrapLoop$25$$, $y$jscomp$89_yOffset$$ + $v2y_verticalLength$$ * $cosAngle_wrapLoop$24_wrapLoop$25$$, $width$$, $height$$), 0 < --$cosAngle_wrapLoop$24_wrapLoop$25$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$109_xOffset$$ - $v2x$$ * $cosAngle_wrapLoop$24_wrapLoop$25$$, $y$jscomp$89_yOffset$$ + $v2y_verticalLength$$ * $cosAngle_wrapLoop$24_wrapLoop$25$$, $width$$, 
          $height$$);
        }
      } else {
        $y$jscomp$89_yOffset$$ + $heightScaled$$ >= $layer$$.viewPort.height && ($wrappingDirection$$.y = -1, $cosAngle_wrapLoop$24_wrapLoop$25$$ = parseInt(($y$jscomp$89_yOffset$$ + $heightScaled$$) / $layer$$.viewPort.height, 10), 0 === this._maxWrapping || $cosAngle_wrapLoop$24_wrapLoop$25$$ < this._maxWrapping) && (this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$109_xOffset$$ + $v2x$$ * $cosAngle_wrapLoop$24_wrapLoop$25$$, $y$jscomp$89_yOffset$$ - $v2y_verticalLength$$ * $cosAngle_wrapLoop$24_wrapLoop$25$$, 
        $width$$, $height$$), 0 < --$cosAngle_wrapLoop$24_wrapLoop$25$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$109_xOffset$$ + $v2x$$ * $cosAngle_wrapLoop$24_wrapLoop$25$$, $y$jscomp$89_yOffset$$ - $v2y_verticalLength$$ * $cosAngle_wrapLoop$24_wrapLoop$25$$, $width$$, $height$$));
      }
    }
    $layer$$.wrapVertical && $layer$$.wrapHorizontal && ($x$jscomp$109_xOffset$$ = $x$jscomp$109_xOffset$$ - $wrappingDirection$$.y * $v2x$$ + $wrappingDirection$$.x * $v1x$$, $y$jscomp$89_yOffset$$ = $y$jscomp$89_yOffset$$ + $wrappingDirection$$.y * $v2y_verticalLength$$ + $wrappingDirection$$.x * $horizontalLength_v1y$$, $x$jscomp$109_xOffset$$ && $y$jscomp$89_yOffset$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$109_xOffset$$, $y$jscomp$89_yOffset$$, $width$$, $height$$));
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.sprite.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }, set:function($v$$) {
    this._name = $v$$;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._dimensions.height;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._dimensions.width;
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return this._theta;
  }}, showDiagnosisLines:{configurable:!0, enumerable:!0, get:function() {
    return this._showDiagnosisLines;
  }, set:function($v$$) {
    this._showDiagnosisLines = $v$$;
  }}, showFullImage:{configurable:!0, enumerable:!0, get:function() {
    return this._showFullImage;
  }, set:function($v$$) {
    this._showFullImage = $v$$;
  }}, maxWrapping:{configurable:!0, enumerable:!0, set:function($v$$) {
    this._maxWrapping = $v$$;
  }}, image:{configurable:!0, enumerable:!0, get:function() {
    return this._image;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.animsprite = function $hamonengine$graphics$animsprite$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.graphics.sprite.call(this, $options$$);
    $options$$ instanceof hamonengine.graphics.animsprite && ($options$$ = {frames:$options$$._frames.map(function($frame$$) {
      return $frame$$.clone();
    }), animationRate:$options$$._animationRate, animationCycles:$options$$._animationCycles});
    this._frames = $options$$.frames || [];
    this._animationRate = $options$$.animationRate || 0;
    this._animationCycles = $options$$.animationCycles || -1;
    this._numberOfAnimationCycles = this._timeSinceLastFrame = this._index = 0;
    this._enableAnimation = !0;
    hamonengine.debug && (console.debug("[hamonengine.graphics.animsprite.constructor] Starting Animation Rate: " + this._animationRate), console.debug("[hamonengine.graphics.animsprite.constructor] Starting Animation Cycle: " + this._animationCycles), console.debug("[hamonengine.graphics.animsprite.constructor] Starting Index: " + this._index), console.debug("[hamonengine.graphics.animsprite.constructor] Starting Enable Animation: " + this._enableAnimation));
  };
  $jscomp.inherits(hamonengine.graphics.animsprite, hamonengine.graphics.sprite);
  hamonengine.graphics.animsprite.prototype.clone = function $hamonengine$graphics$animsprite$$clone$() {
    return new hamonengine.graphics.animsprite(this);
  };
  hamonengine.graphics.animsprite.prototype.start = function $hamonengine$graphics$animsprite$$start$() {
    this._enableAnimation = !0;
    this._numberOfAnimationCycles = 0;
  };
  hamonengine.graphics.animsprite.prototype.stop = function $hamonengine$graphics$animsprite$$stop$() {
    this._enableAnimation = !1;
  };
  hamonengine.graphics.animsprite.prototype.pause = function $hamonengine$graphics$animsprite$$pause$() {
    this._enableAnimation = !this._enableAnimation;
  };
  hamonengine.graphics.animsprite.prototype.next = function $hamonengine$graphics$animsprite$$next$() {
    this.index++;
  };
  hamonengine.graphics.animsprite.prototype.prev = function $hamonengine$graphics$animsprite$$prev$() {
    var $index$$ = this.index - 1;
    this.index = 0 > $index$$ ? this._frames.length + $index$$ : $index$$;
  };
  hamonengine.graphics.animsprite.prototype.addFrame = function $hamonengine$graphics$animsprite$$addFrame$($frame$$) {
    hamonengine.debug && console.debug("[hamonengine.graphics.animsprite.animsprite.addFrame]");
    this._frames.push($frame$$);
  };
  hamonengine.graphics.animsprite.prototype.blendColor = function $hamonengine$graphics$animsprite$$blendColor$($r$$, $g$$, $b$$, $a$$, $blendingOps$$) {
    $r$$ = void 0 === $r$$ ? 0 : $r$$;
    $g$$ = void 0 === $g$$ ? 0 : $g$$;
    $b$$ = void 0 === $b$$ ? 0 : $b$$;
    $a$$ = void 0 === $a$$ ? 0 : $a$$;
    $blendingOps$$ = void 0 === $blendingOps$$ ? BLENDING_OPS.REPLACE : $blendingOps$$;
    for (var $i$$ = 0; $i$$ < this._frames.length; $i$$++) {
      this._frames[$i$$].blendColor($r$$, $g$$, $b$$, $a$$, $blendingOps$$);
    }
  };
  hamonengine.graphics.animsprite.prototype.adjustColorChannel = function $hamonengine$graphics$animsprite$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$) {
    $r$$ = void 0 === $r$$ ? 1.0 : $r$$;
    $g$$ = void 0 === $g$$ ? 1.0 : $g$$;
    $b$$ = void 0 === $b$$ ? 1.0 : $b$$;
    $a$$ = void 0 === $a$$ ? 1.0 : $a$$;
    for (var $i$$ = 0; $i$$ < this._frames.length; $i$$++) {
      this._frames[$i$$].adjustColorChannel($r$$, $g$$, $b$$, $a$$);
    }
  };
  hamonengine.graphics.animsprite.prototype.draw = function $hamonengine$graphics$animsprite$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? null : $width$$;
    $height$$ = void 0 === $height$$ ? null : $height$$;
    var $timeSinceLastFrame$$ = this._timeSinceLastFrame + $elapsedTimeInMilliseconds$$;
    if (this._enableAnimation) {
      var $currentFrame_numberOfAnimationCycles_numberOfFrames$$ = parseInt($timeSinceLastFrame$$ / this.animationRate, 10);
      $currentFrame_numberOfAnimationCycles_numberOfFrames$$ = this.index + $currentFrame_numberOfAnimationCycles_numberOfFrames$$;
      -1 < this.animationCycles && (this._numberOfAnimationCycles += parseInt($currentFrame_numberOfAnimationCycles_numberOfFrames$$ / this._frames.length, 10), this._enableAnimation = this._numberOfAnimationCycles <= this.animationCycles);
      this.index = $currentFrame_numberOfAnimationCycles_numberOfFrames$$;
    }
    0 < this._frames.length && ($currentFrame_numberOfAnimationCycles_numberOfFrames$$ = this._frames[this.index], $currentFrame_numberOfAnimationCycles_numberOfFrames$$.copyProperties(this), $currentFrame_numberOfAnimationCycles_numberOfFrames$$.draw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$ || $currentFrame_numberOfAnimationCycles_numberOfFrames$$.width, $height$$ || $currentFrame_numberOfAnimationCycles_numberOfFrames$$.height));
    this._timeSinceLastFrame = $timeSinceLastFrame$$ % this.animationRate;
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.animsprite.prototype, {index:{configurable:!0, enumerable:!0, get:function() {
    return this._index;
  }, set:function($v$$) {
    this._index = $v$$ % this._frames.length || 0;
  }}, animationRate:{configurable:!0, enumerable:!0, get:function() {
    return this._animationRate;
  }, set:function($v$$) {
    this._animationRate = 0 < $v$$ ? $v$$ : 1;
  }}, animationCycles:{configurable:!0, enumerable:!0, get:function() {
    return this._animationCycles;
  }, set:function($v$$) {
    this._animationCycles = $v$$;
    this._enableAnimation = !0;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.spritesheet = function $hamonengine$graphics$spritesheet$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._imageResource = new hamonengine.graphics.imageext;
    this._sprites = {};
    this._spriteIndex = [];
    this._url = $options$$.url || "";
    this._name = $options$$.name || "";
    hamonengine.debug && (console.debug("[hamonengine.audio.album.constructor] Name: '" + this._name + "'"), console.debug("[hamonengine.graphics.spritesheet.constructor] Url: '" + this._url + "''"));
  };
  hamonengine.graphics.spritesheet.prototype.load = function $hamonengine$graphics$spritesheet$$load$($spriteSheetMetadata$$) {
    $spriteSheetMetadata$$ = void 0 === $spriteSheetMetadata$$ ? "" : $spriteSheetMetadata$$;
    var $$jscomp$async$this$$ = this, $spriteSheetMetadataResponse$$, $resourceLoadingPromise$$, $i$$, $spriteMetadata$$, $spriteName$$, $i$26$$, $animSpriteMetadata$$, $animatedSprite$$, $j$$, $frameMetadata$$, $spriteName$27$$;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      if (1 == $$jscomp$generator$context$$.nextAddress) {
        return $spriteSheetMetadata$$ = $spriteSheetMetadata$$ || $$jscomp$async$this$$._url, "string" !== typeof $spriteSheetMetadata$$ ? $$jscomp$generator$context$$.jumpTo(2) : $$jscomp$generator$context$$.yield(connect.get($spriteSheetMetadata$$), 3);
      }
      2 != $$jscomp$generator$context$$.nextAddress && ($spriteSheetMetadataResponse$$ = $$jscomp$generator$context$$.yieldResult, $spriteSheetMetadata$$ = JSON.parse($spriteSheetMetadataResponse$$.data));
      $$jscomp$async$this$$._name = $$jscomp$async$this$$._name || $spriteSheetMetadata$$.name;
      $resourceLoadingPromise$$ = $$jscomp$async$this$$._imageResource.load($spriteSheetMetadata$$.spritesheetUrl);
      if ($spriteSheetMetadata$$.sprites) {
        for ($i$$ = 0; $i$$ < $spriteSheetMetadata$$.sprites.length; $i$$++) {
          $spriteMetadata$$ = $spriteSheetMetadata$$.sprites[$i$$], $spriteName$$ = $spriteMetadata$$.name.toLowerCase(), $$jscomp$async$this$$._spriteIndex.push($spriteName$$), $$jscomp$async$this$$._sprites[$spriteName$$] = new hamonengine.graphics.sprite({image:$$jscomp$async$this$$._imageResource, name:$spriteMetadata$$.name, dimensions:new hamonengine.geometry.rect($spriteMetadata$$.x, $spriteMetadata$$.y, $spriteMetadata$$.width, $spriteMetadata$$.height)});
        }
      }
      if ($spriteSheetMetadata$$.animSprites) {
        for ($i$26$$ = 0; $i$26$$ < $spriteSheetMetadata$$.animSprites.length; $i$26$$++) {
          $animSpriteMetadata$$ = $spriteSheetMetadata$$.animSprites[$i$26$$];
          $animatedSprite$$ = new hamonengine.graphics.animsprite({animationRate:$animSpriteMetadata$$.animationRate, });
          for ($j$$ = 0; $j$$ < $animSpriteMetadata$$.frames.length; $j$$++) {
            $frameMetadata$$ = $animSpriteMetadata$$.frames[$j$$], $animatedSprite$$.addFrame(new hamonengine.graphics.sprite({image:$$jscomp$async$this$$._imageResource, name:$frameMetadata$$.name, dimensions:new hamonengine.geometry.rect($frameMetadata$$.x, $frameMetadata$$.y, $frameMetadata$$.width, $frameMetadata$$.height)}));
          }
          $spriteName$27$$ = $animSpriteMetadata$$.name.toLowerCase();
          $$jscomp$async$this$$._spriteIndex.push($spriteName$27$$);
          $$jscomp$async$this$$._sprites[$spriteName$27$$] = $animatedSprite$$;
        }
      }
      return $$jscomp$generator$context$$.return($resourceLoadingPromise$$);
    });
  };
  hamonengine.graphics.spritesheet.prototype.getSprite = function $hamonengine$graphics$spritesheet$$getSprite$($spriteName$$) {
    return this._sprites[$spriteName$$.toLowerCase()].clone();
  };
  hamonengine.graphics.spritesheet.prototype.getSpriteByOrdinal = function $hamonengine$graphics$spritesheet$$getSpriteByOrdinal$($index$$) {
    return this._sprites[this._spriteIndex[$index$$]].clone();
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.spritesheet.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, length:{configurable:!0, enumerable:!0, get:function() {
    return this._spriteIndex.length;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._imageResource.isLoaded();
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
var OBJECT_STATE_FLAG = {NONE:0, SOLID:1, MOVEABLE:2, VISIBLE:4}, OBJECT_FACE_DIRECTION = {NONE:0, XAXIS:1, YAXIS:2};
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.object2d = function $hamonengine$entities$object2d$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.entities.object2d && ($options$$ = {name:$options$$._name, boundingShape:$options$$._boundingShape, width:$options$$._width, height:$options$$._height, zinddex:$options$$._zindex, movementRate:$options$$._movementRate, position:$options$$._position, direction:$options$$._direction, theta:$options$$._theta, scale:$options$$._scale, state:$options$$._state});
    this._name = $options$$.name || "";
    this._boundingShape = $options$$.boundingShape;
    this._width = $options$$.width || 0;
    this._height = $options$$.height || 0;
    this._zindex = $options$$.zindex || 0;
    this._movementRate = $options$$.movementRate || 0;
    this._position = $options$$.position || new hamonengine.math.vector2;
    this._direction = $options$$.direction || new hamonengine.math.vector2;
    this._transformDirection = $options$$.transformDirection || new hamonengine.math.vector2;
    this._theta = $options$$.theta || 0.0;
    this._scale = $options$$.scale || 1.0;
    void 0 !== $options$$.state ? this._state = $options$$.state : (this._state = 0, this._state |= $options$$.isSolid ? OBJECT_STATE_FLAG.SOLID : OBJECT_STATE_FLAG.NONE, this._state |= $options$$.isMovable ? OBJECT_STATE_FLAG.MOVEABLE : OBJECT_STATE_FLAG.NONE, this._state |= $options$$.isVisible ? OBJECT_STATE_FLAG.VISIBLE : OBJECT_STATE_FLAG.NONE);
    hamonengine.debug && (console.debug("[hamonengine.entities.object2d.constructor] Name: " + this.name), console.debug("[hamonengine.entities.object2d.constructor] Starting Dimensions {Width: " + this.width + ", Height: " + this.height + "}"), console.debug("[hamonengine.entities.object2d.constructor] Starting Direction: {x: " + this.direction.x + ", y: " + this.direction.y + "}"), console.debug("[hamonengine.entities.object2d.constructor] Starting Position: {x: " + this.position.x + ", y: " + 
    this.position.y + "}"), console.debug("[hamonengine.entities.object2d.constructor] Starting Theta: " + this.theta), console.debug("[hamonengine.entities.object2d.constructor] Movement Rate: " + this._movementRate), console.debug("[hamonengine.entities.object2d.constructor] isSolid: " + this.isSolid), console.debug("[hamonengine.entities.object2d.constructor] isMovable: " + this.isMovable), console.debug("[hamonengine.entities.object2d.constructor] isVisible: " + this.isVisible));
  };
  hamonengine.entities.object2d.prototype.move = function $hamonengine$entities$object2d$$move$($elapsedTimeInMilliseconds$$, $movementVector$$) {
    this.isMovable && ($movementVector$$ = (void 0 === $movementVector$$ ? null : $movementVector$$) || this.calcMove($elapsedTimeInMilliseconds$$), this.position.x += $movementVector$$.x, this.position.y += $movementVector$$.y);
    return this;
  };
  hamonengine.entities.object2d.prototype.calcMove = function $hamonengine$entities$object2d$$calcMove$($elapsedTimeInMilliseconds$$) {
    return new hamonengine.math.vector2(this._movementRate * this.direction.x * $elapsedTimeInMilliseconds$$, this._movementRate * this.direction.y * $elapsedTimeInMilliseconds$$);
  };
  hamonengine.entities.object2d.prototype.isCollision = function $hamonengine$entities$object2d$$isCollision$($object$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.math.vector2 : $direction$$;
    var $rotation$$ = this.boundingShape.translate(this.position);
    $rotation$$ = $rotation$$.rotateAtCenter ? $rotation$$.rotateAtCenter(this.theta) : $rotation$$;
    return ($rotation$$.scaleAtCenter ? $rotation$$.scaleAtCenter(new hamonengine.math.vector2(this.scale, this.scale)) : $rotation$$).isCollision($object$$, $direction$$);
  };
  hamonengine.entities.object2d.prototype.isContained = function $hamonengine$entities$object2d$$isContained$($targetObject$$) {
    return this.boundingShape.isContained($targetObject$$.position, $targetObject$$.boundingShape);
  };
  hamonengine.entities.object2d.prototype.holdLeft = function $hamonengine$entities$object2d$$holdLeft$() {
    this.direction.x = -1;
    return this;
  };
  hamonengine.entities.object2d.prototype.holdRight = function $hamonengine$entities$object2d$$holdRight$() {
    this.direction.x = 1;
    return this;
  };
  hamonengine.entities.object2d.prototype.holdUp = function $hamonengine$entities$object2d$$holdUp$() {
    this.direction.y = -1;
    return this;
  };
  hamonengine.entities.object2d.prototype.holdDown = function $hamonengine$entities$object2d$$holdDown$() {
    this.direction.y = 1;
    return this;
  };
  hamonengine.entities.object2d.prototype.releaseHorizontal = function $hamonengine$entities$object2d$$releaseHorizontal$() {
    this.direction.x = 0;
    return this;
  };
  hamonengine.entities.object2d.prototype.releaseVertical = function $hamonengine$entities$object2d$$releaseVertical$() {
    this.direction.y = 0;
    return this;
  };
  hamonengine.entities.object2d.prototype.holdRotate = function $hamonengine$entities$object2d$$holdRotate$($state$$, $direction$$) {
    this._transformDirection.x = $state$$ ? void 0 === $direction$$ ? 1 : $direction$$ : 0;
    return this;
  };
  hamonengine.entities.object2d.prototype.resetRotate = function $hamonengine$entities$object2d$$resetRotate$() {
    this.theta = this._transformDirection.x = 0;
    return this;
  };
  hamonengine.entities.object2d.prototype.holdScale = function $hamonengine$entities$object2d$$holdScale$($state$$, $direction$$) {
    this._transformDirection.y = $state$$ ? void 0 === $direction$$ ? 1 : $direction$$ : 0;
    return this;
  };
  hamonengine.entities.object2d.prototype.resetScale = function $hamonengine$entities$object2d$$resetScale$() {
    this._transformDirection.y = 0;
    this.scale = 1.0;
    return this;
  };
  hamonengine.entities.object2d.prototype.reset = function $hamonengine$entities$object2d$$reset$() {
    return this.resetRotate().resetScale().releaseHorizontal().releaseVertical();
  };
  hamonengine.entities.object2d.prototype.toString = function $hamonengine$entities$object2d$$toString$() {
    return "{name: '" + this.name + "', position: '" + this.position + "'}";
  };
  hamonengine.entities.object2d.prototype.onEnvironmentCollision = function $hamonengine$entities$object2d$$onEnvironmentCollision$($position$$, $environmentObject$$) {
    this._position = $position$$;
    return !0;
  };
  hamonengine.entities.object2d.prototype.onObjectCollision = function $hamonengine$entities$object2d$$onObjectCollision$($x$$, $y$$, $object$$) {
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.object2d.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, position:{configurable:!0, enumerable:!0, get:function() {
    return this._position;
  }, set:function($v$$) {
    this._position = $v$$;
  }}, direction:{configurable:!0, enumerable:!0, get:function() {
    return this._direction;
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return this._theta || 0.0;
  }, set:function($v$$) {
    this._theta = $v$$;
  }}, scale:{configurable:!0, enumerable:!0, get:function() {
    return this._scale || 1.0;
  }, set:function($v$$) {
    this._scale = $v$$;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._height;
  }}, zIndex:{configurable:!0, enumerable:!0, get:function() {
    return this._zindex;
  }, set:function($v$$) {
    this._zindex = $v$$;
  }}, boundingShape:{configurable:!0, enumerable:!0, get:function() {
    return this._boundingShape = this._boundingShape || new hamonengine.geometry.rect(0, 0, this.width, this.height);
  }}, isMovable:{configurable:!0, enumerable:!0, get:function() {
    return (this._state & OBJECT_STATE_FLAG.MOVEABLE) === OBJECT_STATE_FLAG.MOVEABLE;
  }}, isSolid:{configurable:!0, enumerable:!0, get:function() {
    return (this._state & OBJECT_STATE_FLAG.SOLID) === OBJECT_STATE_FLAG.SOLID;
  }}, isVisible:{configurable:!0, enumerable:!0, get:function() {
    return (this._state & OBJECT_STATE_FLAG.VISIBLE) === OBJECT_STATE_FLAG.VISIBLE;
  }, set:function($v$$) {
    this._state = $v$$ ? this._state | OBJECT_STATE_FLAG.VISIBLE : this._state ^ OBJECT_STATE_FLAG.VISIBLE;
  }}, isHoldRotate:{configurable:!0, enumerable:!0, get:function() {
    return this._transformDirection.x;
  }}, isHoldScale:{configurable:!0, enumerable:!0, get:function() {
    return this._transformDirection.y;
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.spriteObject = function $hamonengine$entities$spriteObject$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.entities.object2d.call(this, $options$$);
    $options$$ instanceof hamonengine.entities.spriteObject && ($options$$ = {sprite:$options$$._sprite, directionBasis:$options$$._directionBasis});
    this._sprite = $options$$.sprite || new hamonengine.graphics.sprite;
    this._faceAxisOnMove = void 0 !== $options$$.faceAxisOnMove ? $options$$.faceAxisOnMove : OBJECT_FACE_DIRECTION.XAXIS | OBJECT_FACE_DIRECTION.YAXIS;
    this._directionBasis = $options$$.directionBasis || new hamonengine.math.vector2(-1, -1);
    hamonengine.debug && !this._hasBoundingShape && console.debug("[hamonengine.entities.spriteObject.constructor] BoundingShape not found, using sprite dimensions.");
  };
  $jscomp.inherits(hamonengine.entities.spriteObject, hamonengine.entities.object2d);
  hamonengine.entities.spriteObject.prototype.move = function $hamonengine$entities$spriteObject$$move$($elapsedTimeInMilliseconds$$, $movementVector$$) {
    hamonengine.entities.object2d.prototype.move.call(this, $elapsedTimeInMilliseconds$$, void 0 === $movementVector$$ ? null : $movementVector$$);
    (this.faceAxisOnMove & OBJECT_FACE_DIRECTION.XAXIS) === OBJECT_FACE_DIRECTION.XAXIS && 0 !== this.direction.x && this.sprite.mirror(this.direction.x === this._directionBasis.x).rotate();
    (this.faceAxisOnMove & OBJECT_FACE_DIRECTION.YAXIS) === OBJECT_FACE_DIRECTION.YAXIS && 0 !== this.direction.y && this.sprite.rotate(this.direction.y === this._directionBasis.y ? Math.PI_2 : -Math.PI_2);
    return this;
  };
  hamonengine.entities.spriteObject.prototype.reset = function $hamonengine$entities$spriteObject$$reset$() {
    return this.sprite.rotate().mirror(!1);
  };
  hamonengine.entities.spriteObject.prototype.isCollision = function $hamonengine$entities$spriteObject$$isCollision$($spriteObject$$) {
    if (this.isSolid) {
      var $direction$$ = new hamonengine.math.vector2;
      $spriteObject$$ instanceof hamonengine.entities.shapeObject && $spriteObject$$.isSolid && ($direction$$ = $spriteObject$$.position.subtract(this.position), $spriteObject$$ = $spriteObject$$.shape.translate($spriteObject$$.position));
      return hamonengine.entities.object2d.prototype.isCollision.call(this, $spriteObject$$, $direction$$);
    }
    return new hamonengine.math.vector2;
  };
  hamonengine.entities.spriteObject.prototype.render = function $hamonengine$entities$spriteObject$$render$($layer$$, $elapsedTimeInMilliseconds$$) {
    this.sprite && this.sprite.draw($layer$$, $elapsedTimeInMilliseconds$$, this.position.x, this.position.y, this.width, this.height);
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.spriteObject.prototype, {sprite:{configurable:!0, enumerable:!0, get:function() {
    return this._sprite;
  }, set:function($v$$) {
    this._sprite = $v$$;
  }}, faceAxisOnMove:{configurable:!0, enumerable:!0, get:function() {
    return this._faceAxisOnMove;
  }, set:function($v$$) {
    this._faceAxisOnMove = $v$$;
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.shapeObject = function $hamonengine$entities$shapeObject$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.entities.object2d.call(this, $options$$);
    $options$$ instanceof hamonengine.entities.shapeObject && ($options$$ = {shape:$options$$._shape});
    this._shape = $options$$.shape || new hamonengine.geometry.rect;
    this._faceAxisOnMove = void 0 !== $options$$.faceAxisOnMove ? $options$$.faceAxisOnMove : OBJECT_FACE_DIRECTION.XAXIS | OBJECT_FACE_DIRECTION.YAXIS;
    this._boundingShape = (this._hasBoundingShape = $options$$.boundingShape) || this._shape;
    this._directionBasis = $options$$.directionBasis || new hamonengine.math.vector2(-1, -1);
    this._mirroredState = !1;
    hamonengine.debug && !this._hasBoundingShape && console.debug("[hamonengine.entities.shapeObject.constructor] BoundingShape not found, using shape dimensions.");
  };
  $jscomp.inherits(hamonengine.entities.shapeObject, hamonengine.entities.object2d);
  hamonengine.entities.shapeObject.prototype.reset = function $hamonengine$entities$shapeObject$$reset$() {
    this._mirroredState = !1;
    return hamonengine.entities.object2d.prototype.reset.call(this);
  };
  hamonengine.entities.shapeObject.prototype.addVertex = function $hamonengine$entities$shapeObject$$addVertex$($x$$, $y$$) {
    (this.isPolygon ? this._shape : this._shape = this._shape.toPolygon()).addVertex($x$$, $y$$);
    return this;
  };
  hamonengine.entities.shapeObject.prototype.move = function $hamonengine$entities$shapeObject$$move$($elapsedTimeInMilliseconds$$, $movementVector$$) {
    hamonengine.entities.object2d.prototype.move.call(this, $elapsedTimeInMilliseconds$$, void 0 === $movementVector$$ ? null : $movementVector$$);
    this.isPolygon && ((this.faceAxisOnMove & OBJECT_FACE_DIRECTION.XAXIS) === OBJECT_FACE_DIRECTION.XAXIS && 0 !== this.direction.x && (this._mirroredState = this.direction.x === this._directionBasis.x, this.theta = 0), (this.faceAxisOnMove & OBJECT_FACE_DIRECTION.YAXIS) === OBJECT_FACE_DIRECTION.YAXIS && 0 !== this.direction.y && (this.theta = this.direction.y === this._directionBasis.y ? Math.PI_2 : -Math.PI_2));
    return this;
  };
  hamonengine.entities.shapeObject.prototype.transformShape = function $hamonengine$entities$shapeObject$$transformShape$($elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$) {
    this.theta = (this.theta + this.isHoldRotate * $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$ / 1000 * Math.PI / 4) % Math.PI2;
    this.scale += this.isHoldScale * $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$ / 1000 * 0.10;
    $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$ = this.shape.translate(this.position);
    return this.isPolygon ? ($elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$ = $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$.mirror ? $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$.mirror(this._mirroredState) : $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$, $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$ = $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$.rotateAtCenter ? 
    $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$.rotateAtCenter(this.theta) : $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$, $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$.scaleAtCenter ? $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$.scaleAtCenter(new hamonengine.math.vector2(this.scale, this.scale)) : $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$) : 
    $elapsedTimeInMilliseconds$jscomp$10_mirror_rotation$jscomp$4_translation$$;
  };
  hamonengine.entities.shapeObject.prototype.isCollision = function $hamonengine$entities$shapeObject$$isCollision$($shapeObject$$) {
    if (this.isSolid) {
      var $direction$$ = new hamonengine.math.vector2;
      $shapeObject$$ instanceof hamonengine.entities.shapeObject && $shapeObject$$.isSolid && ($direction$$ = $shapeObject$$.position.subtract(this.position), $shapeObject$$ = $shapeObject$$.shape.translate($shapeObject$$.position));
      return hamonengine.entities.object2d.prototype.isCollision.call(this, $shapeObject$$, $direction$$);
    }
    return new hamonengine.math.vector2;
  };
  hamonengine.entities.shapeObject.prototype.render = function $hamonengine$entities$shapeObject$$render$($layer$$, $elapsedTimeInMilliseconds$$, $$jscomp$destructuring$var45_lineWidth$$) {
    var $$jscomp$destructuring$var46_drawNormals$$ = void 0 === $$jscomp$destructuring$var45_lineWidth$$ ? {} : $$jscomp$destructuring$var45_lineWidth$$;
    $$jscomp$destructuring$var45_lineWidth$$ = void 0 === $$jscomp$destructuring$var46_drawNormals$$.lineWidth ? 2 : $$jscomp$destructuring$var46_drawNormals$$.lineWidth;
    var $color$$ = void 0 === $$jscomp$destructuring$var46_drawNormals$$.color ? "blue" : $$jscomp$destructuring$var46_drawNormals$$.color;
    $$jscomp$destructuring$var46_drawNormals$$ = void 0 === $$jscomp$destructuring$var46_drawNormals$$.drawNormals ? !1 : $$jscomp$destructuring$var46_drawNormals$$.drawNormals;
    this.shape && $layer$$.drawShape(this.transformShape($elapsedTimeInMilliseconds$$), 0, 0, {lineWidth:$$jscomp$destructuring$var45_lineWidth$$, color:$color$$, drawNormals:$$jscomp$destructuring$var46_drawNormals$$});
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.shapeObject.prototype, {shape:{configurable:!0, enumerable:!0, get:function() {
    return this._shape;
  }, set:function($v$$) {
    this._shape = $v$$;
    this._hasBoundingShape || (this._boundingShape = this.shape);
  }}, faceAxisOnMove:{configurable:!0, enumerable:!0, get:function() {
    return this._faceAxisOnMove;
  }, set:function($v$$) {
    this._faceAxisOnMove = $v$$;
  }}, isPolygon:{configurable:!0, enumerable:!0, get:function() {
    return this.shape instanceof hamonengine.geometry.polygon;
  }}, isRect:{configurable:!0, enumerable:!0, get:function() {
    return this.shape instanceof hamonengine.geometry.rect;
  }}, isLine:{configurable:!0, enumerable:!0, get:function() {
    return this.shape instanceof hamonengine.geometry.lineSegment;
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.cell = function $hamonengine$entities$cell$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.entities.object2d.call(this, $options$$);
    this._movementRate = 0;
    this._direction = new hamonengine.math.vector2;
    this._theta = 0;
    this._children = [];
    this._objects = [];
    this._zIndexSorter = new hamonengine.util.sort({compareFunc:function($a$$, $b$$) {
      return $a$$ === $b$$ ? 0 : $a$$.zIndex < $b$$.zIndex ? -1 : 1;
    }});
  };
  $jscomp.inherits(hamonengine.entities.cell, hamonengine.entities.object2d);
  hamonengine.entities.cell.prototype.addChild = function $hamonengine$entities$cell$$addChild$($child$$) {
    this._children.push($child$$);
  };
  hamonengine.entities.cell.prototype.addObject = function $hamonengine$entities$cell$$addObject$($object$$) {
    this._objects.push($object$$);
  };
  hamonengine.entities.cell.prototype.addObjects = function $hamonengine$entities$cell$$addObjects$($objects$$) {
    for (var $i$$ = 0; $i$$ < $objects$$.length; $i$$++) {
      this._objects.push($objects$$[$i$$]);
    }
  };
  hamonengine.entities.cell.prototype.process = function $hamonengine$entities$cell$$process$($elapsedTimeInMilliseconds$$) {
    if (this.objects) {
      for (var $collisionsEdges$$ = new Set, $i$$ = 0; $i$$ < this.objects.length; $i$$++) {
        var $object$$ = this.objects[$i$$];
        if ($object$$.isMovable && ($object$$.move($elapsedTimeInMilliseconds$$), this.isSolid)) {
          var $adjustedPosition_i$28$$ = hamonengine.math.vector2.clone($object$$.position), $collisionVector_siblingObject$$ = this.isContained($object$$);
          0 > $collisionVector_siblingObject$$.x ? $adjustedPosition_i$28$$.x = this.boundingShape.x - $object$$.boundingShape.x : 0 < $collisionVector_siblingObject$$.x && ($adjustedPosition_i$28$$.x = this.boundingShape.width - $object$$.boundingShape.right);
          0 > $collisionVector_siblingObject$$.y ? $adjustedPosition_i$28$$.y = this.boundingShape.y - $object$$.boundingShape.y : 0 < $collisionVector_siblingObject$$.y && ($adjustedPosition_i$28$$.y = this.boundingShape.height - $object$$.boundingShape.bottom);
          if (!$object$$.onEnvironmentCollision($adjustedPosition_i$28$$, this)) {
            break;
          }
        }
        for ($adjustedPosition_i$28$$ = 0; $adjustedPosition_i$28$$ < this.objects.length; $adjustedPosition_i$28$$++) {
          if ($collisionVector_siblingObject$$ = this.objects[$adjustedPosition_i$28$$], $object$$ !== $collisionVector_siblingObject$$) {
            var $edgeName$$ = $object$$.name + "->" + $collisionVector_siblingObject$$.name;
            $collisionsEdges$$.has($edgeName$$) || (console.log($object$$.isCollision($collisionVector_siblingObject$$)), $collisionsEdges$$.add($edgeName$$), $collisionsEdges$$.add($collisionVector_siblingObject$$.name + "->" + $object$$.name));
          }
        }
      }
    }
  };
  hamonengine.entities.cell.prototype.render = function $hamonengine$entities$cell$$render$($layer$$, $elapsedTimeInMilliseconds$$) {
    if (this.objects && (this._zIndexSorter.quickSort(this._objects), this.objects)) {
      for (var $i$$ = 0; $i$$ < this.objects.length; $i$$++) {
        this.objects[$i$$].render($layer$$, $elapsedTimeInMilliseconds$$);
      }
    }
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.cell.prototype, {children:{configurable:!0, enumerable:!0, get:function() {
    return this._children;
  }}, objects:{configurable:!0, enumerable:!0, get:function() {
    return this._objects;
  }}});
})();
hamonengine.events = hamonengine.events || {};
(function() {
  hamonengine.events.frame = function $hamonengine$events$frame$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.events.frame && (console.log($options$$._name), $options$$ = {name:$options$$._name, parent:$options$$._parent, first:$options$$._first, last:$options$$._last, top:$options$$._top}, console.log($options$$));
    this._parent = $options$$.parent || null;
    this._first = $options$$.first || null;
    this._last = $options$$.last || null;
    this._top = $options$$.top || null;
    this._name = $options$$.name || "";
    this._prev = this._next = null;
    hamonengine.debug && console.debug("[hamonengine.events.frame.constructor] Name: " + this._name);
  };
  hamonengine.events.frame.prototype.clone = function $hamonengine$events$frame$$clone$($$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$) {
    $$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$ = void 0 === $$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$ ? {} : $$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$;
    var $node$jscomp$6_parent$$ = $$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$.parent;
    $$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$ = $$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$.top;
    var $$jscomp$nullish$tmp0_newNode$$;
    $$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$ = null != ($$jscomp$nullish$tmp0_newNode$$ = $$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$) ? $$jscomp$nullish$tmp0_newNode$$ : $node$jscomp$6_parent$$;
    $$jscomp$nullish$tmp0_newNode$$ = new hamonengine.events.frame({name:this.name + "-cloned", parent:$node$jscomp$6_parent$$, top:$$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$});
    for ($node$jscomp$6_parent$$ = this.first; null != $node$jscomp$6_parent$$;) {
      $$jscomp$nullish$tmp0_newNode$$.append($node$jscomp$6_parent$$.clone({parent:$$jscomp$nullish$tmp0_newNode$$, top:$$jscomp$destructuring$var47_$jscomp$destructuring$var48_top$$})), $node$jscomp$6_parent$$ = $node$jscomp$6_parent$$.next;
    }
    return $$jscomp$nullish$tmp0_newNode$$;
  };
  hamonengine.events.frame.prototype.load = function $hamonengine$events$frame$$load$() {
    var $$jscomp$async$this$$ = this, $nodePromises$$, $parentNodePromise$$, $node$$, $nodePromise$$;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      $nodePromises$$ = [];
      $parentNodePromise$$ = $$jscomp$async$this$$.onLoadResources();
      if (!($parentNodePromise$$ instanceof Promise)) {
        return $$jscomp$generator$context$$.jumpTo(0);
      }
      $nodePromises$$.push($parentNodePromise$$);
      for ($node$$ = $$jscomp$async$this$$.first; null !== $node$$;) {
        $nodePromise$$ = $node$$.load(), $nodePromise$$ instanceof Promise && $nodePromises$$.push($nodePromise$$), $node$$ = $node$$.next;
      }
      return $$jscomp$generator$context$$.yield(Promise.all($nodePromises$$), 0);
    });
  };
  hamonengine.events.frame.prototype.append = function $hamonengine$events$frame$$append$($frame$$) {
    var $$jscomp$nullish$tmp1$$;
    $frame$$._top = null != ($$jscomp$nullish$tmp1$$ = this.top) ? $$jscomp$nullish$tmp1$$ : this;
    $frame$$._parent = this;
    this.last ? ($frame$$._prev = this.last, this._last = this._last._next = $frame$$) : this._first = this._last = $frame$$;
  };
  hamonengine.events.frame.prototype.prepend = function $hamonengine$events$frame$$prepend$($frame$$) {
    var $$jscomp$nullish$tmp2$$;
    $frame$$._top = null != ($$jscomp$nullish$tmp2$$ = this.top) ? $$jscomp$nullish$tmp2$$ : this;
    $frame$$._parent = this;
    this.first ? ($frame$$._next = this.first, this._first = this._first._prev = $frame$$) : this._first = this._last = $frame$$;
  };
  hamonengine.events.frame.prototype.__internalClear = function $hamonengine$events$frame$$__internalClear$($clearAll$$) {
    for (var $node$$ = this.first; null !== $node$$;) {
      var $nextNode$$ = $node$$.next;
      $node$$._prev = $node$$._next = $node$$._parent = null;
      $clearAll$$ && $node$$.clear();
      $node$$ = $nextNode$$;
    }
    this._first = this._last = null;
    $clearAll$$ && this.onRelease();
  };
  hamonengine.events.frame.prototype.clear = function $hamonengine$events$frame$$clear$() {
    this.__internalClear(!0);
  };
  hamonengine.events.frame.prototype.empty = function $hamonengine$events$frame$$empty$() {
    this.__internalClear(!1);
  };
  hamonengine.events.frame.prototype.findAncestorByName = function $hamonengine$events$frame$$findAncestorByName$($name$$) {
    for (var $node$$ = this.parent; null !== $node$$ && $node$$.name.toLowerCase() !== $name$$.toLowerCase();) {
      $node$$ = $node$$.parent;
    }
    return $node$$;
  };
  hamonengine.events.frame.searchByPredicate = function $hamonengine$events$frame$searchByPredicate$($node$$, $predicate$$) {
    for (; $predicate$$ && $predicate$$($node$$);) {
      $node$$ = $node$$.next;
    }
    return $node$$;
  };
  hamonengine.events.frame.prototype.findChildByName = function $hamonengine$events$frame$$findChildByName$($name$$) {
    return hamonengine.events.frame.searchByPredicate(this.first, function($node$$) {
      return null !== $node$$ && $node$$.name.toLowerCase() !== $name$$.toLowerCase();
    });
  };
  hamonengine.events.frame.prototype.findChildByIndex = function $hamonengine$events$frame$$findChildByIndex$($index$$) {
    var $currentIndex$$ = 0;
    return hamonengine.events.frame.searchByPredicate(this.first, function($node$$) {
      return null !== $node$$ && 0 < $index$$ && $currentIndex$$++ < $index$$;
    });
  };
  hamonengine.events.frame.findLast = function $hamonengine$events$frame$findLast$($node$jscomp$0$$) {
    return hamonengine.events.frame.searchByPredicate($node$jscomp$0$$, function($node$$) {
      return null !== $node$$ && null !== $node$$.next;
    });
  };
  hamonengine.events.frame.prototype.onLoadResources = function $hamonengine$events$frame$$onLoadResources$() {
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      $$jscomp$generator$context$$.jumpToEnd();
    });
  };
  hamonengine.events.frame.prototype.onAction = function $hamonengine$events$frame$$onAction$($elapsedTimeInMilliseconds$$, $parentFrame$$, $engine$$) {
  };
  hamonengine.events.frame.prototype.onRelease = function $hamonengine$events$frame$$onRelease$() {
  };
  $jscomp.global.Object.defineProperties(hamonengine.events.frame.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, first:{configurable:!0, enumerable:!0, get:function() {
    return this._first;
  }}, last:{configurable:!0, enumerable:!0, get:function() {
    return this._last;
  }}, next:{configurable:!0, enumerable:!0, get:function() {
    return this._next;
  }, set:function($v$$) {
    this._next = $v$$;
  }}, prev:{configurable:!0, enumerable:!0, get:function() {
    return this._prev;
  }, set:function($v$$) {
    this._prev = $v$$;
  }}, parent:{configurable:!0, enumerable:!0, get:function() {
    return this._parent;
  }}, top:{configurable:!0, enumerable:!0, get:function() {
    return this._top;
  }}});
})();
hamonengine.events = hamonengine.events || {};
(function() {
  hamonengine.events.storyboard = function $hamonengine$events$storyboard$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.events.frame.call(this, $options$$);
    $options$$ instanceof hamonengine.events.storyboard && ($options$$ = {engine:$options$$._engine, currentTopFrame:$options$$._currentTopFrame});
    this._engine = $options$$.engine;
    this._currentTopFrame = $options$$.currentTopFrame;
  };
  $jscomp.inherits(hamonengine.events.storyboard, hamonengine.events.frame);
  hamonengine.events.storyboard.prototype.clone = function $hamonengine$events$storyboard$$clone$() {
    return new hamonengine.events.storyboard({engine:this.engine, currentTopFrame:this.currentTopFrame.clone()});
  };
  hamonengine.events.storyboard.prototype.load = function $hamonengine$events$storyboard$$load$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      if (1 == $$jscomp$generator$context$$.nextAddress) {
        return $$jscomp$generator$context$$.yield($$jscomp$async$this$$.onloadResources(), 2);
      }
      if (3 != $$jscomp$generator$context$$.nextAddress) {
        return $$jscomp$generator$context$$.yield($$jscomp$async$this$$.currentTopFrame, 3);
      }
      $$jscomp$generator$context$$.yieldResult && $$jscomp$async$this$$.currentTopFrame.load();
      $$jscomp$generator$context$$.jumpToEnd();
    });
  };
  hamonengine.events.storyboard.prototype.start = function $hamonengine$events$storyboard$$start$($elapsedTimeInMilliseconds$$) {
    this._currentTopFrame && this._currentTopFrame.onAction($elapsedTimeInMilliseconds$$, this, this._engine);
  };
  hamonengine.events.storyboard.prototype.stop = function $hamonengine$events$storyboard$$stop$() {
    this._currentTopFrame && this._currentTopFrame.clear();
  };
  hamonengine.events.storyboard.prototype.onloadResources = function $hamonengine$events$storyboard$$onloadResources$() {
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      hamonengine.debug && console.debug("[hamonengine.events.storyboard.onloadResources]");
      $$jscomp$generator$context$$.jumpToEnd();
    });
  };
  $jscomp.global.Object.defineProperties(hamonengine.events.storyboard.prototype, {currentTopFrame:{configurable:!0, enumerable:!0, get:function() {
    return this._currentTopFrame;
  }}});
})();
hamonengine.core = hamonengine.core || {};
(function() {
  var $ENGINE_STATES_NAMES$$ = ["STOPPED", "STARTED", "LOADING", "RUNNING"];
  hamonengine.core.engine = function $hamonengine$core$engine$($options$$) {
    var $$jscomp$this$$ = this;
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    console.log("HamonEngine -- Using version: 0.2.0");
    this._movementRate = $options$$.movementRate || 0.25;
    this._size = $options$$.size || 64;
    this._showFPS = void 0 !== $options$$.showFPS ? $options$$.showFPS : !1;
    this._syncFrames = void 0 !== $options$$.syncFrames ? $options$$.syncFrames : !1;
    this._splashScreenWait = void 0 !== $options$$.splashScreenWait ? $options$$.splashScreenWait : 500;
    this._detectCanvas = void 0 !== $options$$.detectCanvas ? $options$$.detectCanvas : !0;
    this._allowDocumentEventBinding = void 0 !== $options$$.allowDocumentEventBinding ? $options$$.allowDocumentEventBinding : !1;
    this._captureTouchAsMouseEvents = void 0 !== $options$$.captureTouchAsMouseEvents ? $options$$.captureTouchAsMouseEvents : !0;
    var $blockArrowKeys_canvasCollection$$ = void 0 !== $options$$.blockArrowKeys ? $options$$.blockArrowKeys : !0;
    this._preventDefaultState = 0;
    this._preventDefaultState |= $options$$.blockAllKeys ? 1 : 0;
    this._preventDefaultState |= $blockArrowKeys_canvasCollection$$ ? 2 : 0;
    this._externalElements = $options$$.externalElements || [];
    this._animationId = this._lastFrameTimeStamp = this._startTimeStamp = this._state = 0;
    this._fpsCounter = new fpscounter;
    this._layers = {};
    $blockArrowKeys_canvasCollection$$ = $options$$.canvas || [];
    if (this._detectCanvas && 0 === $blockArrowKeys_canvasCollection$$.length) {
      hamonengine.debug && console.debug("[hamonengine.core.engine.constructor] DetectCanvas: true.  Attempting to detect all canvas."), Object.entries(document.getElementsByTagName("canvas")).forEach(function($$jscomp$destructuring$var49_canvasName$jscomp$1_key$$) {
        var $$jscomp$destructuring$var50_value$$ = $jscomp.makeIterator($$jscomp$destructuring$var49_canvasName$jscomp$1_key$$);
        $$jscomp$destructuring$var49_canvasName$jscomp$1_key$$ = $$jscomp$destructuring$var50_value$$.next().value;
        $$jscomp$destructuring$var50_value$$ = $$jscomp$destructuring$var50_value$$.next().value;
        $$jscomp$destructuring$var49_canvasName$jscomp$1_key$$ = $$jscomp$destructuring$var50_value$$.getAttribute("name") || "canvas" + $$jscomp$destructuring$var49_canvasName$jscomp$1_key$$;
        $$jscomp$this$$._layers[$$jscomp$destructuring$var49_canvasName$jscomp$1_key$$] = new hamonengine.graphics.layer({name:$$jscomp$destructuring$var49_canvasName$jscomp$1_key$$, canvas:$$jscomp$destructuring$var50_value$$, allowEventBinding:$$jscomp$destructuring$var50_value$$.dataset.alloweventbinding, enableImageSmoothing:$$jscomp$destructuring$var50_value$$.dataset.enableimagesmoothing, clipToViewPort:$$jscomp$destructuring$var50_value$$.dataset.cliptoviewport});
      });
    } else {
      hamonengine.debug && console.debug("[hamonengine.core.engine.constructor] DetectCanvas: false.  Using collection of options.canvas.");
      for (var $index$$ = 0, $i$$ = 0; $i$$ < $blockArrowKeys_canvasCollection$$.length; $i$$++) {
        var $canvas$$ = $blockArrowKeys_canvasCollection$$[$i$$], $canvasName$$ = $canvas$$.name || "canvas" + $index$$++;
        this._layers[$canvasName$$] = new hamonengine.graphics.layer({name:$canvasName$$, canvasId:$canvas$$.id, viewPort:$canvas$$.viewPort, allowEventBinding:$canvas$$.allowEventBinding, enableImageSmoothing:$options$$.enableImageSmoothing, clipToViewPort:$canvas$$.clipToViewPort});
      }
    }
    this._resourcesLoaded = !1;
    hamonengine.debug && (console.debug("[hamonengine.core.engine.constructor] MovementRate: " + this._movementRate), console.debug("[hamonengine.core.engine.constructor] State: " + $ENGINE_STATES_NAMES$$[this._state]), console.debug("[hamonengine.core.engine.constructor] SyncFrames: " + (this.syncFrames ? "Enabled" : "Disabled")), console.debug("[hamonengine.core.engine.constructor] SplashScreen Wait Time: " + this._splashScreenWait + " milliseconds."), console.debug("[hamonengine.core.engine.constructor] Global States"), 
    console.debug("[hamonengine.core.engine.constructor] hamonengine.geometry.settings.collisionDetection.floor: " + hamonengine.geometry.settings.collisionDetection.floor), console.debug("[hamonengine.core.engine.constructor] hamonengine.geometry.settings.collisionDetection.limit: " + hamonengine.geometry.settings.collisionDetection.limit), console.debug("[hamonengine.core.engine.constructor] hamonengine.geometry.settings.coordinateSystem: " + hamonengine.geometry.settings.coordinateSystem));
  };
  hamonengine.core.engine.prototype.getLayer = function $hamonengine$core$engine$$getLayer$($name$$) {
    return this._layers[$name$$];
  };
  hamonengine.core.engine.prototype.load = function $hamonengine$core$engine$$load$() {
    var $$jscomp$async$this$$ = this, $preloadPromise$$, $eventBindingPromise$$, $loadingResource$$, $error$$;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      switch($$jscomp$generator$context$$.nextAddress) {
        case 1:
          hamonengine.debug && console.debug("[hamonengine.core.engine.load]");
          $preloadPromise$$ = new Promise(function($resolve$$) {
            $$jscomp$async$this$$.onPreload() ? setTimeout(function() {
              return $resolve$$();
            }, $$jscomp$async$this$$._splashScreenWait) : $resolve$$();
          });
          $$jscomp$async$this$$._state = 2;
          console.log("[hamonengine.core.engine.load] State: " + $ENGINE_STATES_NAMES$$[$$jscomp$async$this$$._state]);
          $$jscomp$generator$context$$.setCatchFinallyBlocks(2);
          $eventBindingPromise$$ = $$jscomp$async$this$$.onEventBinding();
          if (!($eventBindingPromise$$ instanceof Promise)) {
            throw "onEventBinding is not returning a promise!  This event must return an unhandled promise.";
          }
          console.log("%c[hamonengine.core.engine.load] Engine is paused, waiting for event binding to resolve...", "color: yellow");
          return $$jscomp$generator$context$$.yield($eventBindingPromise$$, 4);
        case 4:
          console.log("%c[hamonengine.core.engine.load] Engine has resumed loading, event binding has completed.", "color: green");
          $loadingResource$$ = $$jscomp$async$this$$.onloadResources();
          if (!($loadingResource$$ instanceof Promise)) {
            throw "onloadResources is not returning a promise!  This event must return an unhandled promise.";
          }
          console.log("%c[hamonengine.core.engine.load] Engine is paused, waiting for resources to resolve...", "color: yellow");
          return $$jscomp$generator$context$$.yield($loadingResource$$, 5);
        case 5:
          return $$jscomp$async$this$$._resourcesLoaded = !0, console.log("%c[hamonengine.core.engine.load] Engine has resumed loading, resource loading completed.", "color: green"), console.log("%c[hamonengine.core.engine.load] Engine is paused, waiting for preload event to resolve...", "color: yellow"), $$jscomp$generator$context$$.yield($preloadPromise$$, 6);
        case 6:
          console.log("%c[hamonengine.core.engine.load] Preload completed.", "color: green");
          $$jscomp$generator$context$$.leaveTryBlock(3);
          break;
        case 2:
          $error$$ = $$jscomp$generator$context$$.enterCatchBlock(), console.error("[hamonengine.core.engine.load] Resources could not be loaded due to a failure! Stopping the engine."), console.error($error$$), $$jscomp$async$this$$.stop({reasons:"A critical error occured during resource loading."});
        case 3:
          return $$jscomp$generator$context$$.return($$jscomp$async$this$$);
      }
    });
  };
  hamonengine.core.engine.prototype.start = function $hamonengine$core$engine$$start$() {
    hamonengine.debug && console.debug("[hamonengine.core.engine.start]");
    2 === this._state && (this._state = 1, console.log("[hamonengine.core.engine.start] State: " + $ENGINE_STATES_NAMES$$[this._state]), this.fpsCounter.start(), this.onDraw(0));
    return this;
  };
  hamonengine.core.engine.prototype.stop = function $hamonengine$core$engine$$stop$($$jscomp$destructuring$var51_reasons$$) {
    $$jscomp$destructuring$var51_reasons$$ = (void 0 === $$jscomp$destructuring$var51_reasons$$ ? {reasons:"Stopped By User"} : $$jscomp$destructuring$var51_reasons$$).reasons;
    hamonengine.debug && console.debug("[hamonengine.core.engine.stop]");
    window.cancelAnimationFrame(this._animationId);
    this._state = this._startTimeStamp = this._animationId = 0;
    console.log("[hamonengine.core.engine.stop] State: " + $ENGINE_STATES_NAMES$$[this._state]);
    this.onStop($$jscomp$destructuring$var51_reasons$$);
    return this;
  };
  hamonengine.core.engine.prototype.onPreload = function $hamonengine$core$engine$$onPreload$() {
    hamonengine.debug && console.debug("[hamonengine.core.engine.onPreload]");
    return !1;
  };
  hamonengine.core.engine.prototype.onloadResources = function $hamonengine$core$engine$$onloadResources$() {
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      hamonengine.debug && console.debug("[hamonengine.core.engine.onloadResources]");
      return $$jscomp$generator$context$$.return(Promise.resolve());
    });
  };
  hamonengine.core.engine.prototype.onEventBinding = function $hamonengine$core$engine$$onEventBinding$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.asyncExecutePromiseGeneratorProgram(function($$jscomp$generator$context$$) {
      return $$jscomp$generator$context$$.return(new Promise(function($resolve$$, $reject$$) {
        window.addEventListener("DOMContentLoaded", function($event$$) {
          var $touchEventMap$$ = new Map, $bindEvents$$ = function $$bindEvents$$$($elementToBind$$, $eventContainer$$) {
            var $keyEvent$$ = function $$keyEvent$$$($type$$, $e$$) {
              $$jscomp$async$this$$.onKeyEvent($type$$, $e$$.code, $e$$, $eventContainer$$);
              $e$$ && ($$jscomp$async$this$$.blockByDefaultAllKeys ? $e$$.preventDefault() : $$jscomp$async$this$$.blockByDefaultArrowKeys && ("ArrowLeft" === $e$$.code || "ArrowRight" === $e$$.code || "ArrowUp" === $e$$.code || "ArrowDown" === $e$$.code) && $e$$.preventDefault());
            }, $mouseEvent$$ = function $$mouseEvent$$$($type$$, $e$$) {
              var $v$$ = new hamonengine.math.vector2($e$$.offsetX, $e$$.offsetY);
              $$jscomp$async$this$$.onMouseEvent($type$$, $v$$, $e$$, $eventContainer$$);
            }, $touchEvent$$ = function $$touchEvent$$$($type$$, $e$$) {
              var $isClick_lasttouchevent$$ = $touchEventMap$$.has($eventContainer$$.name) ? $touchEventMap$$.get($eventContainer$$.name) : "";
              $touchEventMap$$.set($eventContainer$$.name, $type$$);
              var $position$jscomp$2_v$$ = $eventContainer$$.position;
              if ($position$jscomp$2_v$$) {
                for (var $touches$$ = [], $i$$ = 0; $i$$ < $e$$.touches.length; $i$$++) {
                  $touches$$.push(new hamonengine.math.vector2($e$$.touches[$i$$].clientX - $position$jscomp$2_v$$.x, $e$$.touches[$i$$].clientY - $position$jscomp$2_v$$.y));
                }
                $isClick_lasttouchevent$$ = "end" === $type$$ && "start" === $isClick_lasttouchevent$$;
                $$jscomp$async$this$$.onTouchEvent($type$$, $touches$$, $e$$, $eventContainer$$);
                $isClick_lasttouchevent$$ && $$jscomp$async$this$$.onTouchEvent("click", $touches$$, $e$$, $eventContainer$$);
                $$jscomp$async$this$$.captureTouchAsMouseEvents && ($type$$ = "start" === $type$$ ? "down" : $type$$, $type$$ = "end" === $type$$ ? "up" : $type$$, $position$jscomp$2_v$$ = new hamonengine.math.vector2($e$$.changedTouches[0].clientX - $position$jscomp$2_v$$.x, $e$$.changedTouches[0].clientY - $position$jscomp$2_v$$.y), $$jscomp$async$this$$.onMouseEvent($type$$, $position$jscomp$2_v$$, $e$$, $eventContainer$$), $isClick_lasttouchevent$$ && $$jscomp$async$this$$.onMouseEvent("click", 
                $position$jscomp$2_v$$, $e$$, $eventContainer$$));
              }
            };
            $elementToBind$$.addEventListener("keyup", function($e$$) {
              return $keyEvent$$("up", $e$$);
            });
            $elementToBind$$.addEventListener("keydown", function($e$$) {
              return $keyEvent$$("down", $e$$);
            });
            $elementToBind$$.addEventListener("click", function($e$$) {
              return $mouseEvent$$("click", $e$$);
            });
            $elementToBind$$.addEventListener("mouseup", function($e$$) {
              return $mouseEvent$$("up", $e$$);
            });
            $elementToBind$$.addEventListener("mousedown", function($e$$) {
              return $mouseEvent$$("down", $e$$);
            });
            $elementToBind$$.addEventListener("mousemove", function($e$$) {
              return $mouseEvent$$("move", $e$$);
            });
            $elementToBind$$.addEventListener("mouseenter", function($e$$) {
              return $mouseEvent$$("enter", $e$$);
            });
            $elementToBind$$.addEventListener("mouseleave", function($e$$) {
              return $mouseEvent$$("leave", $e$$);
            });
            $elementToBind$$.addEventListener("touchstart", function($e$$) {
              return $touchEvent$$("start", $e$$);
            }, {passive:!1});
            $elementToBind$$.addEventListener("touchmove", function($e$$) {
              return $touchEvent$$("move", $e$$);
            }, {passive:!1});
            $elementToBind$$.addEventListener("touchend", function($e$$) {
              return $touchEvent$$("end", $e$$);
            }, {passive:!1});
            $elementToBind$$.addEventListener("touchcancel", function($e$$) {
              return $touchEvent$$("cancel", $e$$);
            }, {passive:!1});
          };
          $$jscomp$async$this$$.allowDocumentEventBinding && $bindEvents$$(document, $$jscomp$async$this$$);
          $$jscomp$async$this$$.externalElements.forEach(function($externalElement$$) {
            return $bindEvents$$($externalElement$$, $externalElement$$);
          });
          $$jscomp$async$this$$.layers.forEach(function($layer$$) {
            return $layer$$.allowEventBinding && $bindEvents$$($layer$$.canvas, $layer$$);
          });
        });
        $resolve$$();
      }));
    });
  };
  hamonengine.core.engine.prototype.onKeyEvent = function $hamonengine$core$engine$$onKeyEvent$($type$$, $keyCode$$, $e$$, $caller$$) {
    hamonengine.debug && console.debug("[hamonengine.core.engine.onKeyEvent] Type: '" + $type$$ + "' '" + $keyCode$$ + "'");
  };
  hamonengine.core.engine.prototype.onMouseEvent = function $hamonengine$core$engine$$onMouseEvent$($type$$, $v$$, $e$$, $caller$$) {
    hamonengine.debug && hamonengine.verbose && console.debug("[hamonengine.core.engine.onMouseEvent] Type: '" + $type$$ + "' '" + $v$$.toString() + "'");
  };
  hamonengine.core.engine.prototype.onTouchEvent = function $hamonengine$core$engine$$onTouchEvent$($type$$, $touches$$, $e$$, $caller$$) {
    $e$$ && $e$$.preventDefault();
    hamonengine.debug && hamonengine.verbose && console.debug("[hamonengine.core.engine.onTouchEvent] Type: '" + $type$$ + "' '" + $e$$ + "'");
  };
  hamonengine.core.engine.prototype.onDraw = function $hamonengine$core$engine$$onDraw$($timestampInMilliseconds$$) {
    var $$jscomp$this$$ = this;
    $timestampInMilliseconds$$ = $timestampInMilliseconds$$ || 0;
    this._startTimeStamp || (this._startTimeStamp = $timestampInMilliseconds$$);
    var $elapsedTimeInMilliseconds$$ = $timestampInMilliseconds$$ - this._lastFrameTimeStamp;
    try {
      var $processingComplete$$ = !1;
      setTimeout(function() {
        $$jscomp$this$$.onProcessingFrame($elapsedTimeInMilliseconds$$);
        $processingComplete$$ = !0;
      }, 1);
      this._animationId = window.requestAnimationFrame(function($scopedTimestampInMS$$) {
        $$jscomp$this$$._state = 3;
        $$jscomp$this$$.syncFrames && !$processingComplete$$ || $$jscomp$this$$.onFrame($elapsedTimeInMilliseconds$$);
        $$jscomp$this$$.onDraw($scopedTimestampInMS$$);
      });
    } catch ($exception$$) {
      this.stop(), hamonengine.debug && console.debug($exception$$);
    }
    this._lastFrameTimeStamp = $timestampInMilliseconds$$;
    return this;
  };
  hamonengine.core.engine.prototype.onFrame = function $hamonengine$core$engine$$onFrame$($elapsedTimeInMilliseconds$$) {
    return this;
  };
  hamonengine.core.engine.prototype.onProcessingFrame = function $hamonengine$core$engine$$onProcessingFrame$($elapsedTimeInMilliseconds$$) {
    return this;
  };
  hamonengine.core.engine.prototype.onStop = function $hamonengine$core$engine$$onStop$($reasons$$) {
    return this;
  };
  $jscomp.global.Object.defineProperties(hamonengine.core.engine.prototype, {primaryLayer:{configurable:!0, enumerable:!0, get:function() {
    return this._layers.canvas0;
  }}, resourcesLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._resourcesLoaded;
  }}, fpsCounter:{configurable:!0, enumerable:!0, get:function() {
    return this._fpsCounter;
  }}, layers:{configurable:!0, enumerable:!0, get:function() {
    return Object.values(this._layers);
  }}, externalElements:{configurable:!0, enumerable:!0, get:function() {
    return this._externalElements;
  }}, syncFrames:{configurable:!0, enumerable:!0, get:function() {
    return this._syncFrames;
  }, set:function($v$$) {
    this._syncFrames = $v$$;
  }}, allowDocumentEventBinding:{configurable:!0, enumerable:!0, get:function() {
    return this._allowDocumentEventBinding;
  }}, captureTouchAsMouseEvents:{configurable:!0, enumerable:!0, get:function() {
    return this._captureTouchAsMouseEvents;
  }, set:function($v$$) {
    this._captureTouchAsMouseEvents = $v$$;
  }}, blockByDefaultAllKeys:{configurable:!0, enumerable:!0, get:function() {
    return 1 === (this._preventDefaultState & 1);
  }, set:function($v$$) {
    this._preventDefaultState = $v$$ ? this._preventDefaultState | 1 : this._preventDefaultState ^ 1;
  }}, blockByDefaultArrowKeys:{configurable:!0, enumerable:!0, get:function() {
    return 2 === (this._preventDefaultState & 2);
  }, set:function($v$$) {
    this._preventDefaultState = $v$$ ? this._preventDefaultState | 2 : this._preventDefaultState ^ 2;
  }}});
})();

