/*
 Hamonengine 波紋
 Copyright \(c\) 2020-2022, CaffeinatedRat.
 All rights reserved.
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
 EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function($target$$, $property$$, $descriptor$$) {
  $target$$ != Array.prototype && $target$$ != Object.prototype && ($target$$[$property$$] = $descriptor$$.value);
};
$jscomp.getGlobal = function $$jscomp$getGlobal$($maybeGlobal$$) {
  return "undefined" != typeof window && window === $maybeGlobal$$ ? $maybeGlobal$$ : "undefined" != typeof global && null != global ? global : $maybeGlobal$$;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function $$jscomp$initSymbol$() {
  $jscomp.initSymbol = function $$jscomp$initSymbol$() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.symbolCounter_ = 0;
$jscomp.Symbol = function $$jscomp$Symbol$($opt_description$$) {
  return $jscomp.SYMBOL_PREFIX + ($opt_description$$ || "") + $jscomp.symbolCounter_++;
};
$jscomp.initSymbolIterator = function $$jscomp$initSymbolIterator$() {
  $jscomp.initSymbol();
  var $symbolIterator$$ = $jscomp.global.Symbol.iterator;
  $symbolIterator$$ || ($symbolIterator$$ = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[$symbolIterator$$] && $jscomp.defineProperty(Array.prototype, $symbolIterator$$, {configurable:!0, writable:!0, value:function() {
    return $jscomp.arrayIterator(this);
  }});
  $jscomp.initSymbolIterator = function $$jscomp$initSymbolIterator$() {
  };
};
$jscomp.arrayIterator = function $$jscomp$arrayIterator$($array$$) {
  var $index$$ = 0;
  return $jscomp.iteratorPrototype(function() {
    return $index$$ < $array$$.length ? {done:!1, value:$array$$[$index$$++]} : {done:!0};
  });
};
$jscomp.iteratorPrototype = function $$jscomp$iteratorPrototype$($iterator$$) {
  $jscomp.initSymbolIterator();
  $iterator$$ = {next:$iterator$$};
  $iterator$$[$jscomp.global.Symbol.iterator] = function $$iterator$$$$jscomp$global$Symbol$iterator$() {
    return this;
  };
  return $iterator$$;
};
$jscomp.makeIterator = function $$jscomp$makeIterator$($iterable$$) {
  $jscomp.initSymbolIterator();
  var $iteratorFunction$$ = $iterable$$[Symbol.iterator];
  return $iteratorFunction$$ ? $iteratorFunction$$.call($iterable$$) : $jscomp.arrayIterator($iterable$$);
};
$jscomp.polyfill = function $$jscomp$polyfill$($property$jscomp$5_split_target$$, $impl_polyfill$$, $fromLang_obj$$, $i$$) {
  if ($impl_polyfill$$) {
    $fromLang_obj$$ = $jscomp.global;
    $property$jscomp$5_split_target$$ = $property$jscomp$5_split_target$$.split(".");
    for ($i$$ = 0; $i$$ < $property$jscomp$5_split_target$$.length - 1; $i$$++) {
      var $key$$ = $property$jscomp$5_split_target$$[$i$$];
      $key$$ in $fromLang_obj$$ || ($fromLang_obj$$[$key$$] = {});
      $fromLang_obj$$ = $fromLang_obj$$[$key$$];
    }
    $property$jscomp$5_split_target$$ = $property$jscomp$5_split_target$$[$property$jscomp$5_split_target$$.length - 1];
    $i$$ = $fromLang_obj$$[$property$jscomp$5_split_target$$];
    $impl_polyfill$$ = $impl_polyfill$$($i$$);
    $impl_polyfill$$ != $i$$ && null != $impl_polyfill$$ && $jscomp.defineProperty($fromLang_obj$$, $property$jscomp$5_split_target$$, {configurable:!0, writable:!0, value:$impl_polyfill$$});
  }
};
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.polyfill("Promise", function($NativePromise$$) {
  function $AsyncExecutor$$() {
    this.batch_ = null;
  }
  function $resolvingPromise$$($opt_value$$) {
    return $opt_value$$ instanceof $PolyfillPromise$$ ? $opt_value$$ : new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $resolve$$($opt_value$$);
    });
  }
  if ($NativePromise$$ && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return $NativePromise$$;
  }
  $AsyncExecutor$$.prototype.asyncExecute = function $$AsyncExecutor$$$$asyncExecute$($f$$) {
    null == this.batch_ && (this.batch_ = [], this.asyncExecuteBatch_());
    this.batch_.push($f$$);
    return this;
  };
  $AsyncExecutor$$.prototype.asyncExecuteBatch_ = function $$AsyncExecutor$$$$asyncExecuteBatch_$() {
    var $self$$ = this;
    this.asyncExecuteFunction(function() {
      $self$$.executeBatch_();
    });
  };
  var $nativeSetTimeout$$ = $jscomp.global.setTimeout;
  $AsyncExecutor$$.prototype.asyncExecuteFunction = function $$AsyncExecutor$$$$asyncExecuteFunction$($f$$) {
    $nativeSetTimeout$$($f$$, 0);
  };
  $AsyncExecutor$$.prototype.executeBatch_ = function $$AsyncExecutor$$$$executeBatch_$() {
    for (; this.batch_ && this.batch_.length;) {
      var $executingBatch$$ = this.batch_;
      this.batch_ = [];
      for (var $i$$ = 0; $i$$ < $executingBatch$$.length; ++$i$$) {
        var $f$$ = $executingBatch$$[$i$$];
        delete $executingBatch$$[$i$$];
        try {
          $f$$();
        } catch ($error$$) {
          this.asyncThrow_($error$$);
        }
      }
    }
    this.batch_ = null;
  };
  $AsyncExecutor$$.prototype.asyncThrow_ = function $$AsyncExecutor$$$$asyncThrow_$($exception$$) {
    this.asyncExecuteFunction(function() {
      throw $exception$$;
    });
  };
  var $PolyfillPromise$$ = function $$PolyfillPromise$$$($executor$$) {
    this.state_ = 0;
    this.result_ = void 0;
    this.onSettledCallbacks_ = [];
    var $resolveAndReject$$ = this.createResolveAndReject_();
    try {
      $executor$$($resolveAndReject$$.resolve, $resolveAndReject$$.reject);
    } catch ($e$$) {
      $resolveAndReject$$.reject($e$$);
    }
  };
  $PolyfillPromise$$.prototype.createResolveAndReject_ = function $$PolyfillPromise$$$$createResolveAndReject_$() {
    function $firstCallWins$$($method$$) {
      return function($x$$) {
        $alreadyCalled$$ || ($alreadyCalled$$ = !0, $method$$.call($thisPromise$$, $x$$));
      };
    }
    var $thisPromise$$ = this, $alreadyCalled$$ = !1;
    return {resolve:$firstCallWins$$(this.resolveTo_), reject:$firstCallWins$$(this.reject_)};
  };
  $PolyfillPromise$$.prototype.resolveTo_ = function $$PolyfillPromise$$$$resolveTo_$($value$$) {
    if ($value$$ === this) {
      this.reject_(new TypeError("A Promise cannot resolve to itself"));
    } else {
      if ($value$$ instanceof $PolyfillPromise$$) {
        this.settleSameAsPromise_($value$$);
      } else {
        a: {
          switch(typeof $value$$) {
            case "object":
              var $JSCompiler_inline_result$$ = null != $value$$;
              break a;
            case "function":
              $JSCompiler_inline_result$$ = !0;
              break a;
            default:
              $JSCompiler_inline_result$$ = !1;
          }
        }
        $JSCompiler_inline_result$$ ? this.resolveToNonPromiseObj_($value$$) : this.fulfill_($value$$);
      }
    }
  };
  $PolyfillPromise$$.prototype.resolveToNonPromiseObj_ = function $$PolyfillPromise$$$$resolveToNonPromiseObj_$($obj$$) {
    var $thenMethod$$ = void 0;
    try {
      $thenMethod$$ = $obj$$.then;
    } catch ($error$$) {
      this.reject_($error$$);
      return;
    }
    "function" == typeof $thenMethod$$ ? this.settleSameAsThenable_($thenMethod$$, $obj$$) : this.fulfill_($obj$$);
  };
  $PolyfillPromise$$.prototype.reject_ = function $$PolyfillPromise$$$$reject_$($reason$$) {
    this.settle_(2, $reason$$);
  };
  $PolyfillPromise$$.prototype.fulfill_ = function $$PolyfillPromise$$$$fulfill_$($value$$) {
    this.settle_(1, $value$$);
  };
  $PolyfillPromise$$.prototype.settle_ = function $$PolyfillPromise$$$$settle_$($settledState$$, $valueOrReason$$) {
    if (0 != this.state_) {
      throw Error("Cannot settle(" + $settledState$$ + ", " + $valueOrReason$$ | "): Promise already settled in state" + this.state_);
    }
    this.state_ = $settledState$$;
    this.result_ = $valueOrReason$$;
    this.executeOnSettledCallbacks_();
  };
  $PolyfillPromise$$.prototype.executeOnSettledCallbacks_ = function $$PolyfillPromise$$$$executeOnSettledCallbacks_$() {
    if (null != this.onSettledCallbacks_) {
      for (var $callbacks$$ = this.onSettledCallbacks_, $i$$ = 0; $i$$ < $callbacks$$.length; ++$i$$) {
        $callbacks$$[$i$$].call(), $callbacks$$[$i$$] = null;
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var $asyncExecutor$$ = new $AsyncExecutor$$;
  $PolyfillPromise$$.prototype.settleSameAsPromise_ = function $$PolyfillPromise$$$$settleSameAsPromise_$($promise$$) {
    var $methods$$ = this.createResolveAndReject_();
    $promise$$.callWhenSettled_($methods$$.resolve, $methods$$.reject);
  };
  $PolyfillPromise$$.prototype.settleSameAsThenable_ = function $$PolyfillPromise$$$$settleSameAsThenable_$($thenMethod$$, $thenable$$) {
    var $methods$$ = this.createResolveAndReject_();
    try {
      $thenMethod$$.call($thenable$$, $methods$$.resolve, $methods$$.reject);
    } catch ($error$$) {
      $methods$$.reject($error$$);
    }
  };
  $PolyfillPromise$$.prototype.then = function $$PolyfillPromise$$$$then$($onFulfilled$$, $onRejected$$) {
    function $createCallback$$($paramF$$, $defaultF$$) {
      return "function" == typeof $paramF$$ ? function($x$$) {
        try {
          $resolveChild$$($paramF$$($x$$));
        } catch ($error$$) {
          $rejectChild$$($error$$);
        }
      } : $defaultF$$;
    }
    var $resolveChild$$, $rejectChild$$, $childPromise$$ = new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $resolveChild$$ = $resolve$$;
      $rejectChild$$ = $reject$$;
    });
    this.callWhenSettled_($createCallback$$($onFulfilled$$, $resolveChild$$), $createCallback$$($onRejected$$, $rejectChild$$));
    return $childPromise$$;
  };
  $PolyfillPromise$$.prototype.catch = function $$PolyfillPromise$$$$catch$($onRejected$$) {
    return this.then(void 0, $onRejected$$);
  };
  $PolyfillPromise$$.prototype.callWhenSettled_ = function $$PolyfillPromise$$$$callWhenSettled_$($onFulfilled$$, $onRejected$$) {
    function $callback$$() {
      switch($thisPromise$$.state_) {
        case 1:
          $onFulfilled$$($thisPromise$$.result_);
          break;
        case 2:
          $onRejected$$($thisPromise$$.result_);
          break;
        default:
          throw Error("Unexpected state: " + $thisPromise$$.state_);
      }
    }
    var $thisPromise$$ = this;
    null == this.onSettledCallbacks_ ? $asyncExecutor$$.asyncExecute($callback$$) : this.onSettledCallbacks_.push(function() {
      $asyncExecutor$$.asyncExecute($callback$$);
    });
  };
  $PolyfillPromise$$.resolve = $resolvingPromise$$;
  $PolyfillPromise$$.reject = function $$PolyfillPromise$$$reject$($opt_reason$$) {
    return new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $reject$$($opt_reason$$);
    });
  };
  $PolyfillPromise$$.race = function $$PolyfillPromise$$$race$($thenablesOrValues$$) {
    return new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      for (var $iterator$$ = $jscomp.makeIterator($thenablesOrValues$$), $iterRec$$ = $iterator$$.next(); !$iterRec$$.done; $iterRec$$ = $iterator$$.next()) {
        $resolvingPromise$$($iterRec$$.value).callWhenSettled_($resolve$$, $reject$$);
      }
    });
  };
  $PolyfillPromise$$.all = function $$PolyfillPromise$$$all$($thenablesOrValues$$) {
    var $iterator$$ = $jscomp.makeIterator($thenablesOrValues$$), $iterRec$$ = $iterator$$.next();
    return $iterRec$$.done ? $resolvingPromise$$([]) : new $PolyfillPromise$$(function($resolveAll$$, $rejectAll$$) {
      function $onFulfilled$$($i$$) {
        return function($ithResult$$) {
          $resultsArray$$[$i$$] = $ithResult$$;
          $unresolvedCount$$--;
          0 == $unresolvedCount$$ && $resolveAll$$($resultsArray$$);
        };
      }
      var $resultsArray$$ = [], $unresolvedCount$$ = 0;
      do {
        $resultsArray$$.push(void 0), $unresolvedCount$$++, $resolvingPromise$$($iterRec$$.value).callWhenSettled_($onFulfilled$$($resultsArray$$.length - 1), $rejectAll$$), $iterRec$$ = $iterator$$.next();
      } while (!$iterRec$$.done);
    });
  };
  return $PolyfillPromise$$;
}, "es6", "es3");
$jscomp.executeAsyncGenerator = function $$jscomp$executeAsyncGenerator$($generator$$) {
  function $passValueToGenerator$$($value$$) {
    return $generator$$.next($value$$);
  }
  function $passErrorToGenerator$$($error$$) {
    return $generator$$.throw($error$$);
  }
  return new Promise(function($resolve$$, $reject$$) {
    function $handleGeneratorRecord$$($genRec$$) {
      $genRec$$.done ? $resolve$$($genRec$$.value) : Promise.resolve($genRec$$.value).then($passValueToGenerator$$, $passErrorToGenerator$$).then($handleGeneratorRecord$$, $reject$$);
    }
    $handleGeneratorRecord$$($generator$$.next());
  });
};
$jscomp.inherits = function $$jscomp$inherits$($childCtor$$, $parentCtor$$) {
  function $tempCtor$$() {
  }
  $tempCtor$$.prototype = $parentCtor$$.prototype;
  $childCtor$$.superClass_ = $parentCtor$$.prototype;
  $childCtor$$.prototype = new $tempCtor$$;
  $childCtor$$.prototype.constructor = $childCtor$$;
  for (var $p$$ in $parentCtor$$) {
    if ("prototype" != $p$$) {
      if (Object.defineProperties) {
        var $descriptor$$ = Object.getOwnPropertyDescriptor($parentCtor$$, $p$$);
        $descriptor$$ && Object.defineProperty($childCtor$$, $p$$, $descriptor$$);
      } else {
        $childCtor$$[$p$$] = $parentCtor$$[$p$$];
      }
    }
  }
};
$jscomp.arrayFromIterator = function $$jscomp$arrayFromIterator$($iterator$$) {
  for (var $i$$, $arr$$ = []; !($i$$ = $iterator$$.next()).done;) {
    $arr$$.push($i$$.value);
  }
  return $arr$$;
};
$jscomp.arrayFromIterable = function $$jscomp$arrayFromIterable$($iterable$$) {
  return $iterable$$ instanceof Array ? $iterable$$ : $jscomp.arrayFromIterator($jscomp.makeIterator($iterable$$));
};
$jscomp.findInternal = function $$jscomp$findInternal$($array$$, $callback$$, $thisArg$$) {
  $array$$ instanceof String && ($array$$ = String($array$$));
  for (var $len$$ = $array$$.length, $i$$ = 0; $i$$ < $len$$; $i$$++) {
    var $value$$ = $array$$[$i$$];
    if ($callback$$.call($thisArg$$, $value$$, $i$$, $array$$)) {
      return {i:$i$$, v:$value$$};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill("Array.prototype.findIndex", function($orig$$) {
  return $orig$$ ? $orig$$ : function($callback$$, $opt_thisArg$$) {
    return $jscomp.findInternal(this, $callback$$, $opt_thisArg$$).i;
  };
}, "es6", "es3");
$jscomp.polyfill("Array.prototype.fill", function($orig$$) {
  return $orig$$ ? $orig$$ : function($value$$, $i$$, $opt_end$$) {
    var $length$$ = this.length || 0;
    0 > $i$$ && ($i$$ = Math.max(0, $length$$ + $i$$));
    if (null == $opt_end$$ || $opt_end$$ > $length$$) {
      $opt_end$$ = $length$$;
    }
    $opt_end$$ = Number($opt_end$$);
    0 > $opt_end$$ && ($opt_end$$ = Math.max(0, $length$$ + $opt_end$$));
    for ($i$$ = Number($i$$ || 0); $i$$ < $opt_end$$; $i$$++) {
      this[$i$$] = $value$$;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.owns = function $$jscomp$owns$($obj$$, $prop$$) {
  return Object.prototype.hasOwnProperty.call($obj$$, $prop$$);
};
$jscomp.polyfill("WeakMap", function($NativeWeakMap$$) {
  function $insert$$($target$$) {
    $jscomp.owns($target$$, $prop$$) || $jscomp.defineProperty($target$$, $prop$$, {value:{}});
  }
  function $patch$$($name$$) {
    var $prev$$ = Object[$name$$];
    $prev$$ && (Object[$name$$] = function $Object$$name$$$($target$$) {
      $insert$$($target$$);
      return $prev$$($target$$);
    });
  }
  if (function isConformant() {
    if (!$NativeWeakMap$$ || !Object.seal) {
      return !1;
    }
    try {
      var $x$$ = Object.seal({}), $y$$ = Object.seal({}), $map$$ = new $NativeWeakMap$$([[$x$$, 2], [$y$$, 3]]);
      if (2 != $map$$.get($x$$) || 3 != $map$$.get($y$$)) {
        return !1;
      }
      $map$$.delete($x$$);
      $map$$.set($y$$, 4);
      return !$map$$.has($x$$) && 4 == $map$$.get($y$$);
    } catch ($err$$) {
      return !1;
    }
  }()) {
    return $NativeWeakMap$$;
  }
  var $prop$$ = "$jscomp_hidden_" + Math.random().toString().substring(2);
  $patch$$("freeze");
  $patch$$("preventExtensions");
  $patch$$("seal");
  var $index$$ = 0, $PolyfillWeakMap$$ = function $$PolyfillWeakMap$$$($iter_opt_iterable$$) {
    this.id_ = ($index$$ += Math.random() + 1).toString();
    if ($iter_opt_iterable$$) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      $iter_opt_iterable$$ = $jscomp.makeIterator($iter_opt_iterable$$);
      for (var $entry_item$$; !($entry_item$$ = $iter_opt_iterable$$.next()).done;) {
        $entry_item$$ = $entry_item$$.value, this.set($entry_item$$[0], $entry_item$$[1]);
      }
    }
  };
  $PolyfillWeakMap$$.prototype.set = function $$PolyfillWeakMap$$$$set$($key$$, $value$$) {
    $insert$$($key$$);
    if (!$jscomp.owns($key$$, $prop$$)) {
      throw Error("WeakMap key fail: " + $key$$);
    }
    $key$$[$prop$$][this.id_] = $value$$;
    return this;
  };
  $PolyfillWeakMap$$.prototype.get = function $$PolyfillWeakMap$$$$get$($key$$) {
    return $jscomp.owns($key$$, $prop$$) ? $key$$[$prop$$][this.id_] : void 0;
  };
  $PolyfillWeakMap$$.prototype.has = function $$PolyfillWeakMap$$$$has$($key$$) {
    return $jscomp.owns($key$$, $prop$$) && $jscomp.owns($key$$[$prop$$], this.id_);
  };
  $PolyfillWeakMap$$.prototype.delete = function $$PolyfillWeakMap$$$$delete$($key$$) {
    return $jscomp.owns($key$$, $prop$$) && $jscomp.owns($key$$[$prop$$], this.id_) ? delete $key$$[$prop$$][this.id_] : !1;
  };
  return $PolyfillWeakMap$$;
}, "es6", "es3");
$jscomp.MapEntry = function $$jscomp$MapEntry$() {
};
$jscomp.polyfill("Map", function($NativeMap$$) {
  if (!$jscomp.ASSUME_NO_NATIVE_MAP && function() {
    if (!$NativeMap$$ || !$NativeMap$$.prototype.entries || "function" != typeof Object.seal) {
      return !1;
    }
    try {
      var $key$$ = Object.seal({x:4}), $map$$ = new $NativeMap$$($jscomp.makeIterator([[$key$$, "s"]]));
      if ("s" != $map$$.get($key$$) || 1 != $map$$.size || $map$$.get({x:4}) || $map$$.set({x:4}, "t") != $map$$ || 2 != $map$$.size) {
        return !1;
      }
      var $iter$$ = $map$$.entries(), $item$$ = $iter$$.next();
      if ($item$$.done || $item$$.value[0] != $key$$ || "s" != $item$$.value[1]) {
        return !1;
      }
      $item$$ = $iter$$.next();
      return $item$$.done || 4 != $item$$.value[0].x || "t" != $item$$.value[1] || !$iter$$.next().done ? !1 : !0;
    } catch ($err$$) {
      return !1;
    }
  }()) {
    return $NativeMap$$;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var $idMap$$ = new WeakMap, $PolyfillMap$$ = function $$PolyfillMap$$$($iter$jscomp$2_opt_iterable$$) {
    this.data_ = {};
    this.head_ = $createHead$$();
    this.size = 0;
    if ($iter$jscomp$2_opt_iterable$$) {
      $iter$jscomp$2_opt_iterable$$ = $jscomp.makeIterator($iter$jscomp$2_opt_iterable$$);
      for (var $entry$jscomp$1_item$$; !($entry$jscomp$1_item$$ = $iter$jscomp$2_opt_iterable$$.next()).done;) {
        $entry$jscomp$1_item$$ = $entry$jscomp$1_item$$.value, this.set($entry$jscomp$1_item$$[0], $entry$jscomp$1_item$$[1]);
      }
    }
  };
  $PolyfillMap$$.prototype.set = function $$PolyfillMap$$$$set$($key$$, $value$$) {
    var $r$$ = $maybeGetEntry$$(this, $key$$);
    $r$$.list || ($r$$.list = this.data_[$r$$.id] = []);
    $r$$.entry ? $r$$.entry.value = $value$$ : ($r$$.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:$key$$, value:$value$$}, $r$$.list.push($r$$.entry), this.head_.previous.next = $r$$.entry, this.head_.previous = $r$$.entry, this.size++);
    return this;
  };
  $PolyfillMap$$.prototype.delete = function $$PolyfillMap$$$$delete$($key$jscomp$34_r$$) {
    $key$jscomp$34_r$$ = $maybeGetEntry$$(this, $key$jscomp$34_r$$);
    return $key$jscomp$34_r$$.entry && $key$jscomp$34_r$$.list ? ($key$jscomp$34_r$$.list.splice($key$jscomp$34_r$$.index, 1), $key$jscomp$34_r$$.list.length || delete this.data_[$key$jscomp$34_r$$.id], $key$jscomp$34_r$$.entry.previous.next = $key$jscomp$34_r$$.entry.next, $key$jscomp$34_r$$.entry.next.previous = $key$jscomp$34_r$$.entry.previous, $key$jscomp$34_r$$.entry.head = null, this.size--, !0) : !1;
  };
  $PolyfillMap$$.prototype.clear = function $$PolyfillMap$$$$clear$() {
    this.data_ = {};
    this.head_ = this.head_.previous = $createHead$$();
    this.size = 0;
  };
  $PolyfillMap$$.prototype.has = function $$PolyfillMap$$$$has$($key$$) {
    return !!$maybeGetEntry$$(this, $key$$).entry;
  };
  $PolyfillMap$$.prototype.get = function $$PolyfillMap$$$$get$($entry$jscomp$2_key$$) {
    return ($entry$jscomp$2_key$$ = $maybeGetEntry$$(this, $entry$jscomp$2_key$$).entry) && $entry$jscomp$2_key$$.value;
  };
  $PolyfillMap$$.prototype.entries = function $$PolyfillMap$$$$entries$() {
    return $makeIterator$$(this, function($entry$$) {
      return [$entry$$.key, $entry$$.value];
    });
  };
  $PolyfillMap$$.prototype.keys = function $$PolyfillMap$$$$keys$() {
    return $makeIterator$$(this, function($entry$$) {
      return $entry$$.key;
    });
  };
  $PolyfillMap$$.prototype.values = function $$PolyfillMap$$$$values$() {
    return $makeIterator$$(this, function($entry$$) {
      return $entry$$.value;
    });
  };
  $PolyfillMap$$.prototype.forEach = function $$PolyfillMap$$$$forEach$($callback$$, $opt_thisArg$$) {
    for (var $iter$$ = this.entries(), $entry$jscomp$6_item$$; !($entry$jscomp$6_item$$ = $iter$$.next()).done;) {
      $entry$jscomp$6_item$$ = $entry$jscomp$6_item$$.value, $callback$$.call($opt_thisArg$$, $entry$jscomp$6_item$$[1], $entry$jscomp$6_item$$[0], this);
    }
  };
  $PolyfillMap$$.prototype[Symbol.iterator] = $PolyfillMap$$.prototype.entries;
  var $maybeGetEntry$$ = function $$maybeGetEntry$$$($index$jscomp$45_map$$, $key$$) {
    var $id$jscomp$4_id$jscomp$inline_63_type$$ = $key$$ && typeof $key$$;
    "object" == $id$jscomp$4_id$jscomp$inline_63_type$$ || "function" == $id$jscomp$4_id$jscomp$inline_63_type$$ ? $idMap$$.has($key$$) ? $id$jscomp$4_id$jscomp$inline_63_type$$ = $idMap$$.get($key$$) : ($id$jscomp$4_id$jscomp$inline_63_type$$ = "" + ++$mapIndex$$, $idMap$$.set($key$$, $id$jscomp$4_id$jscomp$inline_63_type$$)) : $id$jscomp$4_id$jscomp$inline_63_type$$ = "p_" + $key$$;
    var $list$$ = $index$jscomp$45_map$$.data_[$id$jscomp$4_id$jscomp$inline_63_type$$];
    if ($list$$ && $jscomp.owns($index$jscomp$45_map$$.data_, $id$jscomp$4_id$jscomp$inline_63_type$$)) {
      for ($index$jscomp$45_map$$ = 0; $index$jscomp$45_map$$ < $list$$.length; $index$jscomp$45_map$$++) {
        var $entry$$ = $list$$[$index$jscomp$45_map$$];
        if ($key$$ !== $key$$ && $entry$$.key !== $entry$$.key || $key$$ === $entry$$.key) {
          return {id:$id$jscomp$4_id$jscomp$inline_63_type$$, list:$list$$, index:$index$jscomp$45_map$$, entry:$entry$$};
        }
      }
    }
    return {id:$id$jscomp$4_id$jscomp$inline_63_type$$, list:$list$$, index:-1, entry:void 0};
  }, $makeIterator$$ = function $$makeIterator$$$($map$$, $func$$) {
    var $entry$$ = $map$$.head_;
    return $jscomp.iteratorPrototype(function() {
      if ($entry$$) {
        for (; $entry$$.head != $map$$.head_;) {
          $entry$$ = $entry$$.previous;
        }
        for (; $entry$$.next != $entry$$.head;) {
          return $entry$$ = $entry$$.next, {done:!1, value:$func$$($entry$$)};
        }
        $entry$$ = null;
      }
      return {done:!0, value:void 0};
    });
  }, $createHead$$ = function $$createHead$$$() {
    var $head$$ = {};
    return $head$$.previous = $head$$.next = $head$$.head = $head$$;
  }, $mapIndex$$ = 0;
  return $PolyfillMap$$;
}, "es6", "es3");
$jscomp.polyfill("Set", function($NativeSet$$) {
  if (!$jscomp.ASSUME_NO_NATIVE_SET && function() {
    if (!$NativeSet$$ || !$NativeSet$$.prototype.entries || "function" != typeof Object.seal) {
      return !1;
    }
    try {
      var $value$$ = Object.seal({x:4}), $set$$ = new $NativeSet$$($jscomp.makeIterator([$value$$]));
      if (!$set$$.has($value$$) || 1 != $set$$.size || $set$$.add($value$$) != $set$$ || 1 != $set$$.size || $set$$.add({x:4}) != $set$$ || 2 != $set$$.size) {
        return !1;
      }
      var $iter$$ = $set$$.entries(), $item$$ = $iter$$.next();
      if ($item$$.done || $item$$.value[0] != $value$$ || $item$$.value[1] != $value$$) {
        return !1;
      }
      $item$$ = $iter$$.next();
      return $item$$.done || $item$$.value[0] == $value$$ || 4 != $item$$.value[0].x || $item$$.value[1] != $item$$.value[0] ? !1 : $iter$$.next().done;
    } catch ($err$$) {
      return !1;
    }
  }()) {
    return $NativeSet$$;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var $PolyfillSet$$ = function $$PolyfillSet$$$($iter$jscomp$5_opt_iterable$$) {
    this.map_ = new Map;
    if ($iter$jscomp$5_opt_iterable$$) {
      $iter$jscomp$5_opt_iterable$$ = $jscomp.makeIterator($iter$jscomp$5_opt_iterable$$);
      for (var $entry$$; !($entry$$ = $iter$jscomp$5_opt_iterable$$.next()).done;) {
        this.add($entry$$.value);
      }
    }
    this.size = this.map_.size;
  };
  $PolyfillSet$$.prototype.add = function $$PolyfillSet$$$$add$($value$$) {
    this.map_.set($value$$, $value$$);
    this.size = this.map_.size;
    return this;
  };
  $PolyfillSet$$.prototype.delete = function $$PolyfillSet$$$$delete$($result_value$$) {
    $result_value$$ = this.map_.delete($result_value$$);
    this.size = this.map_.size;
    return $result_value$$;
  };
  $PolyfillSet$$.prototype.clear = function $$PolyfillSet$$$$clear$() {
    this.map_.clear();
    this.size = 0;
  };
  $PolyfillSet$$.prototype.has = function $$PolyfillSet$$$$has$($value$$) {
    return this.map_.has($value$$);
  };
  $PolyfillSet$$.prototype.entries = function $$PolyfillSet$$$$entries$() {
    return this.map_.entries();
  };
  $PolyfillSet$$.prototype.values = function $$PolyfillSet$$$$values$() {
    return this.map_.values();
  };
  $PolyfillSet$$.prototype.keys = $PolyfillSet$$.prototype.values;
  $PolyfillSet$$.prototype[Symbol.iterator] = $PolyfillSet$$.prototype.values;
  $PolyfillSet$$.prototype.forEach = function $$PolyfillSet$$$$forEach$($callback$$, $opt_thisArg$$) {
    var $set$$ = this;
    this.map_.forEach(function($value$$) {
      return $callback$$.call($opt_thisArg$$, $value$$, $value$$, $set$$);
    });
  };
  return $PolyfillSet$$;
}, "es6", "es3");
$jscomp.polyfill("Object.entries", function($orig$$) {
  return $orig$$ ? $orig$$ : function($obj$$) {
    var $result$$ = [], $key$$;
    for ($key$$ in $obj$$) {
      $jscomp.owns($obj$$, $key$$) && $result$$.push([$key$$, $obj$$[$key$$]]);
    }
    return $result$$;
  };
}, "es8", "es3");
$jscomp.polyfill("Object.values", function($orig$$) {
  return $orig$$ ? $orig$$ : function($obj$$) {
    var $result$$ = [], $key$$;
    for ($key$$ in $obj$$) {
      $jscomp.owns($obj$$, $key$$) && $result$$.push($obj$$[$key$$]);
    }
    return $result$$;
  };
}, "es8", "es3");
var hamonengine = {debug:!0, verbose:!0};
var bitflag = function $bitflag$() {
};
bitflag.toggle = function $bitflag$toggle$($value$$, $bitToToggle$$, $state$$) {
  return void 0 !== $state$$ ? $state$$ ? $value$$ | 1 << $bitToToggle$$ : $value$$ & ~(1 << $bitToToggle$$) : $value$$ ^ 1 << $bitToToggle$$;
};
bitflag.isSet = function $bitflag$isSet$($value$$, $bitToCheck_valueToCheck$$) {
  $bitToCheck_valueToCheck$$ = 1 << $bitToCheck_valueToCheck$$;
  return ($value$$ & $bitToCheck_valueToCheck$$) === $bitToCheck_valueToCheck$$;
};
var connect = function $connect$($options$$) {
  $options$$ = void 0 === $options$$ ? {} : $options$$;
  this._timeout = $options$$.timeout;
};
connect.get = function $connect$get$($url$$, $options$$) {
  var $$jscomp$destructuring$var0_responseType$$ = void 0 === $options$$ ? {} : $options$$;
  $options$$ = $$jscomp$destructuring$var0_responseType$$.timeout;
  $$jscomp$destructuring$var0_responseType$$ = $$jscomp$destructuring$var0_responseType$$.responseType;
  if (!$url$$) {
    throw "Invalid url '" + $url$$ + "'";
  }
  var $xhr$$ = new XMLHttpRequest;
  if (!$xhr$$) {
    throw "Unable to create XMLHttpRequest";
  }
  void 0 !== $options$$ && ($xhr$$.timeout = $options$$);
  void 0 !== $$jscomp$destructuring$var0_responseType$$ && ($xhr$$.responseType = $$jscomp$destructuring$var0_responseType$$);
  return new Promise(function($resolve$$, $reject$$) {
    $xhr$$.addEventListener("load", function($e$$) {
      var $status$$ = $xhr$$.status;
      0 === $status$$ || 200 <= $status$$ && 400 > $status$$ ? $resolve$$({data:$xhr$$.response, status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$}) : $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.addEventListener("error", function($e$$) {
      return $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.open("GET", $url$$);
    $xhr$$.send();
  });
};
connect.post = function $connect$post$($url$$, $data$$, $options$jscomp$14_timeout$$) {
  var $$jscomp$destructuring$var1_responseType$$ = void 0 === $options$jscomp$14_timeout$$ ? {} : $options$jscomp$14_timeout$$;
  $options$jscomp$14_timeout$$ = $$jscomp$destructuring$var1_responseType$$.timeout;
  var $contentType$$ = $$jscomp$destructuring$var1_responseType$$.contentType, $accept$$ = $$jscomp$destructuring$var1_responseType$$.accept;
  $$jscomp$destructuring$var1_responseType$$ = $$jscomp$destructuring$var1_responseType$$.responseType;
  if (!$url$$) {
    throw "Invalid url '" + $url$$ + "'";
  }
  var $xhr$$ = new XMLHttpRequest;
  if (!$xhr$$) {
    throw "Unable to create XMLHttpRequest";
  }
  void 0 !== $options$jscomp$14_timeout$$ && ($xhr$$.timeout = $options$jscomp$14_timeout$$);
  $$jscomp$destructuring$var1_responseType$$ || ($xhr$$.responseType = $$jscomp$destructuring$var1_responseType$$);
  return new Promise(function($resolve$$, $reject$$) {
    $xhr$$.addEventListener("load", function($e$$) {
      var $status$$ = $xhr$$.status;
      0 === $status$$ || 200 <= $status$$ && 400 > $status$$ ? $resolve$$({data:$xhr$$.response, status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$}) : $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.addEventListener("error", function($e$$) {
      return $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.open("POST", $url$$);
    void 0 !== $contentType$$ ? $xhr$$.setRequestHeader("Content-Type", $contentType$$) : $xhr$$.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    void 0 !== $accept$$ ? $xhr$$.setRequestHeader("Accept", $accept$$) : $xhr$$.setRequestHeader("Accept", "application/x-www-form-urlencoded");
    $xhr$$.send($data$$);
  });
};
$jscomp.global.Object.defineProperties(connect.prototype, {timeout:{configurable:!0, enumerable:!0, get:function() {
  return this._timeout;
}}});
var MILLISECONDS = 1000, fpscounter = function $fpscounter$($options$$) {
  this._spf = this._fps = this._frameCounter = this._globalStartTime = 0;
  this._minFPS = MILLISECONDS;
  this._maxFPS = 0;
};
fpscounter.prototype.start = function $fpscounter$$start$() {
  this._globalStartTime = Date.now();
  this._spf = this._fps = this._frameCounter = 0;
  this._minFPS = MILLISECONDS;
  this._maxFPS = 0;
};
fpscounter.prototype.begin = function $fpscounter$$begin$() {
  this._frameStartTime = Date.now();
};
fpscounter.prototype.end = function $fpscounter$$end$() {
  if (0 === this._startTime) {
    throw "[fpscounter.end] Begin was not called before end.";
  }
  var $frameEndTime$$ = Date.now();
  this._frameCounter++;
  this._spf = ($frameEndTime$$ - this._frameStartTime) * MILLISECONDS;
  $frameEndTime$$ > this._globalStartTime + MILLISECONDS && (this._fps = Math.round(MILLISECONDS * this._frameCounter / ($frameEndTime$$ - this._globalStartTime)), this._minFPS = Math.min(this._minFPS, this._fps), this._maxFPS = Math.max(this._maxFPS, this._fps), this._globalStartTime = $frameEndTime$$, this._frameCounter = 0);
};
$jscomp.global.Object.defineProperties(fpscounter.prototype, {SPF:{configurable:!0, enumerable:!0, get:function() {
  return this._spf;
}}, FPS:{configurable:!0, enumerable:!0, get:function() {
  return this._fps;
}}, minFPS:{configurable:!0, enumerable:!0, get:function() {
  return this._minFPS;
}}, maxFPS:{configurable:!0, enumerable:!0, get:function() {
  return this._maxFPS;
}}});
var listenerPool = function $listenerPool$($options$$) {
  this._listeners = [];
};
listenerPool.prototype.register = function $listenerPool$$register$($listener$$) {
  this._listeners.push($listener$$);
};
listenerPool.prototype.invoke = function $listenerPool$$invoke$($event$$, $args$$) {
  this._listeners.forEach(function($listener$$) {
    return $listener$$[$event$$] && $listener$$[$event$$]($args$$);
  });
};
$jscomp.global.Object.defineProperties(listenerPool.prototype, {listeners:{configurable:!0, enumerable:!0, get:function() {
  return this._listeners;
}}});
var worker = function $worker$($options$$) {
  $options$$ = void 0 === $options$$ ? {} : $options$$;
  $options$$ instanceof worker && ($options$$ = {blob:$options$$.blob, method:$options$$.method});
  if (!$options$$.method) {
    throw console.error("[worker.constructor] Unable to create a workert: options.method is undefined!"), "Cannot create the worker";
  }
  this._method = $options$$.method;
  this._blob = $options$$.blob || new Blob(["onmessage = " + $options$$.method.toString() + ";"], {type:"text/javascript"});
  this._url = URL.createObjectURL(this._blob);
  this._worker = new Worker(this._url);
};
worker.create = function $worker$create$($method$$) {
  return new worker({method:$method$$});
};
worker.prototype.run = function $worker$$run$($data$$) {
  var $$jscomp$async$this$$ = this;
  return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
    function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
      for (;;) {
        switch($$jscomp$generator$state$$) {
          case 0:
            return $$jscomp$generator$state$$ = -1, {value:new Promise(function($resolve$$, $reject$$) {
              $$jscomp$async$this$$.worker.onmessage = function $$$jscomp$async$this$$$worker$onmessage$($e$$) {
                $resolve$$($e$$.data);
                URL.revokeObjectURL($$jscomp$async$this$$.url);
              };
              $$jscomp$async$this$$.worker.onerror = function $$$jscomp$async$this$$$worker$onerror$($e$$) {
                $reject$$($e$$);
                URL.revokeObjectURL($$jscomp$async$this$$.url);
              };
              $$jscomp$async$this$$.worker.postMessage($data$$);
            }), done:!0};
          default:
            return {value:void 0, done:!0};
        }
      }
    }
    var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
      return $$jscomp$generator$impl$$($arg$$, void 0);
    }, throw:function($arg$$) {
      return $$jscomp$generator$impl$$(void 0, $arg$$);
    }, return:function($arg$$) {
      throw Error("Not yet implemented");
    }};
    $jscomp.initSymbolIterator();
    $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
      return this;
    };
    return $iterator$$;
  }());
};
$jscomp.global.Object.defineProperties(worker.prototype, {blob:{configurable:!0, enumerable:!0, get:function() {
  return this._blob;
}}, method:{configurable:!0, enumerable:!0, get:function() {
  return this._method;
}}, url:{configurable:!0, enumerable:!0, get:function() {
  return this._url;
}}, worker:{configurable:!0, enumerable:!0, get:function() {
  return this._worker;
}}});
hamonengine.math = hamonengine.math || {};
(function() {
  Math.PI2 = 6.283185307179586476925286766559;
  Math.PI3_2 = 3 * Math.PI / 2;
  Math.PI_2 = Math.PI / 2;
  Math.HalfPI = 1.5707963267948966192313216916398;
  Math.QuarterPI = 4.7123889803846898576939650749193;
  Math.maxInt32 = 2147483647;
  Math.maxUInt32 = 4294967296;
  Math.bitRound = function $Math$bitRound$($x$$) {
    return 0.5 + $x$$ << 0;
  };
  Math.truncate = function $Math$truncate$($x$$) {
    return $x$$ >= Math.maxInt32 ? Math.maxInt32 : ~~$x$$;
  };
  Math.sqr = function $Math$sqr$($x$$) {
    return $x$$ * $x$$;
  };
  Math.toDegrees = function $Math$toDegrees$($degrees$$) {
    return $degrees$$ * Math.PI / 180;
  };
  Math.toRadians = function $Math$toRadians$($radians$$) {
    return 180 * $radians$$ / Math.PI;
  };
})();
hamonengine.math = hamonengine.math || {};
(function() {
  hamonengine.math.sort = function $hamonengine$math$sort$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._compareFunc = $options$$.compareFunc ? $options$$.compareFunc : hamonengine.math.sort.sort.ascending;
  };
  hamonengine.math.sort.prototype.quickSort = function $hamonengine$math$sort$$quickSort$($arr$$) {
    hamonengine.math.sort.iquicksort(this._compareFunc, $arr$$, 0, $arr$$.length - 1);
  };
  hamonengine.math.sort.ascending = function $hamonengine$math$sort$ascending$($a$$, $b$$) {
    return $a$$ === $b$$ ? 0 : $a$$ < $b$$ ? -1 : 1;
  };
  hamonengine.math.sort.descending = function $hamonengine$math$sort$descending$($a$$, $b$$) {
    return $a$$ === $b$$ ? 0 : $a$$ < $b$$ ? 1 : -1;
  };
  hamonengine.math.sort.iquicksort = function $hamonengine$math$sort$iquicksort$($compareFunction$$, $arr$$, $left$$, $right$$) {
    for (var $i$$ = $left$$, $j$$ = $right$$, $pivot$$ = $arr$$[Math.truncate(($left$$ + $right$$) / 2)]; $i$$ <= $j$$;) {
      for (; 0 > $compareFunction$$($arr$$[$i$$], $pivot$$);) {
        $i$$++;
      }
      for (; 0 < $compareFunction$$($arr$$[$j$$], $pivot$$);) {
        $j$$--;
      }
      if ($i$$ <= $j$$) {
        var $tmp$$ = $arr$$[$i$$];
        $arr$$[$i$$] = $arr$$[$j$$];
        $arr$$[$j$$] = $tmp$$;
        $i$$++;
        $j$$--;
      }
    }
    $left$$ < $j$$ && hamonengine.math.sort.iquicksort($compareFunction$$, $arr$$, $left$$, $j$$);
    $i$$ < $right$$ && hamonengine.math.sort.iquicksort($compareFunction$$, $arr$$, $i$$, $right$$);
  };
})();
hamonengine.math = hamonengine.math || {};
(function() {
  var $m$$ = Math.maxUInt32;
  hamonengine.math.LCGRandom = function $hamonengine$math$LCGRandom$($seed$$) {
    this._seed = $seed$$;
  };
  hamonengine.math.LCGRandom.prototype.random = function $hamonengine$math$LCGRandom$$random$() {
    return this._seed = (214013 * this._seed + 2531011) % $m$$;
  };
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.album = function $hamonengine$audio$album$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.audio.album && ($options$$ = {audioResource:$options$$._audioResource, tracks:$options$$._tracks, trackIndex:$options$$._trackIndex, url:$options$$._url, name:$options$$._name});
    this._audioResource = $options$$.audioResource || new hamonengine.audio.audioext;
    this._tracks = $options$$.tracks || {};
    this._trackIndex = $options$$.trackIndex || [];
    this._url = $options$$.url || "";
    this._name = $options$$.name || "";
    hamonengine.debug && (console.debug("[hamonengine.audio.album.constructor] Name: '" + this._name + "'"), console.debug("[hamonengine.audio.album.constructor] Url: '" + this._url + "'"));
  };
  hamonengine.audio.album.prototype.clone = function $hamonengine$audio$album$$clone$() {
    return new hamonengine.audio.album(this);
  };
  hamonengine.audio.album.prototype.load = function $hamonengine$audio$album$$load$($albumMetadata$$) {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$jscomp$1_i$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              $albumMetadata$$ = $albumMetadata$$ || $$jscomp$async$this$$._url;
              if ("string" !== typeof $albumMetadata$$) {
                $$jscomp$generator$state$$ = 1;
                break;
              }
              $$jscomp$generator$state$$ = 2;
              return {value:connect.get($albumMetadata$$), done:!1};
            case 2:
              if (void 0 === $$jscomp$generator$throw$arg$$) {
                $$jscomp$generator$state$$ = 3;
                break;
              }
              $$jscomp$generator$state$$ = -1;
              throw $$jscomp$generator$throw$arg$$;
            case 3:
              $albumMetadataResponse$$ = $$jscomp$generator$next$arg23$$ = $$jscomp$generator$next$arg$jscomp$1_i$$, $albumMetadata$$ = JSON.parse($albumMetadataResponse$$.data);
            case 1:
              return $$jscomp$async$this$$._name = $$jscomp$async$this$$._name || $albumMetadata$$.name, $$jscomp$generator$state$$ = 4, {value:$$jscomp$async$this$$._audioResource.load($albumMetadata$$.albumUrl), done:!1};
            case 4:
              if (void 0 === $$jscomp$generator$throw$arg$$) {
                $$jscomp$generator$state$$ = 5;
                break;
              }
              $$jscomp$generator$state$$ = -1;
              throw $$jscomp$generator$throw$arg$$;
            case 5:
              for ($$jscomp$generator$next$arg$jscomp$1_i$$ = 0; $$jscomp$generator$next$arg$jscomp$1_i$$ < $albumMetadata$$.tracks.length; $$jscomp$generator$next$arg$jscomp$1_i$$++) {
                $$jscomp$generator$throw$arg$$ = $albumMetadata$$.tracks[$$jscomp$generator$next$arg$jscomp$1_i$$], $$jscomp$async$this$$._trackIndex.push($$jscomp$generator$throw$arg$$.name), $$jscomp$async$this$$._tracks[$$jscomp$generator$throw$arg$$.name] = new hamonengine.audio.track({audioext:$$jscomp$async$this$$._audioResource.clone(), name:$$jscomp$generator$throw$arg$$.name, trackBegin:$$jscomp$generator$throw$arg$$.begin, trackEnd:$$jscomp$generator$throw$arg$$.end});
              }
              $$jscomp$generator$state$$ = -1;
              return {value:Promise.resolve(), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $albumMetadataResponse$$, $$jscomp$generator$next$arg23$$, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.album.prototype.getTrack = function $hamonengine$audio$album$$getTrack$($name$$) {
    return this._tracks[$name$$].clone();
  };
  hamonengine.audio.album.prototype.getTrackByOrdinal = function $hamonengine$audio$album$$getTrackByOrdinal$($index$$) {
    return this._tracks[this._trackIndex[$index$$]].clone();
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.album.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, length:{configurable:!0, enumerable:!0, get:function() {
    return this._trackIndex.length;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._audioResource.isLoaded();
  }}});
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.audioext = function $hamonengine$audio$audioext$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.audio.audioext && ($options$$ = {audio:$options$$._audio, src:$options$$._src, loop:$options$$._loop, buffer:$options$$._buffer, resourceState:$options$$._resourceState, audioCtx:$options$$._audio ? $options$$._audioCtx : null, gainNode:$options$$._audio ? $options$$._gainNode : null, panNode:$options$$._audio ? $options$$._panNode : null, mediaSource:$options$$._audio ? $options$$._mediaSource : null});
    this._loop = void 0 !== $options$$.loop ? $options$$.loop : !1;
    this._src = $options$$.src;
    this._audio = $options$$.audio;
    this._buffer = $options$$.buffer;
    this._fallbackSourceURLs = [];
    if (this.audio) {
      var $sourceElements$$ = this.audio.children;
      if (0 < $sourceElements$$.length) {
        for (var $i$$ = 0; $i$$ < $sourceElements$$.length; $i$$++) {
          this._fallbackSourceURLs.push($sourceElements$$[$i$$].src);
        }
      }
    }
    this._resourceState = $options$$.resourceState || 0;
    this._playingState = 5;
    this._startTime = 0;
    this._mediaSource = $options$$.mediaSource;
    this._audioNodes = [];
    this._audioCtx = $options$$.audioCtx || new AudioContext;
    this._gainNode = $options$$.gainNode || this._audioCtx.createGain();
    this._panNode = $options$$.panNode || new StereoPannerNode(this._audioCtx, {pan:0});
    this._audioListenerDelegate = null;
    hamonengine.debug && (console.debug("[hamonengine.audio.audioext.constructor] ResourceState: {" + this._resourceState + "}"), console.debug("[hamonengine.audio.audioext.constructor] PlayingState: {" + this._playingState + "}"));
  };
  hamonengine.audio.audioext.prototype.clone = function $hamonengine$audio$audioext$$clone$() {
    return new hamonengine.audio.audioext(this);
  };
  hamonengine.audio.audioext.prototype.load = function $hamonengine$audio$audioext$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              if (!$$jscomp$async$this$$.isLoaded) {
                $$jscomp$generator$state$$ = 1;
                break;
              }
              $$jscomp$generator$state$$ = -1;
              return {value:Promise.resolve($$jscomp$async$this$$), done:!0};
            case 1:
              $$jscomp$async$this$$.audio ? ($src$$ = $src$$ ? $src$$ : $$jscomp$async$this$$.audio.src, $$jscomp$async$this$$.audio.load()) : $src$$ = $src$$ ? $src$$ : $$jscomp$async$this$$.src;
              $$jscomp$async$this$$._resourceState = 1;
              $handleSuccess$$ = function $$handleSuccess$$$($buffer$$) {
                $$jscomp$async$this$$.audio ? $$jscomp$async$this$$._mediaSource || ($$jscomp$async$this$$._mediaSource = $$jscomp$async$this$$.context.createMediaElementSource($$jscomp$async$this$$.audio), $$jscomp$async$this$$._mediaSource.connect($$jscomp$async$this$$._gainNode).connect($$jscomp$async$this$$._panNode).connect($$jscomp$async$this$$.context.destination)) : $$jscomp$async$this$$._buffer = $buffer$$;
                $$jscomp$async$this$$._src = $src$$;
                $$jscomp$async$this$$._resourceState = 2;
                hamonengine.debug && console.debug("[hamonengine.audio.audioext.load] Audio '" + $$jscomp$async$this$$.src + "' has loaded successfully.");
                return Promise.resolve($$jscomp$async$this$$);
              };
              $handleFailure$$ = function $$handleFailure$$$($error$$) {
                $$jscomp$async$this$$._resourceState = 3;
                $$jscomp$async$this$$._buffer = null;
                return Promise.reject("The audio '" + $src$$ + "' could not be loaded.  Due to '" + ($error$$ instanceof String ? $error$$ : $error$$.statusText || $error$$) + "'.");
              };
              if (!$$jscomp$async$this$$.audio) {
                $$jscomp$generator$state$$ = 2;
                break;
              }
              $$jscomp$async$this$$.audio.addEventListener("error", function($error$$) {
                return $handleFailure$$($error$$);
              }, !1);
              $$jscomp$async$this$$.audio.addEventListener("stalled", function($error$$) {
                return $handleFailure$$($error$$);
              }, !1);
              $$jscomp$async$this$$.audio.addEventListener("ended", function() {
                return $$jscomp$async$this$$.onAudioEnd();
              }, !1);
              if (0 !== $$jscomp$async$this$$.audio.readyState) {
                $$jscomp$generator$state$$ = 4;
                break;
              }
              $$jscomp$async$this$$.audio.addEventListener("loadeddata", function() {
                return $handleSuccess$$();
              }, !1);
              $$jscomp$generator$state$$ = -1;
              return {value:Promise.resolve($$jscomp$async$this$$), done:!0};
            case 4:
              return $$jscomp$generator$state$$ = -1, {value:$handleSuccess$$(), done:!0};
            case 5:
              $$jscomp$generator$state$$ = 3;
              break;
            case 2:
              try {
                return $$jscomp$generator$state$$ = 8, {value:connect.get($src$$, {responseType:"arraybuffer"}), done:!1};
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 6;
                break;
              }
            case 8:
              try {
                if (void 0 === $$jscomp$generator$throw$arg$$) {
                  $$jscomp$generator$state$$ = 9;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw $$jscomp$generator$throw$arg$$;
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 6;
                break;
              }
            case 9:
              try {
                return $$jscomp$destructuring$var2$$ = $$jscomp$generator$next$arg25$$ = $$jscomp$generator$next$arg$$, $data$$ = $$jscomp$destructuring$var2$$.data, $$jscomp$generator$state$$ = 10, {value:$$jscomp$async$this$$.context.decodeAudioData($data$$), done:!1};
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 6;
                break;
              }
            case 10:
              try {
                if (void 0 === $$jscomp$generator$throw$arg$$) {
                  $$jscomp$generator$state$$ = 11;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw $$jscomp$generator$throw$arg$$;
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 6;
                break;
              }
            case 11:
              try {
                return $buffer$jscomp$0$$ = $$jscomp$generator$next$arg26$$ = $$jscomp$generator$next$arg$$, $$jscomp$generator$state$$ = -1, {value:$handleSuccess$$($buffer$jscomp$0$$), done:!0};
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 6;
                break;
              }
            case 6:
              return $error$jscomp$0$$ = $$jscomp$generator$global$error$$, $$jscomp$generator$state$$ = -1, {value:$handleFailure$$($error$jscomp$0$$), done:!0};
            case 7:
            case 3:
              $$jscomp$generator$state$$ = -1;
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $error$jscomp$0$$, $buffer$jscomp$0$$, $$jscomp$generator$next$arg26$$, $data$$, $$jscomp$destructuring$var2$$, $$jscomp$generator$next$arg25$$, $$jscomp$generator$global$error$$, $handleFailure$$, $handleSuccess$$, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.audioext.prototype.play = function $hamonengine$audio$audioext$$play$($begin$$, $end$$) {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$jscomp$3_i$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              if ($$jscomp$async$this$$.isPlaying) {
                $$jscomp$generator$state$$ = 1;
                break;
              }
              $$jscomp$async$this$$._startTime = $$jscomp$async$this$$.context.currentTime;
              if ("suspended" !== $$jscomp$async$this$$.context.state) {
                $$jscomp$generator$state$$ = 2;
                break;
              }
              $$jscomp$generator$state$$ = 3;
              return {value:$$jscomp$async$this$$.context.resume(), done:!1};
            case 3:
              if (void 0 === $$jscomp$generator$throw$arg$$) {
                $$jscomp$generator$state$$ = 4;
                break;
              }
              $$jscomp$generator$state$$ = -1;
              throw $$jscomp$generator$throw$arg$$;
            case 4:
            case 2:
              if (!$$jscomp$async$this$$.isPaused) {
                $$jscomp$generator$state$$ = 5;
                break;
              }
              $$jscomp$async$this$$._playingState = 4;
              $$jscomp$generator$state$$ = -1;
              return {value:void 0, done:!0};
            case 5:
              $$jscomp$async$this$$._playingState = 4;
              if (!$$jscomp$async$this$$.audio) {
                $$jscomp$generator$state$$ = 6;
                break;
              }
              $$jscomp$async$this$$.audio.currentTime = $begin$$;
              $$jscomp$generator$state$$ = -1;
              return {value:$$jscomp$async$this$$.audio.play(), done:!0};
            case 6:
              $$jscomp$async$this$$._mediaSource = $$jscomp$async$this$$.context.createBufferSource();
              $$jscomp$async$this$$._mediaSource.connect($$jscomp$async$this$$._gainNode).connect($$jscomp$async$this$$._panNode);
              $$jscomp$async$this$$._mediaSource.addEventListener("ended", function($e$$) {
                return $$jscomp$async$this$$.onAudioEnd($e$$);
              }, !1);
              for ($$jscomp$generator$next$arg$jscomp$3_i$$ = 0; $$jscomp$generator$next$arg$jscomp$3_i$$ < $$jscomp$async$this$$._audioNodes.length; $$jscomp$generator$next$arg$jscomp$3_i$$++) {
                $$jscomp$async$this$$._mediaSource.connect($$jscomp$async$this$$._audioNodes[$$jscomp$generator$next$arg$jscomp$3_i$$]);
              }
              $$jscomp$async$this$$._mediaSource.connect($$jscomp$async$this$$.context.destination);
              $end$$ = $end$$ || $$jscomp$async$this$$.duration;
              $$jscomp$async$this$$._mediaSource.buffer = $$jscomp$async$this$$.buffer;
              ($$jscomp$async$this$$._mediaSource.loop = $$jscomp$async$this$$.loop) ? ($$jscomp$async$this$$._mediaSource.loopStart = $begin$$, $$jscomp$async$this$$._mediaSource.loopEnd = $end$$, $$jscomp$async$this$$._mediaSource.start(0, $begin$$)) : $$jscomp$async$this$$._mediaSource.start(0, $begin$$, $end$$ - $begin$$);
              $$jscomp$generator$state$$ = -1;
              return {value:Promise.resolve(), done:!0};
            case 7:
            case 1:
              $$jscomp$generator$state$$ = -1;
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.audioext.prototype.pause = function $hamonengine$audio$audioext$$pause$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              if (!$$jscomp$async$this$$.isPlaying) {
                $$jscomp$generator$state$$ = 1;
                break;
              }
              $$jscomp$async$this$$._playingState = 6;
              $$jscomp$generator$state$$ = -1;
              return {value:$$jscomp$async$this$$.context.suspend(), done:!0};
            case 1:
              $$jscomp$generator$state$$ = -1;
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.audioext.prototype.stop = function $hamonengine$audio$audioext$$stop$($$jscomp$destructuring$var3_options$$) {
    $$jscomp$destructuring$var3_options$$ = void 0 === $$jscomp$destructuring$var3_options$$ ? {} : $$jscomp$destructuring$var3_options$$;
    var $suspend$$ = void 0 === $$jscomp$destructuring$var3_options$$.suspend ? !0 : $$jscomp$destructuring$var3_options$$.suspend, $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              $$jscomp$async$this$$._playingState = 5;
              if (!$$jscomp$async$this$$.audio) {
                $$jscomp$generator$state$$ = 1;
                break;
              }
              $$jscomp$async$this$$.audio.currentTime = 0;
              $$jscomp$generator$state$$ = 3;
              return {value:$$jscomp$async$this$$.audio.pause(), done:!1};
            case 3:
              if (void 0 === $$jscomp$generator$throw$arg$$) {
                $$jscomp$generator$state$$ = 4;
                break;
              }
              $$jscomp$generator$state$$ = -1;
              throw $$jscomp$generator$throw$arg$$;
            case 4:
              $$jscomp$generator$state$$ = 2;
              break;
            case 1:
              $$jscomp$async$this$$._mediaSource && ($$jscomp$async$this$$._mediaSource.disconnect(), $$jscomp$async$this$$._mediaSource.stop(0), $$jscomp$async$this$$._mediaSource._userStopped = !0, $$jscomp$async$this$$._mediaSource = null);
            case 2:
              return $$jscomp$generator$state$$ = -1, {value:$suspend$$ ? $$jscomp$async$this$$.context.suspend() : Promise.resolve(), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.audioext.prototype.connect = function $hamonengine$audio$audioext$$connect$($audioNode$$) {
    this._mediaSource && this._mediaSource instanceof HTMLAudioElement && this._mediaSource.connect($audioNode$$);
    this._audioNodes.push($audioNode$$);
    return $audioNode$$;
  };
  hamonengine.audio.audioext.prototype.disconnect = function $hamonengine$audio$audioext$$disconnect$($audioNode$$) {
    this._mediaSource && this._mediaSource instanceof HTMLAudioElement && this._mediaSource.disconnect($audioNode$$);
    this._audioNodes = this._audioNodes.filter(function($node$$) {
      return $node$$ !== $audioNode$$;
    });
    return $audioNode$$;
  };
  hamonengine.audio.audioext.prototype.onAudioEnd = function $hamonengine$audio$audioext$$onAudioEnd$($e$$) {
    $e$$ = $e$$ && $e$$.currentTarget && $e$$.currentTarget._userStopped || !1;
    4 !== this._playingState || $e$$ || this.loop || (this._playingState = 5, this.audioListenerDelegate && this.audioListenerDelegate.onAudioEnd && this.audioListenerDelegate.onAudioEnd());
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.audioext.prototype, {context:{configurable:!0, enumerable:!0, get:function() {
    return this._audioCtx;
  }}, buffer:{configurable:!0, enumerable:!0, get:function() {
    return this._buffer;
  }}, audio:{configurable:!0, enumerable:!0, get:function() {
    return this._audio;
  }}, src:{configurable:!0, enumerable:!0, get:function() {
    return this._src;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return 2 === this._resourceState;
  }}, isPlaying:{configurable:!0, enumerable:!0, get:function() {
    return 4 === this._playingState;
  }}, isStopped:{configurable:!0, enumerable:!0, get:function() {
    return 5 === this._playingState;
  }}, isPaused:{configurable:!0, enumerable:!0, get:function() {
    return 6 === this._playingState;
  }}, fallbackSourceURLs:{configurable:!0, enumerable:!0, get:function() {
    return this._fallbackSourceURLs;
  }}, duration:{configurable:!0, enumerable:!0, get:function() {
    return this.audio ? this.audio.duration : this.buffer && this.buffer.duration || 0;
  }}, currentTime:{configurable:!0, enumerable:!0, get:function() {
    return this.audio ? this.audio.currentTime : this.isPlaying ? this.context.currentTime - this._startTime : 0;
  }}, loop:{configurable:!0, enumerable:!0, get:function() {
    return this._loop;
  }, set:function($v$$) {
    this._loop = $v$$;
    this.audio && (this.audio.loop = $v$$);
    this._mediaSource && (this._mediaSource.loop = $v$$);
  }}, muted:{configurable:!0, enumerable:!0, get:function() {
    return 0 === this._gainNode.gain.value;
  }, set:function($v$$) {
    $v$$ ? (this._preMutedVolume = this.volume, this.volume = 0) : void 0 !== this._preMutedVolume && (this.volume = this._preMutedVolume, delete this._preMutedVolume);
  }}, volume:{configurable:!0, enumerable:!0, get:function() {
    return this._gainNode.gain.value;
  }, set:function($v$$) {
    this._gainNode.gain.value = 1.0 < $v$$ ? 1.0 : $v$$;
  }}, audioListenerDelegate:{configurable:!0, enumerable:!0, get:function() {
    return this._audioListenerDelegate;
  }, set:function($v$$) {
    this._audioListenerDelegate = $v$$;
  }}});
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.playlist = function $hamonengine$audio$playlist$($options$$) {
    var $$jscomp$this$$ = this;
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.audio.playlist && ($options$$ = {tracks:$options$$._tracks.map(function($track$$) {
      return $track$$.clone();
    }), index:$options$$._index, loop:$options$$._loop, autoplay:$options$$._autoplay});
    this._name = $options$$.name;
    this._tracks = [];
    this._index = $options$$.index || 0;
    this._loop = $options$$.loop || 0;
    this._autoplay = void 0 !== $options$$.autoplay ? $options$$.autoplay : !1;
    this._autoplayFilters = $options$$.autoplayFilters || [];
    this._volume = 1.0;
    this._listenerPool = new listenerPool;
    ($options$$.tracks || []).forEach(function($track$$) {
      return $$jscomp$this$$.addTrack($track$$);
    });
    hamonengine.debug && (console.debug("[hamonengine.audio.playlist.constructor] Name: " + this._name), console.debug("[hamonengine.audio.playlist.constructor] Track Index: " + this._index), console.debug("[hamonengine.audio.playlist.constructor] Loop: " + (this._loop ? "true" : "false")), console.debug("[hamonengine.audio.playlist.constructor] Autoplay: " + (this._autoplay ? "true" : "false")));
  };
  hamonengine.audio.playlist.prototype.clone = function $hamonengine$audio$playlist$$clone$() {
    return new hamonengine.audio.playlist(this);
  };
  hamonengine.audio.playlist.prototype.register = function $hamonengine$audio$playlist$$register$($listener$$) {
    this._listenerPool.register($listener$$);
  };
  hamonengine.audio.playlist.prototype.load = function $hamonengine$audio$playlist$$load$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$jscomp$6_i$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              $unloadedTracks$$ = [];
              for ($$jscomp$generator$next$arg$jscomp$6_i$$ = 0; $$jscomp$generator$next$arg$jscomp$6_i$$ < $$jscomp$async$this$$._tracks.length; $$jscomp$generator$next$arg$jscomp$6_i$$++) {
                $$jscomp$async$this$$._tracks[$$jscomp$generator$next$arg$jscomp$6_i$$].isLoaded || $unloadedTracks$$.push($$jscomp$async$this$$._tracks[$$jscomp$generator$next$arg$jscomp$6_i$$].load());
              }
              if (!(0 < $unloadedTracks$$.length)) {
                $$jscomp$generator$state$$ = 1;
                break;
              }
              $$jscomp$generator$state$$ = -1;
              return {value:Promise.all($unloadedTracks$$), done:!0};
            case 1:
              return $$jscomp$generator$state$$ = -1, {value:Promise.resolve(), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $unloadedTracks$$, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.playlist.prototype.play = function $hamonengine$audio$playlist$$play$($trackname$$) {
    $trackname$$ = void 0 === $trackname$$ ? "" : $trackname$$;
    if (!this.currentTrack.isPlaying) {
      if ("" !== $trackname$$) {
        var $index$$ = this._tracks.findIndex(function($track$$) {
          return $track$$.name === $trackname$$;
        });
        -1 < $index$$ && (this.index = $index$$);
      }
      this.currentTrack.volume = this.volume;
      this.currentTrack.play();
      this._listenerPool.invoke("onPlaylistPlay", {track:this.currentTrack});
    }
  };
  hamonengine.audio.playlist.prototype.pause = function $hamonengine$audio$playlist$$pause$() {
    this.currentTrack.pause();
    this._listenerPool.invoke("onPlaylistPause", {track:this.currentTrack});
  };
  hamonengine.audio.playlist.prototype.stop = function $hamonengine$audio$playlist$$stop$($$jscomp$destructuring$var4_reason$$) {
    $$jscomp$destructuring$var4_reason$$ = void 0 === $$jscomp$destructuring$var4_reason$$ ? {} : $$jscomp$destructuring$var4_reason$$;
    $$jscomp$destructuring$var4_reason$$ = void 0 === $$jscomp$destructuring$var4_reason$$.reason ? "invoked" : $$jscomp$destructuring$var4_reason$$.reason;
    this.currentTrack.stop();
    this.index = 0;
    this._listenerPool.invoke("onPlaylistStop", {track:this.currentTrack, reason:$$jscomp$destructuring$var4_reason$$});
  };
  hamonengine.audio.playlist.prototype.next = function $hamonengine$audio$playlist$$next$() {
    this.currentTrack.isPlaying ? (this.currentTrack.stop(), this.index++, this.currentTrack.play()) : this.index++;
    this._listenerPool.invoke("onPlaylistNext", {track:this.currentTrack});
  };
  hamonengine.audio.playlist.prototype.prev = function $hamonengine$audio$playlist$$prev$() {
    this.currentTrack.isPlaying ? (this.currentTrack.stop(), this.index--, this.currentTrack.play()) : this.index--;
    this._listenerPool.invoke("onPlaylistPrevious", {track:this.currentTrack});
  };
  hamonengine.audio.playlist.prototype.addTrack = function $hamonengine$audio$playlist$$addTrack$($track$$) {
    $track$$.register(this);
    this._tracks.push($track$$);
  };
  hamonengine.audio.playlist.createAutoPlayFadeFilter = function $hamonengine$audio$playlist$createAutoPlayFadeFilter$($fadeOutStart$$) {
    var $$jscomp$destructuring$var5$$ = void 0 === $fadeOutStart$$ ? {} : $fadeOutStart$$;
    $fadeOutStart$$ = void 0 === $$jscomp$destructuring$var5$$.fadeOutStart ? 0.01 : $$jscomp$destructuring$var5$$.fadeOutStart;
    var $rateOfFade$$ = void 0 === $$jscomp$destructuring$var5$$.rateOfFade ? 0 : $$jscomp$destructuring$var5$$.rateOfFade;
    return function($$jscomp$destructuring$var6_playList$$) {
      var $remainingTime_volume$$ = $$jscomp$destructuring$var6_playList$$.remainingTime, $currentTrack$$ = $$jscomp$destructuring$var6_playList$$.currentTrack;
      $$jscomp$destructuring$var6_playList$$ = $$jscomp$destructuring$var6_playList$$.playList;
      var $fadeOutStartInterval$$ = $currentTrack$$.duration * $fadeOutStart$$;
      $remainingTime_volume$$ < $fadeOutStartInterval$$ && ($remainingTime_volume$$ = 0 < $rateOfFade$$ ? $currentTrack$$.volume - $rateOfFade$$ : $remainingTime_volume$$ / ($currentTrack$$.volume * $fadeOutStartInterval$$), 0 < $remainingTime_volume$$ ? $currentTrack$$.volume = $remainingTime_volume$$ : ($currentTrack$$.stop({suspend:!1}), $$jscomp$destructuring$var6_playList$$.next(), $$jscomp$destructuring$var6_playList$$.play()));
    };
  };
  hamonengine.audio.playlist.prototype.onTrackBegin = function $hamonengine$audio$playlist$$onTrackBegin$($$jscomp$destructuring$var8$$) {
  };
  hamonengine.audio.playlist.prototype.onTrackEnd = function $hamonengine$audio$playlist$$onTrackEnd$($$jscomp$destructuring$var10_track$$) {
    $$jscomp$destructuring$var10_track$$ = $$jscomp$destructuring$var10_track$$.track;
    this.autoplay && $$jscomp$destructuring$var10_track$$ === this.currentTrack && (this.loop || this.index < this._tracks.length - 1 ? (this.next(), this.play()) : this.stop({reason:"playlistend"}));
  };
  hamonengine.audio.playlist.prototype.onTrackUpdate = function $hamonengine$audio$playlist$$onTrackUpdate$($$jscomp$destructuring$var12_remainingTime$$) {
    var $track$$ = $$jscomp$destructuring$var12_remainingTime$$.track, $elapsedTime$$ = $$jscomp$destructuring$var12_remainingTime$$.elapsedTime;
    $$jscomp$destructuring$var12_remainingTime$$ = $$jscomp$destructuring$var12_remainingTime$$.remainingTime;
    if (0 < this._autoplayFilters.length) {
      for (var $nextTrack$$ = this._tracks[this.index + 1 % this._tracks.length], $i$$ = 0; $i$$ < this._autoplayFilters.length; $i$$++) {
        this._autoplayFilters[$i$$]({elapsedTime:$elapsedTime$$, remainingTime:$$jscomp$destructuring$var12_remainingTime$$, currentTrack:$track$$, nextTrack:$nextTrack$$, playList:this});
      }
    }
    this._listenerPool.invoke("onPlaylistUpdate", {track:$track$$, elapsedTime:$elapsedTime$$, remainingTime:$$jscomp$destructuring$var12_remainingTime$$, playlist:this});
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.playlist.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }, set:function($v$$) {
    this._name = $v$$;
  }}, index:{configurable:!0, enumerable:!0, get:function() {
    return this._index;
  }, set:function($index$jscomp$48_v$$) {
    $index$jscomp$48_v$$ %= this._tracks.length;
    this._index = 0 > $index$jscomp$48_v$$ ? this._tracks.length + $index$jscomp$48_v$$ : $index$jscomp$48_v$$;
  }}, isPlaying:{configurable:!0, enumerable:!0, get:function() {
    return this.currentTrack.isPlaying;
  }}, currentTrack:{configurable:!0, enumerable:!0, get:function() {
    return this._tracks[this.index];
  }}, loop:{configurable:!0, enumerable:!0, get:function() {
    return this._loop;
  }, set:function($v$$) {
    this._loop = $v$$;
  }}, autoplay:{configurable:!0, enumerable:!0, get:function() {
    return this._autoplay;
  }, set:function($v$$) {
    this._autoplay = $v$$;
  }}, volume:{configurable:!0, enumerable:!0, get:function() {
    return this._volume;
  }, set:function($v$$) {
    this._volume = $v$$;
  }}});
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.track = function $hamonengine$audio$track$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.audio.track && ($options$$ = {name:$options$$._name, audioext:$options$$._audioext.clone(), src:$options$$._src, trackBegin:$options$$._trackBegin, trackEnd:$options$$._trackEnd});
    this._name = $options$$.name;
    this._audioext = $options$$.audioext || new hamonengine.audio.audioext({audio:$options$$.audio, src:$options$$.src});
    this._trackBegin = $options$$.trackBegin || 0;
    this._trackEnd = $options$$.trackEnd;
    this._listenerPool = new listenerPool;
    hamonengine.debug && (console.debug("[hamonengine.audio.track.constructor] Name: " + this._name), console.debug("[hamonengine.audio.track.constructor] Track Begin: " + this._trackBegin), console.debug("[hamonengine.audio.track.constructor] Track End: {" + this._trackEnd + "}"));
  };
  hamonengine.audio.track.prototype.clone = function $hamonengine$audio$track$$clone$() {
    return new hamonengine.audio.track(this);
  };
  hamonengine.audio.track.prototype.register = function $hamonengine$audio$track$$register$($listener$$) {
    this._listenerPool.register($listener$$);
  };
  hamonengine.audio.track.prototype.load = function $hamonengine$audio$track$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return $$jscomp$generator$state$$ = -1, {value:$$jscomp$async$this$$._audioext.load($src$$), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.track.prototype.play = function $hamonengine$audio$track$$play$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return $$jscomp$async$this$$._audioext.audioListenerDelegate = $$jscomp$async$this$$, $$jscomp$generator$state$$ = -1, {value:$$jscomp$async$this$$._audioext.play($$jscomp$async$this$$._trackBegin, $$jscomp$async$this$$._trackEnd), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.track.prototype.pause = function $hamonengine$audio$track$$pause$() {
    return this._audioext.pause();
  };
  hamonengine.audio.track.prototype.stop = function $hamonengine$audio$track$$stop$($$jscomp$destructuring$var14_options$$) {
    $$jscomp$destructuring$var14_options$$ = void 0 === $$jscomp$destructuring$var14_options$$ ? {} : $$jscomp$destructuring$var14_options$$;
    var $suspend$$ = void 0 === $$jscomp$destructuring$var14_options$$.suspend ? !0 : $$jscomp$destructuring$var14_options$$.suspend, $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return $$jscomp$generator$state$$ = -1, {value:$$jscomp$async$this$$._audioext.stop({suspend:$suspend$$}), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.track.prototype.onTrackBegin = function $hamonengine$audio$track$$onTrackBegin$() {
    this._listenerPool.invoke("onTrackBegin", {track:this});
  };
  hamonengine.audio.track.prototype.onAudioEnd = function $hamonengine$audio$track$$onAudioEnd$() {
    this.loop ? this.play() : this._listenerPool.invoke("onTrackEnd", {track:this});
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.track.prototype, {src:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.src;
  }}, name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }, set:function($v$$) {
    this._name = $v$$;
  }}, context:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.context;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.isLoaded;
  }}, isPlaying:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.isPlaying;
  }}, duration:{configurable:!0, enumerable:!0, get:function() {
    return (this._trackEnd || this._audioext.duration) - this._trackBegin;
  }}, fallbackSourceURLs:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.fallbackSourceURLs;
  }}, autoplay:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.autoplay;
  }, set:function($v$$) {
    this._audioext.autoplay = $v$$;
  }}, loop:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.loop;
  }, set:function($v$$) {
    this._audioext.loop = $v$$;
  }}, muted:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.muted;
  }, set:function($v$$) {
    this._audioext.muted = $v$$;
  }}, volume:{configurable:!0, enumerable:!0, get:function() {
    return this._audioext.volume;
  }, set:function($v$$) {
    this._audioext.volume = $v$$;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.interval = function $hamonengine$geometry$interval$($min$$, $max$$) {
    this.min = void 0 === $min$$ ? 0.0 : $min$$;
    this.max = void 0 === $max$$ ? 0.0 : $max$$;
  };
  hamonengine.geometry.interval.clone = function $hamonengine$geometry$interval$clone$($interval$$) {
    return new hamonengine.geometry.interval($interval$$.min, $interval$$.max);
  };
  hamonengine.geometry.interval.prototype.clone = function $hamonengine$geometry$interval$$clone$() {
    return hamonengine.geometry.interval.clone(this);
  };
  hamonengine.geometry.interval.prototype.toString = function $hamonengine$geometry$interval$$toString$() {
    return "{min: '" + this.min + "', max: '" + this.max + "'}";
  };
  hamonengine.geometry.interval.prototype.mirror = function $hamonengine$geometry$interval$$mirror$() {
    return new hamonengine.geometry.interval(this.max, this.min);
  };
  hamonengine.geometry.interval.prototype.add = function $hamonengine$geometry$interval$$add$($l$$) {
    return new hamonengine.geometry.interval(this.min + $l$$.min, this.max + $l$$.max);
  };
  hamonengine.geometry.interval.prototype.subtract = function $hamonengine$geometry$interval$$subtract$($l$$) {
    return new hamonengine.geometry.interval(this.min - $l$$.min, this.max - $l$$.max);
  };
  hamonengine.geometry.interval.prototype.multiplyScalar = function $hamonengine$geometry$interval$$multiplyScalar$($s$$) {
    return new hamonengine.geometry.interval(this.min * $s$$, this.max * $s$$);
  };
  hamonengine.geometry.interval.prototype.overlap = function $hamonengine$geometry$interval$$overlap$($i$$) {
    if (this.isPoint && $i$$.isPoint) {
      return this.min === $i$$.min ? new hamonengine.geometry.interval(0, 0) : new hamonengine.geometry.interval(NaN, NaN);
    }
    if (this.isPoint || $i$$.isPoint) {
      var $min$jscomp$1_p$$ = this;
      this.isPoint || ($min$jscomp$1_p$$ = $i$$, $i$$ = this);
      var $isPointOnLine_min$0$$ = NaN;
      var $max$$ = NaN;
      $i$$.contains($min$jscomp$1_p$$) && ($min$jscomp$1_p$$.min - $i$$.min < $i$$.max - $min$jscomp$1_p$$.min ? ($isPointOnLine_min$0$$ = $i$$.min, $max$$ = $min$jscomp$1_p$$.min) : ($isPointOnLine_min$0$$ = $min$jscomp$1_p$$.min, $max$$ = $i$$.max));
      return new hamonengine.geometry.interval($isPointOnLine_min$0$$, $max$$);
    }
    $max$$ = $min$jscomp$1_p$$ = NaN;
    this.isPoint || $i$$.isPoint || ($isPointOnLine_min$0$$ = function $$isPointOnLine_min$0$$$($point$$, $interval$$) {
      return $point$$ >= $interval$$.min && $point$$ <= $interval$$.max;
    }, $isPointOnLine_min$0$$(this.min, $i$$) ? $min$jscomp$1_p$$ = this.min : $isPointOnLine_min$0$$($i$$.min, this) && ($min$jscomp$1_p$$ = $i$$.min), $isPointOnLine_min$0$$(this.max, $i$$) ? $max$$ = this.max : $isPointOnLine_min$0$$($i$$.max, this) && ($max$$ = $i$$.max));
    return new hamonengine.geometry.interval($min$jscomp$1_p$$, $max$$);
  };
  hamonengine.geometry.interval.prototype.contains = function $hamonengine$geometry$interval$$contains$($i$$) {
    return $i$$.min >= this.min && $i$$.max <= this.max;
  };
  hamonengine.geometry.interval.prototype.getOrientation = function $hamonengine$geometry$interval$$getOrientation$($i$$) {
    var $tMidPoint$$ = this.midPoint;
    $i$$ = $i$$.midPoint;
    return $i$$ === $tMidPoint$$ ? 0 : $i$$ < $tMidPoint$$ ? -1 : 1;
  };
  hamonengine.geometry.interval.prototype.getDistance = function $hamonengine$geometry$interval$$getDistance$($i$$) {
    return Math.abs(this.midPoint - $i$$.midPoint);
  };
  hamonengine.geometry.interval.prototype.getMinimumDistance = function $hamonengine$geometry$interval$$getMinimumDistance$($i$$) {
    return this.getDistanceParams($i$$).min;
  };
  hamonengine.geometry.interval.prototype.getMaximumDistance = function $hamonengine$geometry$interval$$getMaximumDistance$($i$$) {
    return this.getDistanceParams($i$$).max;
  };
  hamonengine.geometry.interval.prototype.getDistanceParams = function $hamonengine$geometry$interval$$getDistanceParams$($i$jscomp$22_max$$) {
    var $min$$ = Math.abs(this.min - $i$jscomp$22_max$$.min);
    $i$jscomp$22_max$$ = Math.abs(this.max - $i$jscomp$22_max$$.max);
    return {min:$min$$ < $i$jscomp$22_max$$ ? $min$$ : $i$jscomp$22_max$$, max:$min$$ > $i$jscomp$22_max$$ ? $min$$ : $i$jscomp$22_max$$};
  };
  hamonengine.geometry.interval.prototype.getPointDistance = function $hamonengine$geometry$interval$$getPointDistance$($i$$, $direction$$) {
    var $p$$ = this;
    this.isPoint || ($p$$ = $i$$, $i$$ = this);
    return 0 < $direction$$ ? $i$$.max - $p$$.max : $p$$.max - $i$$.min;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.interval.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.abs(this.max - this.min);
  }}, isLine:{configurable:!0, enumerable:!0, get:function() {
    return !isNaN(this.min) && !isNaN(this.max);
  }}, isPoint:{configurable:!0, enumerable:!0, get:function() {
    return this.isLine && this.min === this.max;
  }}, midPoint:{configurable:!0, enumerable:!0, get:function() {
    return this.isPoint ? this.min : (this.max - this.min) / 2;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.lineSegment = function $hamonengine$geometry$lineSegment$($x$$, $y$$, $x2$$, $y2$$) {
    $x$$ = void 0 === $x$$ ? 0 : $x$$;
    $y$$ = void 0 === $y$$ ? 0 : $y$$;
    $x2$$ = void 0 === $x2$$ ? 0 : $x2$$;
    $y2$$ = void 0 === $y2$$ ? 0 : $y2$$;
    this.x = $x$$;
    this.y = $y$$;
    this.x2 = $x2$$;
    this.y2 = $y2$$;
    this._direction = new hamonengine.geometry.vector2($x2$$ - $x$$, $y2$$ - $y$$);
  };
  hamonengine.geometry.lineSegment.prototype.clone = function $hamonengine$geometry$lineSegment$$clone$() {
    return new hamonengine.geometry.lineSegment(this.x, this.y, this.x2, this.y2);
  };
  hamonengine.geometry.lineSegment.prototype.toString = function $hamonengine$geometry$lineSegment$$toString$() {
    return "({x1: " + this.x + ", y1: " + this.y + "}), ({x2: " + this.x2 + ", y2: " + this.y2 + "})";
  };
  hamonengine.geometry.lineSegment.prototype.toVertices = function $hamonengine$geometry$lineSegment$$toVertices$() {
    return [new hamonengine.geometry.vector2(this.x, this.y), new hamonengine.geometry.vector2(this.x2, this.y2)];
  };
  hamonengine.geometry.lineSegment.prototype.toPolygon = function $hamonengine$geometry$lineSegment$$toPolygon$() {
    return new hamonengine.geometry.polygon({vertices:this.toVertices()});
  };
  hamonengine.geometry.lineSegment.prototype.translate = function $hamonengine$geometry$lineSegment$$translate$($translateVector$$) {
    $translateVector$$ = $translateVector$$ || new hamonengine.geometry.vector2(0, 0);
    return new hamonengine.geometry.lineSegment(this.x + $translateVector$$.x, this.y + $translateVector$$.y, this.x2 + $translateVector$$.x, this.y2 + $translateVector$$.y);
  };
  hamonengine.geometry.lineSegment.prototype.isCollision = function $hamonengine$geometry$lineSegment$$isCollision$($shape$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.geometry.vector2 : $direction$$;
    return $shape$$ instanceof hamonengine.geometry.rect ? this.isCollisionRect($shape$$, $direction$$) : $shape$$ instanceof hamonengine.geometry.polygon ? this.isCollisionPolygon($shape$$, $direction$$) : new hamonengine.geometry.vector2(0, 0);
  };
  hamonengine.geometry.lineSegment.prototype.isCollisionPolygon = function $hamonengine$geometry$lineSegment$$isCollisionPolygon$($distance_polygon_shapeProject$$, $axes_direction$$) {
    void 0 === $axes_direction$$ && new hamonengine.geometry.vector2;
    $distance_polygon_shapeProject$$ instanceof hamonengine.geometry.polygon || console.warn("[hamonengine.geometry.lineSegment.isCollisionPolygon] The polygon parameter is not of type hamonengine.geometry.polygon!");
    $axes_direction$$ = $distance_polygon_shapeProject$$.normals;
    for (var $i$$ = 0; $i$$ < $axes_direction$$.length; $i$$++) {
      var $thisProjection$$ = this.project($axes_direction$$[$i$$]), $otherProjection$$ = $distance_polygon_shapeProject$$.project($axes_direction$$[$i$$]);
      if (!$thisProjection$$.overlap($otherProjection$$).isLine) {
        return new hamonengine.geometry.vector2;
      }
    }
    $axes_direction$$ = this.normal;
    $distance_polygon_shapeProject$$ = $distance_polygon_shapeProject$$.project($axes_direction$$);
    $i$$ = this.project($axes_direction$$);
    if (!$distance_polygon_shapeProject$$.overlap($i$$).isLine) {
      return new hamonengine.geometry.vector2;
    }
    $distance_polygon_shapeProject$$ = $distance_polygon_shapeProject$$.getPointDistance($i$$, $axes_direction$$);
    $distance_polygon_shapeProject$$ = $distance_polygon_shapeProject$$ < hamonengine.geometry.settings.collisionDetection.floor ? 0.0 : $distance_polygon_shapeProject$$;
    return $axes_direction$$.multiply($distance_polygon_shapeProject$$);
  };
  hamonengine.geometry.lineSegment.prototype.isCollisionRect = function $hamonengine$geometry$lineSegment$$isCollisionRect$($rect_shapeProject$$, $checkCollision$jscomp$1_direction$jscomp$8_distance$$) {
    $checkCollision$jscomp$1_direction$jscomp$8_distance$$ = void 0 === $checkCollision$jscomp$1_direction$jscomp$8_distance$$ ? new hamonengine.geometry.vector2 : $checkCollision$jscomp$1_direction$jscomp$8_distance$$;
    $rect_shapeProject$$ instanceof hamonengine.geometry.rect || console.warn("[hamonengine.geometry.lineSegment.isCollisionRect] The rect parameter is not of type hamonengine.geometry.rect!");
    $checkCollision$jscomp$1_direction$jscomp$8_distance$$ = function $$checkCollision$jscomp$1_direction$jscomp$8_distance$$$($thisProjection$$, $otherProjection$$) {
      return $thisProjection$$.overlap($otherProjection$$).isLine ? !0 : !1;
    };
    var $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$ = new hamonengine.geometry.interval($rect_shapeProject$$.y, $rect_shapeProject$$.y + $rect_shapeProject$$.height);
    if (!$checkCollision$jscomp$1_direction$jscomp$8_distance$$(this.project(hamonengine.geometry.vector2.Y_AXIS_NORMAL), $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$)) {
      return new hamonengine.geometry.vector2;
    }
    $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$ = new hamonengine.geometry.interval($rect_shapeProject$$.x, $rect_shapeProject$$.x + $rect_shapeProject$$.width);
    if (!$checkCollision$jscomp$1_direction$jscomp$8_distance$$(this.project(hamonengine.geometry.vector2.X_AXIS_NORMAL), $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$)) {
      return new hamonengine.geometry.vector2;
    }
    $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$ = this.normal;
    $rect_shapeProject$$ = $rect_shapeProject$$.project($X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$);
    var $lineProject$$ = this.project($X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$);
    if (!$checkCollision$jscomp$1_direction$jscomp$8_distance$$($rect_shapeProject$$, $lineProject$$)) {
      return new hamonengine.geometry.vector2;
    }
    $checkCollision$jscomp$1_direction$jscomp$8_distance$$ = $rect_shapeProject$$.getPointDistance($lineProject$$, $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$);
    $checkCollision$jscomp$1_direction$jscomp$8_distance$$ = $checkCollision$jscomp$1_direction$jscomp$8_distance$$ < hamonengine.geometry.settings.collisionDetection.floor ? 0.0 : $checkCollision$jscomp$1_direction$jscomp$8_distance$$;
    return $X_AXIS_PROJECTION_Y_AXIS_PROJECTION_thisNormal$$.multiply($checkCollision$jscomp$1_direction$jscomp$8_distance$$);
  };
  hamonengine.geometry.lineSegment.prototype.project = function $hamonengine$geometry$lineSegment$$project$($projection_unitVector$$) {
    var $min$$;
    var $max$$ = $min$$ = $projection_unitVector$$.dot({x:this.x, y:this.y});
    $projection_unitVector$$ = $projection_unitVector$$.dot({x:this.x2, y:this.y2});
    $projection_unitVector$$ < $min$$ ? $min$$ = $projection_unitVector$$ : $projection_unitVector$$ > $max$$ && ($max$$ = $projection_unitVector$$);
    return new hamonengine.geometry.interval($min$$, $max$$);
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.lineSegment.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return this._direction.length;
  }}, midPoint:{configurable:!0, enumerable:!0, get:function() {
    return this._direction.midPoint;
  }}, slope:{configurable:!0, enumerable:!0, get:function() {
    return this._direction.y / this._direction.x;
  }}, normal:{configurable:!0, enumerable:!0, get:function() {
    return this._direction.normal(ROTATION_TYPE.CW);
  }}, normals:{configurable:!0, enumerable:!0, get:function() {
    return [this.normal];
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.polygon = function $hamonengine$geometry$polygon$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.geometry.polygon && ($options$$ = {vertices:$options$$.vertices});
    this._vertices = $options$$.vertices || [];
    this._edges = [];
    this._normals = [];
    this._dimensions = {center:null, max:null, min:null, minVertex:null, maxVertex:null};
    this._dirty = 15;
    this._shapeType = SHAPE_TYPE.UNKNOWN;
  };
  hamonengine.geometry.polygon.prototype.clone = function $hamonengine$geometry$polygon$$clone$() {
    return new hamonengine.geometry.polygon(this);
  };
  hamonengine.geometry.polygon.prototype.toString = function $hamonengine$geometry$polygon$$toString$() {
    for (var $vertexString$$ = "", $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      $vertexString$$ += "" + ("" !== $vertexString$$ ? "," : "") + this.vertices[$i$$].toString();
    }
    return "[" + $vertexString$$ + "]";
  };
  hamonengine.geometry.polygon.prototype.toRect = function $hamonengine$geometry$polygon$$toRect$() {
    return new hamonengine.geometry.rect(this.min.x, this.min.y, this.max.x - this.min.x, this.max.y - this.min.y);
  };
  hamonengine.geometry.polygon.prototype.addVertex = function $hamonengine$geometry$polygon$$addVertex$($x$$, $y$$) {
    this._vertices.push(new hamonengine.geometry.vector2($x$$, $y$$));
    this._dirty = 15;
  };
  hamonengine.geometry.polygon.prototype.addLine = function $hamonengine$geometry$polygon$$addLine$($line$$) {
    this._vertices.push.apply(this._vertices, [].concat($jscomp.arrayFromIterable($line$$.toVertices())));
    this._dirty = 15;
  };
  hamonengine.geometry.polygon.prototype.translate = function $hamonengine$geometry$polygon$$translate$($translateVector$$) {
    $translateVector$$ = $translateVector$$ || new hamonengine.geometry.vector2(0, 0);
    for (var $newVertices$$ = [], $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      $newVertices$$.push(this.vertices[$i$$].add($translateVector$$));
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.rotate = function $hamonengine$geometry$polygon$$rotate$($cosTheta_theta$$, $offsetVector$$) {
    $cosTheta_theta$$ = $cosTheta_theta$$ || 0.0;
    $offsetVector$$ = $offsetVector$$ || new hamonengine.geometry.vector2(0, 0);
    var $sinTheta$$ = Math.sin($cosTheta_theta$$);
    $cosTheta_theta$$ = Math.cos($cosTheta_theta$$);
    for (var $newVertices$$ = [], $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      var $xOffset_y$$ = this.vertices[$i$$].x - $offsetVector$$.x, $yOffset$$ = this.vertices[$i$$].y - $offsetVector$$.y;
      if (hamonengine.geometry.settings.coordinateSystem === COORDINATE_SYSTEM.RHS) {
        var $x$$ = $xOffset_y$$ * $cosTheta_theta$$ - $yOffset$$ * $sinTheta$$;
        $xOffset_y$$ = $xOffset_y$$ * $sinTheta$$ + $yOffset$$ * $cosTheta_theta$$;
      } else {
        $x$$ = $xOffset_y$$ * $cosTheta_theta$$ + $yOffset$$ * $sinTheta$$, $xOffset_y$$ = -($xOffset_y$$ * $sinTheta$$) + $yOffset$$ * $cosTheta_theta$$;
      }
      $newVertices$$.push(new hamonengine.geometry.vector2($x$$ + $offsetVector$$.x, $xOffset_y$$ + $offsetVector$$.y));
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.rotateAtCenter = function $hamonengine$geometry$polygon$$rotateAtCenter$($theta$$) {
    return this.rotate($theta$$, this.center);
  };
  hamonengine.geometry.polygon.prototype.scale = function $hamonengine$geometry$polygon$$scale$($scaleVector$$, $offsetVector$$) {
    $scaleVector$$ = $scaleVector$$ || new hamonengine.geometry.vector2(0, 0);
    $offsetVector$$ = $offsetVector$$ || new hamonengine.geometry.vector2(0, 0);
    var $i$1_i$$ = 0 > $scaleVector$$.x, $yFlipped$$ = 0 > $scaleVector$$.y, $newVertices$$ = [];
    if (!$i$1_i$$ && $yFlipped$$ || $i$1_i$$ & !$yFlipped$$) {
      for ($i$1_i$$ = this.vertices.length - 1; 0 <= $i$1_i$$; $i$1_i$$--) {
        $newVertices$$.push(this.vertices[$i$1_i$$].multiplyVector($scaleVector$$).add($offsetVector$$));
      }
    } else {
      for ($i$1_i$$ = 0; $i$1_i$$ < this.vertices.length; $i$1_i$$++) {
        $newVertices$$.push(this.vertices[$i$1_i$$].multiplyVector($scaleVector$$).add($offsetVector$$));
      }
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.scaleAtCenter = function $hamonengine$geometry$polygon$$scaleAtCenter$($scaleVector$$) {
    return this.scale($scaleVector$$, this.center.subtract(this.center.multiplyVector($scaleVector$$)));
  };
  hamonengine.geometry.polygon.prototype.mirror = function $hamonengine$geometry$polygon$$mirror$($state$$) {
    return $state$$ ? this.scaleAtCenter(new hamonengine.geometry.vector2(-1, 1)) : this;
  };
  hamonengine.geometry.polygon.prototype.flip = function $hamonengine$geometry$polygon$$flip$($state$$) {
    return $state$$ ? this.scaleAtCenter(new hamonengine.geometry.vector2(1, -1)) : this;
  };
  hamonengine.geometry.polygon.prototype.isCollision = function $hamonengine$geometry$polygon$$isCollision$($shape$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.geometry.vector2 : $direction$$;
    return $shape$$ instanceof hamonengine.geometry.rect ? $shape$$.toPolygon().isCollisionPolygon(this, $direction$$) : $shape$$ instanceof hamonengine.geometry.polygon ? this.isCollisionPolygon($shape$$, $direction$$) : $shape$$ instanceof hamonengine.geometry.lineSegment ? $shape$$.isCollision(this, $direction$$) : new hamonengine.geometry.vector2(0, 0);
  };
  hamonengine.geometry.polygon.prototype.isCollisionPolygon = function $hamonengine$geometry$polygon$$isCollisionPolygon$($mtv_polygon$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.geometry.vector2 : $direction$$;
    if (!($mtv_polygon$$ instanceof hamonengine.geometry.polygon)) {
      throw "Parameter polygon is not of type hamonengine.geometry.polygon.";
    }
    for (var $mnimumOverlappingLength$$ = NaN, $mtvAxis$$, $axes$$ = $mtv_polygon$$.normals, $i$2_i$$ = 0; $i$2_i$$ < $axes$$.length; $i$2_i$$++) {
      var $thisProjection$3_thisProjection$$ = this.project($axes$$[$i$2_i$$]), $otherProjection$4_otherProjection$$ = $mtv_polygon$$.project($axes$$[$i$2_i$$]), $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$ = $thisProjection$3_thisProjection$$.overlap($otherProjection$4_otherProjection$$);
      if (!$overlapping_overlapping$5_overlappingLength_overlappingLength$6$$.isLine) {
        return new hamonengine.geometry.vector2;
      }
      $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$ = $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$.length;
      if ($thisProjection$3_thisProjection$$.contains($otherProjection$4_otherProjection$$) || $otherProjection$4_otherProjection$$.contains($thisProjection$3_thisProjection$$)) {
        $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$ += $thisProjection$3_thisProjection$$.getMinimumDistance($otherProjection$4_otherProjection$$);
      }
      if (isNaN($mnimumOverlappingLength$$) || $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$ < $mnimumOverlappingLength$$) {
        $mnimumOverlappingLength$$ = $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$, $mtvAxis$$ = $axes$$[$i$2_i$$];
      }
    }
    $axes$$ = this.normals;
    for ($i$2_i$$ = 0; $i$2_i$$ < $axes$$.length; $i$2_i$$++) {
      $thisProjection$3_thisProjection$$ = this.project($axes$$[$i$2_i$$]);
      $otherProjection$4_otherProjection$$ = $mtv_polygon$$.project($axes$$[$i$2_i$$]);
      $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$ = $thisProjection$3_thisProjection$$.overlap($otherProjection$4_otherProjection$$);
      if (!$overlapping_overlapping$5_overlappingLength_overlappingLength$6$$.isLine) {
        return new hamonengine.geometry.vector2;
      }
      $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$ = $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$.length;
      if ($thisProjection$3_thisProjection$$.contains($otherProjection$4_otherProjection$$) || $otherProjection$4_otherProjection$$.contains($thisProjection$3_thisProjection$$)) {
        $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$ += $thisProjection$3_thisProjection$$.getMinimumDistance($otherProjection$4_otherProjection$$);
      }
      if (isNaN($mnimumOverlappingLength$$) || $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$ < $mnimumOverlappingLength$$) {
        $mnimumOverlappingLength$$ = $overlapping_overlapping$5_overlappingLength_overlappingLength$6$$, $mtvAxis$$ = $axes$$[$i$2_i$$];
      }
    }
    $mnimumOverlappingLength$$ = $mnimumOverlappingLength$$ < hamonengine.geometry.settings.collisionDetection.floor ? 0.0 : $mnimumOverlappingLength$$;
    $mtv_polygon$$ = $mtvAxis$$.multiply($mnimumOverlappingLength$$);
    0 <= $mtv_polygon$$.dot($direction$$) && ($mtv_polygon$$ = $mtv_polygon$$.invert());
    return $mtv_polygon$$;
  };
  hamonengine.geometry.polygon.prototype.isContained = function $hamonengine$geometry$polygon$$isContained$($shape$$) {
    return new hamonengine.geometry.vector2;
  };
  hamonengine.geometry.polygon.prototype.project = function $hamonengine$geometry$polygon$$project$($unitVector$$) {
    var $min$$ = 0, $max$$ = 0;
    if (0 < this.vertices.length) {
      $max$$ = $min$$ = $unitVector$$.dot(this.vertices[0]);
      for (var $i$$ = 1; $i$$ < this.vertices.length; $i$$++) {
        var $projection$$ = $unitVector$$.dot(this.vertices[$i$$]);
        $projection$$ < $min$$ ? $min$$ = $projection$$ : $projection$$ > $max$$ && ($max$$ = $projection$$);
      }
    }
    return new hamonengine.geometry.interval($min$$, $max$$);
  };
  hamonengine.geometry.polygon.calcEdges = function $hamonengine$geometry$polygon$calcEdges$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $edges$$ = [], $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      $edges$$.push($vertices$$[($i$$ + 1) % $vertices$$.length].subtract($vertices$$[$i$$]));
    }
    return $edges$$;
  };
  hamonengine.geometry.polygon.calcNormals = function $hamonengine$geometry$polygon$calcNormals$($edges$$) {
    $edges$$ = void 0 === $edges$$ ? [] : $edges$$;
    return $edges$$.map(function($edge$$) {
      return $edge$$.normal(ROTATION_TYPE.CW);
    });
  };
  hamonengine.geometry.polygon.calcDimensions = function $hamonengine$geometry$polygon$calcDimensions$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $minVertex$$ = null, $maxVertex$$ = null, $xMax$$ = NaN, $xMin$$ = NaN, $yMax$$ = NaN, $yMin$$ = NaN, $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      $xMax$$ = $xMax$$ > $vertices$$[$i$$].x ? $xMax$$ : $vertices$$[$i$$].x;
      $xMin$$ = $xMin$$ < $vertices$$[$i$$].x ? $xMin$$ : $vertices$$[$i$$].x;
      $yMax$$ = $yMax$$ > $vertices$$[$i$$].y ? $yMax$$ : $vertices$$[$i$$].y;
      $yMin$$ = $yMin$$ < $vertices$$[$i$$].y ? $yMin$$ : $vertices$$[$i$$].y;
      if (null === $minVertex$$ || $minVertex$$.x > $vertices$$[$i$$].x && $minVertex$$.y > $vertices$$[$i$$].y) {
        $minVertex$$ = $vertices$$[$i$$];
      }
      if (null === $maxVertex$$ || $maxVertex$$.x < $vertices$$[$i$$].x && $maxVertex$$.y < $vertices$$[$i$$].y) {
        $maxVertex$$ = $vertices$$[$i$$];
      }
    }
    return {max:new hamonengine.geometry.vector2($xMax$$, $yMax$$), min:new hamonengine.geometry.vector2($xMin$$, $yMin$$), center:new hamonengine.geometry.vector2($xMin$$ + ($xMax$$ - $xMin$$) / 2, $yMin$$ + ($yMax$$ - $yMin$$) / 2), minVertex:$minVertex$$, maxVertex:$maxVertex$$};
  };
  hamonengine.geometry.polygon.calcShapeType = function $hamonengine$geometry$polygon$calcShapeType$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $signCounter$$ = 0, $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      var $p2_v2$$ = $vertices$$[($i$$ + 1) % $vertices$$.length], $p3$$ = $vertices$$[($i$$ + 2) % $vertices$$.length], $v1$$ = $p2_v2$$.subtract($vertices$$[$i$$]);
      $p2_v2$$ = $p3$$.subtract($p2_v2$$);
      $signCounter$$ += 0 < $p2_v2$$.cross($v1$$).z ? 1 : -1;
    }
    return $vertices$$.length === $signCounter$$ ? SHAPE_TYPE.CONVEX : SHAPE_TYPE.CONCAVE;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.polygon.prototype, {vertices:{configurable:!0, enumerable:!0, get:function() {
    return this._vertices;
  }}, edges:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 2) && (this._edges = hamonengine.geometry.polygon.calcEdges(this.vertices), bitflag.toggle(this._dirty, 2, !1));
    return this._edges;
  }}, normals:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 0) && (this._normals = hamonengine.geometry.polygon.calcNormals(this.edges), bitflag.toggle(this._dirty, 0, !1));
    return this._normals;
  }}, center:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), bitflag.toggle(this._dirty, 1, !1));
    return this._dimensions.center;
  }}, max:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), bitflag.toggle(this._dirty, 1, !1));
    return this._dimensions.max;
  }}, min:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), bitflag.toggle(this._dirty, 1, !1));
    return this._dimensions.min;
  }}, minVertex:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), bitflag.toggle(this._dirty, 1, !1));
    return this._dimensions.minVertex;
  }}, maxVertex:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), bitflag.toggle(this._dirty, 1, !1));
    return this._dimensions.maxVertex;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this.max.x - this.min.x;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this.max.y - this.min.y;
  }}, shapeType:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 3) && (this._shapeType = hamonengine.geometry.polygon.calcShapeType(this.vertices), bitflag.toggle(this._dirty, 3, !1));
    return this._shapeType;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.rect = function $hamonengine$geometry$rect$($x$$, $y$$, $width$$, $height$$) {
    this.x = void 0 === $x$$ ? 0 : $x$$;
    this.y = void 0 === $y$$ ? 0 : $y$$;
    this.width = void 0 === $width$$ ? 0 : $width$$;
    this.height = void 0 === $height$$ ? 0 : $height$$;
  };
  hamonengine.geometry.rect.prototype.clone = function $hamonengine$geometry$rect$$clone$() {
    return new hamonengine.geometry.rect(this.x, this.y, this.width, this.height);
  };
  hamonengine.geometry.rect.prototype.toString = function $hamonengine$geometry$rect$$toString$() {
    return "{x: " + this.x + ", y: " + this.y + ", width: " + this.width + ", height: " + this.height + "}";
  };
  hamonengine.geometry.rect.prototype.toPolygon = function $hamonengine$geometry$rect$$toPolygon$() {
    return new hamonengine.geometry.polygon({vertices:[new hamonengine.geometry.vector2(this.x, this.y), new hamonengine.geometry.vector2(this.x + this.width, this.y), new hamonengine.geometry.vector2(this.x + this.width, this.y + this.height), new hamonengine.geometry.vector2(this.x, this.y + this.height)]});
  };
  hamonengine.geometry.rect.prototype.translate = function $hamonengine$geometry$rect$$translate$($translateVector$$) {
    $translateVector$$ = $translateVector$$ || new hamonengine.geometry.vector2(0, 0);
    return new hamonengine.geometry.rect(this.x + $translateVector$$.x, this.y + $translateVector$$.y, this.width, this.height);
  };
  hamonengine.geometry.rect.prototype.isCollision = function $hamonengine$geometry$rect$$isCollision$($shape$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.geometry.vector2 : $direction$$;
    return $shape$$ instanceof hamonengine.geometry.rect ? this.isCollisionRect($shape$$, $direction$$) : $shape$$ instanceof hamonengine.geometry.polygon ? $shape$$.isCollision(this, $direction$$) : $shape$$ instanceof hamonengine.geometry.vector2 ? this.isCollisionPoint($shape$$) : $shape$$ instanceof hamonengine.geometry.lineSegment ? $shape$$.isCollision(this, $direction$$) : new hamonengine.geometry.vector2(0, 0);
  };
  hamonengine.geometry.rect.prototype.isCollisionRect = function $hamonengine$geometry$rect$$isCollisionRect$($otherRect_other_XAxisProjection$$, $direction$$) {
    $direction$$ = void 0 === $direction$$ ? new hamonengine.geometry.vector2 : $direction$$;
    $otherRect_other_XAxisProjection$$ instanceof hamonengine.geometry.rect || console.warn("[hamonengine.geometry.rect.isCollision] The otherRect parameter is not of type hamonengine.geometry.rect!");
    var $mnimumOverlappingLength$jscomp$1_mtv$$ = NaN, $this_XAxisProjection_this_YAxisProjection$$ = new hamonengine.geometry.interval(this.y, this.y + this.height), $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ = new hamonengine.geometry.interval($otherRect_other_XAxisProjection$$.y, $otherRect_other_XAxisProjection$$.y + $otherRect_other_XAxisProjection$$.height), $overlappingYAxis_overlappingYAxisLength$$ = $this_XAxisProjection_this_YAxisProjection$$.overlap($other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$);
    if (!$overlappingYAxis_overlappingYAxisLength$$.isLine) {
      return new hamonengine.geometry.vector2;
    }
    $overlappingYAxis_overlappingYAxisLength$$ = $overlappingYAxis_overlappingYAxisLength$$.length;
    if ($this_XAxisProjection_this_YAxisProjection$$.contains($other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$) || $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.contains($this_XAxisProjection_this_YAxisProjection$$)) {
      $overlappingYAxis_overlappingYAxisLength$$ += $this_XAxisProjection_this_YAxisProjection$$.getMinimumDistance($other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$);
    }
    if (isNaN($mnimumOverlappingLength$jscomp$1_mtv$$) || $overlappingYAxis_overlappingYAxisLength$$ < $mnimumOverlappingLength$jscomp$1_mtv$$) {
      $mnimumOverlappingLength$jscomp$1_mtv$$ = $overlappingYAxis_overlappingYAxisLength$$;
      var $mtvAxis$$ = hamonengine.geometry.vector2.Y_AXIS_NORMAL;
    }
    $this_XAxisProjection_this_YAxisProjection$$ = new hamonengine.geometry.interval(this.x, this.x + this.width);
    $otherRect_other_XAxisProjection$$ = new hamonengine.geometry.interval($otherRect_other_XAxisProjection$$.x, $otherRect_other_XAxisProjection$$.x + $otherRect_other_XAxisProjection$$.width);
    $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ = $this_XAxisProjection_this_YAxisProjection$$.overlap($otherRect_other_XAxisProjection$$);
    if (!$other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.isLine) {
      return new hamonengine.geometry.vector2;
    }
    $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ = $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.length;
    if ($this_XAxisProjection_this_YAxisProjection$$.contains($otherRect_other_XAxisProjection$$) || $otherRect_other_XAxisProjection$$.contains($this_XAxisProjection_this_YAxisProjection$$)) {
      $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ += $this_XAxisProjection_this_YAxisProjection$$.getMinimumDistance($otherRect_other_XAxisProjection$$);
    }
    if (isNaN($mnimumOverlappingLength$jscomp$1_mtv$$) || $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ < $mnimumOverlappingLength$jscomp$1_mtv$$) {
      $mnimumOverlappingLength$jscomp$1_mtv$$ = $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$, $mtvAxis$$ = hamonengine.geometry.vector2.X_AXIS_NORMAL;
    }
    $mnimumOverlappingLength$jscomp$1_mtv$$ = $mnimumOverlappingLength$jscomp$1_mtv$$ < hamonengine.geometry.settings.collisionDetection.floor ? 0.0 : $mnimumOverlappingLength$jscomp$1_mtv$$;
    $mnimumOverlappingLength$jscomp$1_mtv$$ = $mtvAxis$$.multiply($mnimumOverlappingLength$jscomp$1_mtv$$);
    0 <= $mnimumOverlappingLength$jscomp$1_mtv$$.dot($direction$$) && ($mnimumOverlappingLength$jscomp$1_mtv$$ = $mnimumOverlappingLength$jscomp$1_mtv$$.invert());
    return $mnimumOverlappingLength$jscomp$1_mtv$$;
  };
  hamonengine.geometry.rect.prototype.isCollisionPoint = function $hamonengine$geometry$rect$$isCollisionPoint$($minY2_point$$) {
    var $outsideDirection$$ = new hamonengine.geometry.vector2;
    if ($minY2_point$$.x >= this.x && $minY2_point$$.x <= this.right && $minY2_point$$.y >= this.y && $minY2_point$$.y <= this.bottom) {
      var $minX_minY$$ = $minY2_point$$.x - this.x, $minX2$$ = this.right - $minY2_point$$.x;
      $outsideDirection$$.x = $minX_minY$$ < $minX2$$ ? $minX_minY$$ : $minX2$$;
      $minX_minY$$ = $minY2_point$$.y - this.y;
      $minY2_point$$ = this.bottom - $minY2_point$$.y;
      $outsideDirection$$.y = $minX_minY$$ < $minY2_point$$ ? $minX_minY$$ : $minY2_point$$;
    }
    return $outsideDirection$$;
  };
  hamonengine.geometry.rect.prototype.isContained = function $hamonengine$geometry$rect$$isContained$($position$$, $rect$$) {
    $rect$$ instanceof hamonengine.geometry.rect || console.warn("[hamonengine.geometry.rect.isContained] The rect parameter is not of type hamonengine.geometry.rect!");
    var $outsideDirection$$ = new hamonengine.geometry.vector2, $xOffset$$ = $position$$.x + $rect$$.x, $yOffset$$ = $position$$.y + $rect$$.y;
    $xOffset$$ < this.x ? (hamonengine.debug && console.debug("[hamonengine.geometry.rect.isContained] Outside -x: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.x = -1) : $position$$.x + $rect$$.right > this.right && (hamonengine.debug && console.debug("[hamonengine.geometry.rect.isContained] Outside +x: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.x = 1);
    $yOffset$$ < this.y ? (hamonengine.debug && console.debug("[hamonengine.geometry.rect.isContained] Outside -y: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.y = -1) : $position$$.y + $rect$$.bottom > this.bottom && (hamonengine.debug && console.debug("[hamonengine.geometry.rect.isContained] Outside +y: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.y = 1);
    return $outsideDirection$$;
  };
  hamonengine.geometry.rect.prototype.project = function $hamonengine$geometry$rect$$project$($unitVector$$) {
    var $min$$ = max = $unitVector$$.dot(new hamonengine.geometry.vector2(this.x, this.y)), $calcProjections$$ = function $$calcProjections$$$($dotProduct_vector$$) {
      $dotProduct_vector$$ = $unitVector$$.dot($dotProduct_vector$$);
      $dotProduct_vector$$ < $min$$ ? $min$$ = $dotProduct_vector$$ : $dotProduct_vector$$ > max && (max = $dotProduct_vector$$);
    };
    $calcProjections$$(new hamonengine.geometry.vector2(this.x + this.width, this.y));
    $calcProjections$$(new hamonengine.geometry.vector2(this.x + this.width, this.y + this.height));
    $calcProjections$$(new hamonengine.geometry.vector2(this.x, this.y + this.height));
    return new hamonengine.geometry.interval($min$$, max);
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.rect.prototype, {right:{configurable:!0, enumerable:!0, get:function() {
    return this.x + this.width;
  }}, bottom:{configurable:!0, enumerable:!0, get:function() {
    return this.y + this.height;
  }}});
})();
var COORDINATE_SYSTEM = {LHS:0, RHS:1}, COLLISION_TYPES = {NONE:0, EDGE:1, INSIDE:2}, SHAPE_TYPE = {UNKNOWN:0, CONVEX:1, CONCAVE:2}, ROTATION_TYPE = {CW:0, CCW:1};
hamonengine.geometry = hamonengine.geometry || {};
hamonengine.geometry.settings = hamonengine.geometry.settings || {collisionDetection:{floor:0.01, limit:15}, coordinateSystem:COORDINATE_SYSTEM.RHS};
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.vector2 = function $hamonengine$geometry$vector2$($x$$, $y$$) {
    this.x = void 0 === $x$$ ? 0.0 : $x$$;
    this.y = void 0 === $y$$ ? 0.0 : $y$$;
  };
  hamonengine.geometry.vector2.clone = function $hamonengine$geometry$vector2$clone$($vector$$) {
    return new hamonengine.geometry.vector2($vector$$.x, $vector$$.y);
  };
  hamonengine.geometry.vector2.prototype.clone = function $hamonengine$geometry$vector2$$clone$() {
    return hamonengine.geometry.vector2.clone(this);
  };
  hamonengine.geometry.vector2.prototype.toString = function $hamonengine$geometry$vector2$$toString$() {
    return "{x: '" + this.x + "', y: '" + this.y + "'}";
  };
  hamonengine.geometry.vector2.prototype.normalize = function $hamonengine$geometry$vector2$$normalize$() {
    var $l$$ = this.length;
    return 0 < $l$$ ? new hamonengine.geometry.vector2(this.x / $l$$, this.y / $l$$) : new hamonengine.geometry.vector2;
  };
  hamonengine.geometry.vector2.prototype.normal = function $hamonengine$geometry$vector2$$normal$($rotationType$$) {
    $rotationType$$ = void 0 === $rotationType$$ ? ROTATION_TYPE.CCW : $rotationType$$;
    var $l$$ = this.length;
    return 0 < $l$$ ? $rotationType$$ === ROTATION_TYPE.CCW ? new hamonengine.geometry.vector2(-this.y / $l$$, this.x / $l$$) : new hamonengine.geometry.vector2(this.y / $l$$, -this.x / $l$$) : new hamonengine.geometry.vector2;
  };
  hamonengine.geometry.vector2.prototype.mirror = function $hamonengine$geometry$vector2$$mirror$() {
    return new hamonengine.geometry.vector2(-this.x, this.y);
  };
  hamonengine.geometry.vector2.prototype.flip = function $hamonengine$geometry$vector2$$flip$() {
    return new hamonengine.geometry.vector2(this.x, -this.y);
  };
  hamonengine.geometry.vector2.prototype.invert = function $hamonengine$geometry$vector2$$invert$() {
    return new hamonengine.geometry.vector2(-this.x, -this.y);
  };
  hamonengine.geometry.vector2.prototype.add = function $hamonengine$geometry$vector2$$add$($v$$) {
    return new hamonengine.geometry.vector2(this.x + $v$$.x, this.y + $v$$.y);
  };
  hamonengine.geometry.vector2.prototype.subtract = function $hamonengine$geometry$vector2$$subtract$($v$$) {
    return new hamonengine.geometry.vector2(this.x - $v$$.x, this.y - $v$$.y);
  };
  hamonengine.geometry.vector2.prototype.multiply = function $hamonengine$geometry$vector2$$multiply$($vos$$) {
    return $vos$$ instanceof hamonengine.geometry.vector2 ? this.multiplyVector($vos$$) : this.multiplyScalar($vos$$);
  };
  hamonengine.geometry.vector2.prototype.multiplyScalar = function $hamonengine$geometry$vector2$$multiplyScalar$($s$$) {
    return new hamonengine.geometry.vector2(this.x * $s$$, this.y * $s$$);
  };
  hamonengine.geometry.vector2.prototype.multiplyVector = function $hamonengine$geometry$vector2$$multiplyVector$($v$$) {
    return new hamonengine.geometry.vector2(this.x * $v$$.x, this.y * $v$$.y);
  };
  hamonengine.geometry.vector2.prototype.dot = function $hamonengine$geometry$vector2$$dot$($v$$) {
    return this.x * $v$$.x + this.y * $v$$.y;
  };
  hamonengine.geometry.vector2.prototype.cross = function $hamonengine$geometry$vector2$$cross$($v$$) {
    return new hamonengine.geometry.vector3(0, 0, this.x * $v$$.y - this.y * $v$$.x);
  };
  hamonengine.geometry.vector2.prototype.equals = function $hamonengine$geometry$vector2$$equals$($v$$) {
    return this.x === $v$$.x && this.y === $v$$.y;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.vector2.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return (Math.atan2(this.y, this.x) + Math.PI2) % Math.PI2;
  }}, midPoint:{configurable:!0, enumerable:!0, get:function() {
    return new hamonengine.geometry.vector2(this.x / 2, this.y / 2);
  }}, min:{configurable:!0, enumerable:!0, get:function() {
    return this.x < this.y ? this.x : this.y;
  }}, max:{configurable:!0, enumerable:!0, get:function() {
    return this.x > this.y ? this.x : this.y;
  }}});
  hamonengine.geometry.vector2.X_AXIS_NORMAL = new hamonengine.geometry.vector2(1, 0);
  hamonengine.geometry.vector2.Y_AXIS_NORMAL = new hamonengine.geometry.vector2(0, 1);
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.vector3 = function $hamonengine$geometry$vector3$($x$$, $y$$, $z$$) {
    this.x = void 0 === $x$$ ? 0.0 : $x$$;
    this.y = void 0 === $y$$ ? 0.0 : $y$$;
    this.z = void 0 === $z$$ ? 0.0 : $z$$;
  };
  hamonengine.geometry.vector3.clone = function $hamonengine$geometry$vector3$clone$($vector$$) {
    return new hamonengine.geometry.vector3($vector$$.x, $vector$$.y, $vector$$.z);
  };
  hamonengine.geometry.vector3.prototype.clone = function $hamonengine$geometry$vector3$$clone$() {
    return hamonengine.geometry.vector3.clone(this);
  };
  hamonengine.geometry.vector3.prototype.toString = function $hamonengine$geometry$vector3$$toString$() {
    return "{x: '" + this.x + "', y: '" + this.y + "', z: '" + this.z + "'}";
  };
  hamonengine.geometry.vector3.prototype.normalize = function $hamonengine$geometry$vector3$$normalize$() {
    var $l$$ = this.length;
    return 0 < $l$$ ? new hamonengine.geometry.vector3(this.x / $l$$, this.y / $l$$, this.z / $l$$) : new hamonengine.geometry.vector3;
  };
  hamonengine.geometry.vector3.prototype.invert = function $hamonengine$geometry$vector3$$invert$() {
    return new hamonengine.geometry.vector2(-this.x, -this.y, -this.z);
  };
  hamonengine.geometry.vector3.prototype.add = function $hamonengine$geometry$vector3$$add$($v$$) {
    return new hamonengine.geometry.vector3(this.x + $v$$.x, this.y + $v$$.y, this.z + $v$$.z);
  };
  hamonengine.geometry.vector3.prototype.subtract = function $hamonengine$geometry$vector3$$subtract$($v$$) {
    return new hamonengine.geometry.vector3(this.x - $v$$.x, this.y - $v$$.y, this.z - $v$$.z);
  };
  hamonengine.geometry.vector3.prototype.multiplyScalar = function $hamonengine$geometry$vector3$$multiplyScalar$($s$$) {
    return new hamonengine.geometry.vector3(this.x * $s$$, this.y * $s$$, this.z * $s$$);
  };
  hamonengine.geometry.vector3.prototype.multiplyVector = function $hamonengine$geometry$vector3$$multiplyVector$($v$$) {
    return new hamonengine.geometry.vector3(this.x * $v$$.x, this.y * $v$$.y, this.z * $v$$.z);
  };
  hamonengine.geometry.vector3.prototype.dot = function $hamonengine$geometry$vector3$$dot$($v$$) {
    return this.x * $v$$.x + this.y * $v$$.y + this.z * $v$$.z;
  };
  hamonengine.geometry.vector3.prototype.cross = function $hamonengine$geometry$vector3$$cross$($v$$) {
    return new hamonengine.geometry.vector3(this.y * $v$$.z - this.z * $v$$.y, $v$$.x * this.z - this.x * $v$$.z, this.x * $v$$.y - this.y * $v$$.x);
  };
  hamonengine.geometry.vector3.prototype.equals = function $hamonengine$geometry$vector3$$equals$($v$$) {
    return this.x === $v$$.x && this.y === $v$$.y && this.z === $v$$.z;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.vector3.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }}, midPoint:{configurable:!0, enumerable:!0, get:function() {
    return new hamonengine.geometry.vector3(this.x / 2, this.y / 2, this.z / 2);
  }}, min:{configurable:!0, enumerable:!0, get:function() {
    var $min$$ = this.x < this.y ? this.x : this.y;
    return $min$$ < this.z ? $min$$ : this.z;
  }}, max:{configurable:!0, enumerable:!0, get:function() {
    var $max$$ = this.x > this.y ? this.x : this.y;
    return $max$$ > this.z ? $max$$ : this.z;
  }}});
  hamonengine.geometry.vector3.X_AXIS_NORMAL = new hamonengine.geometry.vector3(1, 0, 0);
  hamonengine.geometry.vector3.Y_AXIS_NORMAL = new hamonengine.geometry.vector3(0, 1, 0);
  hamonengine.geometry.vector3.Z_AXIS_NORMAL = new hamonengine.geometry.vector3(0, 0, 1);
})();
hamonengine.graphics = hamonengine.graphics || {};
var BLENDING_OPS = {REPLACE:0, ADD:1, MULTIPLY:2, OR:3, AND:4, XOR:5, DIFFERENCE:6}, TEXT_DRAW_TYPE = {STROKE:0, FILL:1};
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.imageext = function $hamonengine$graphics$imageext$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.graphics.imageext && ($options$$ = {image:$options$$._image});
    this._image = $options$$.image || new Image;
    this._state = 0;
    this._backbufferCtx = this._backbufferResource = null;
    hamonengine.debug && hamonengine.verbose && console.debug("[hamonengine.graphics.imageext.constructor] Starting State: {" + this._state + "}");
  };
  hamonengine.graphics.imageext.prototype.clone = function $hamonengine$graphics$imageext$$clone$() {
    return new hamonengine.graphics.imageext(this);
  };
  hamonengine.graphics.imageext.prototype.load = function $hamonengine$graphics$imageext$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return "" !== $src$$ && ($$jscomp$async$this$$._image.src = $src$$), $$jscomp$async$this$$._state = 1, $$jscomp$generator$state$$ = -1, {value:new Promise(function($resolve$$, $reject$$) {
                $$jscomp$async$this$$.complete ? ($$jscomp$async$this$$._state = 2, $resolve$$()) : ($$jscomp$async$this$$.image.addEventListener("load", function() {
                  $$jscomp$async$this$$._state = 2;
                  hamonengine.debug && console.debug("[hamonengine.graphics.imageext.load] Image '" + $src$$ + "' has loaded successfully.");
                  $resolve$$();
                }, !1), $$jscomp$async$this$$.image.addEventListener("error", function($error$$) {
                  $$jscomp$async$this$$._state = 3;
                  $reject$$("The image '" + ($error$$ && $error$$.path && 0 < $error$$.path.length && $error$$.path[0].src || "") + "' could not be loaded.");
                }, !1));
              }), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.graphics.imageext.prototype.getImageData = function $hamonengine$graphics$imageext$$getImageData$($region$$) {
    this._backbufferResource = this._backbufferResource || hamonengine.graphics.layer.createNewCanvas(this.rawImage.width, this.rawImage.height);
    this._backbufferCtx = this._backbufferCtx || this._backbufferResource.getContext("2d");
    this._backbufferCtx.drawImage(this.rawImage, 0, 0);
    $region$$ = $region$$ || new hamonengine.geometry.rect;
    return this._backbufferCtx.getImageData($region$$.x, $region$$.y, $region$$.width || this.rawImage.width, $region$$.height || this.rawImage.height);
  };
  hamonengine.graphics.imageext.prototype.blendColorRegion = function $hamonengine$graphics$imageext$$blendColorRegion$($r$$, $g$$, $b$$, $a$$, $region$$, $blendingOps_data$$) {
    $r$$ = void 0 === $r$$ ? 0 : $r$$;
    $g$$ = void 0 === $g$$ ? 0 : $g$$;
    $b$$ = void 0 === $b$$ ? 0 : $b$$;
    $a$$ = void 0 === $a$$ ? 0 : $a$$;
    $region$$ = void 0 === $region$$ ? null : $region$$;
    $blendingOps_data$$ = void 0 === $blendingOps_data$$ ? BLENDING_OPS.REPLACE : $blendingOps_data$$;
    if (this.complete) {
      var $sourceData$$ = this.getImageData($region$$), $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
        return 0 < $s$$ ? $s$$ : $d$$;
      };
      switch($blendingOps_data$$) {
        case BLENDING_OPS.ADD:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ + $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.MULTIPLY:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ * $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.AND:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ & $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.OR:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ | $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.XOR:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ ^ $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.DIFFERENCE:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ - $d$$, 255) : $d$$;
          };
      }
      $blendingOps_data$$ = $sourceData$$.data;
      for (var $i$$ = 0; $i$$ < $blendingOps_data$$.length; $i$$ += 4) {
        $blendingOps_data$$[$i$$] = $blendingMethod$$($r$$, $blendingOps_data$$[$i$$]), $blendingOps_data$$[$i$$ + 1] = $blendingMethod$$($g$$, $blendingOps_data$$[$i$$ + 1]), $blendingOps_data$$[$i$$ + 2] = $blendingMethod$$($b$$, $blendingOps_data$$[$i$$ + 2]), $blendingOps_data$$[$i$$ + 3] = $blendingMethod$$($a$$, $blendingOps_data$$[$i$$ + 3]);
      }
      this._backbufferCtx.putImageData($sourceData$$, $region$$.x, $region$$.y);
    }
  };
  hamonengine.graphics.imageext.prototype.adjustColorChannel = function $hamonengine$graphics$imageext$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$, $region$$) {
    $r$$ = void 0 === $r$$ ? 1.0 : $r$$;
    $g$$ = void 0 === $g$$ ? 1.0 : $g$$;
    $b$$ = void 0 === $b$$ ? 1.0 : $b$$;
    $a$$ = void 0 === $a$$ ? 1.0 : $a$$;
    $region$$ = void 0 === $region$$ ? null : $region$$;
    if (this.complete) {
      for (var $sourceData$$ = this.getImageData($region$$), $data$$ = $sourceData$$.data, $i$$ = 0; $i$$ < $data$$.length; $i$$ += 4) {
        $data$$[$i$$] = Math.bitRound($data$$[$i$$] * $r$$), $data$$[$i$$ + 1] = Math.bitRound($data$$[$i$$ + 1] * $g$$), $data$$[$i$$ + 2] = Math.bitRound($data$$[$i$$ + 2] * $b$$), $data$$[$i$$ + 3] = Math.bitRound($data$$[$i$$ + 3] * $a$$);
      }
      this._backbufferCtx.putImageData($sourceData$$, $region$$.x, $region$$.y, $region$$.x, $region$$.y, $region$$.width, $region$$.height);
    }
  };
  hamonengine.graphics.imageext.prototype.bitblit = function $hamonengine$graphics$imageext$$bitblit$($destData_imageData$$, $srcRegion$$, $destRegion$$, $transparency$$) {
    if (this.complete && $destData_imageData$$.complete) {
      $destData_imageData$$ instanceof hamonengine.graphics.imageext && ($destData_imageData$$ = $destData_imageData$$.rawImage);
      $transparency$$ = Math.max(Math.min(void 0 === $transparency$$ ? 1.0 : $transparency$$, 1.0), 0.0);
      var $destImageData$$ = this.getImageData($destRegion$$), $srcData_srcImageData_targetCtx$$ = hamonengine.graphics.layer.createNewCanvas($destData_imageData$$.width, $destData_imageData$$.height).getContext("2d");
      $srcData_srcImageData_targetCtx$$.drawImage($destData_imageData$$, 0, 0);
      $srcData_srcImageData_targetCtx$$ = $srcData_srcImageData_targetCtx$$.getImageData($srcRegion$$.x, $srcRegion$$.y, $srcRegion$$.width, $srcRegion$$.height);
      $destData_imageData$$ = $destImageData$$.data;
      $srcData_srcImageData_targetCtx$$ = $srcData_srcImageData_targetCtx$$.data;
      for (var $row$$ = 0; $row$$ < $destRegion$$.height && !($row$$ >= $srcRegion$$.height); $row$$++) {
        for (var $col$$ = 0; $col$$ < $destRegion$$.width && !($col$$ >= $srcRegion$$.width); $col$$++) {
          var $destIndex$$ = 4 * ($row$$ * $destRegion$$.width + $col$$), $srcIndex$$ = 4 * ($row$$ * $srcRegion$$.width + $col$$), $transparencyComplement$$ = 0 < $srcData_srcImageData_targetCtx$$[$srcIndex$$ + 3] ? 1.0 - $transparency$$ : 1.0;
          $destData_imageData$$[$destIndex$$] = Math.bitRound($destData_imageData$$[$destIndex$$] * $transparencyComplement$$ + $srcData_srcImageData_targetCtx$$[$srcIndex$$] * $transparency$$);
          $destData_imageData$$[$destIndex$$ + 1] = Math.bitRound($destData_imageData$$[$destIndex$$ + 1] * $transparencyComplement$$ + $srcData_srcImageData_targetCtx$$[$srcIndex$$ + 1] * $transparency$$);
          $destData_imageData$$[$destIndex$$ + 2] = Math.bitRound($destData_imageData$$[$destIndex$$ + 2] * $transparencyComplement$$ + $srcData_srcImageData_targetCtx$$[$srcIndex$$ + 2] * $transparency$$);
        }
      }
      this._backbufferCtx.putImageData($destImageData$$, $destRegion$$.x, $destRegion$$.y);
    }
  };
  hamonengine.graphics.imageext.prototype.draw = function $hamonengine$graphics$imageext$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this.width : $width$$;
    $height$$ = void 0 === $height$$ ? this.height : $height$$;
    $layer$$.drawImage(this, $x$$, $y$$, this.width, this.height, destinationX, destinationY, $width$$, $height$$);
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.imageext.prototype, {src:{configurable:!0, enumerable:!0, get:function() {
    return this._image.src;
  }}, complete:{configurable:!0, enumerable:!0, get:function() {
    return this._image.complete;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return 2 === this._state;
  }}, image:{configurable:!0, enumerable:!0, get:function() {
    return this._backbufferResource ? this._backbufferResource : this._image;
  }}, rawImage:{configurable:!0, enumerable:!0, get:function() {
    return this._image;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this.image.width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this.image.height;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.layer = function $hamonengine$graphics$layer$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._canvasId = $options$$.canvasId || "";
    this._name = $options$$.name || "";
    this._alpha = void 0 !== $options$$.alpha ? $options$$.alpha : !1;
    this._backgroundColor = $options$$.backgroundColor || "black";
    this._allowEventBinding = void 0 !== $options$$.allowEventBinding ? $options$$.allowEventBinding : !1;
    this._wrapVertical = void 0 !== $options$$.wrapVertical ? $options$$.wrapVertical : !1;
    this._wrapHorizontal = void 0 !== $options$$.wrapHorizontal ? $options$$.wrapHorizontal : !1;
    this._clipToViewPort = void 0 !== $options$$.clipToViewPort ? $options$$.clipToViewPort : !0;
    this._enableImageSmoothing = void 0 !== $options$$.enableImageSmoothing ? $options$$.enableImageSmoothing : !0;
    this._invertYAxis = void 0 !== $options$$.invertYAxis ? $options$$.invertYAxis : !1;
    this._invertXAxis = void 0 !== $options$$.invertXAxis ? $options$$.invertXAxis : !1;
    var $canvas$$ = $options$$.canvas;
    if (!this._canvasId && !$canvas$$) {
      throw console.error("[hamonengine.graphics.layer.constructor] Invalid canvasId '" + this._canvasId + "' or canvas. Unable to create the layer!"), "Cannot create the layer";
    }
    $canvas$$ ? (this._canvas = $canvas$$, this._canvasId = $canvas$$.id, this._name = $options$$.name || $canvas$$.getAttribute("name")) : this._canvas = document.getElementById(this._canvasId);
    if (!this._canvas) {
      throw console.error("[hamonengine.graphics.layer.constructor] Invalid canvas: '" + this._canvasId + "' unable to create the layer!"), "Cannot create the layer";
    }
    try {
      this._alpha ? this._canvasContext = this._canvas.getContext("2d", {alpha:this._alpha}) : (this._workAround = !0, this._canvasContext = this._canvas.getContext("2d"));
    } catch ($err$$) {
    }
    this.enableImageSmoothing($options$$.enableImageSmoothing);
    if (!this._canvasContext) {
      throw console.error("[hamonengine.graphics.layer.constructor] Unable to get the 2d context: '" + this._canvasId + "' unable to create the layer!"), "Cannot create the layer";
    }
    this._viewPort = $options$$.viewPort || new hamonengine.geometry.rect(0, 0, this._canvas.width, this._canvas.height);
    this._wasReset = !1;
    this._allowSaveStateEnabled = !0;
    this._viewPortBorderColor = "";
    hamonengine.debug && (console.debug("[hamonengine.graphics.layer.constructor] Canvas Id: " + this._canvasId), console.debug("[hamonengine.graphics.layer.constructor] Name: " + this._name), console.debug("[hamonengine.graphics.layer.constructor] Alpha: " + this._alpha), console.debug("[hamonengine.graphics.layer.constructor] AllowEventBinding: " + this._allowEventBinding), console.debug("[hamonengine.graphics.layer.constructor] WrapVertical: " + this._wrapVertical), console.debug("[hamonengine.graphics.layer.constructor] WrapHorizontal: " + 
    this._wrapHorizontal), console.debug("[hamonengine.graphics.layer.constructor] ClipToViewPort: " + this._clipToViewPort));
  };
  hamonengine.graphics.layer.createNewCanvas = function $hamonengine$graphics$layer$createNewCanvas$($width$$, $height$$, $id$$, $name$$) {
    $id$$ = void 0 === $id$$ ? "" : $id$$;
    $name$$ = void 0 === $name$$ ? "" : $name$$;
    var $canvas$$ = document.createElement("canvas");
    $canvas$$.setAttribute("width", $width$$);
    $canvas$$.setAttribute("height", $height$$);
    $id$$ && $canvas$$.setAttribute("id", $id$$);
    $name$$ && $canvas$$.setAttribute("name", $name$$);
    return $canvas$$;
  };
  hamonengine.graphics.layer.prototype.clone = function $hamonengine$graphics$layer$$clone$($canvasId_newLayer$$, $name$$, $elementToAttach$$) {
    $elementToAttach$$ = void 0 === $elementToAttach$$ ? null : $elementToAttach$$;
    var $newCanvas$$ = hamonengine.graphics.layer.createNewCanvas(this.width, this.height, $canvasId_newLayer$$, $name$$);
    $elementToAttach$$ && $elementToAttach$$.insertBefore($newCanvas$$, null);
    $canvasId_newLayer$$ = new hamonengine.graphics.layer({canvasId:$canvasId_newLayer$$, name:$name$$, canvas:$newCanvas$$, alpha:this.alpha, allowEventBinding:this.allowEventBinding, wrapVertical:this.wrapVertical, wrapHorizontal:this.wrapHorizontal, clipToViewPort:this.clipToViewPort, enableImageSmoothing:this._enableImageSmoothing, invertYAxis:this.invertYAxis, invertXAxis:this.invertXAxis, viewPort:this.viewPort});
    $canvasId_newLayer$$._allowSaveStateEnabled = this._allowSaveStateEnabled;
    $canvasId_newLayer$$._viewPortBorderColor = this._viewPortBorderColor;
    return $canvasId_newLayer$$;
  };
  hamonengine.graphics.layer.prototype.enableImageSmoothing = function $hamonengine$graphics$layer$$enableImageSmoothing$($enable$$) {
    $enable$$ = void 0 === $enable$$ ? !0 : $enable$$;
    hamonengine.debug && console.debug("[hamonengine.graphics.layer.constructor] EnableImageSmoothing: " + $enable$$);
    this._enableImageSmoothing = $enable$$;
    try {
      this.context.webkitImageSmoothingEnabled = $enable$$, this.context.mozImageSmoothingEnabled = $enable$$, this.context.imageSmoothingEnabled = $enable$$;
    } catch ($err$$) {
    }
  };
  hamonengine.graphics.layer.prototype.clear = function $hamonengine$graphics$layer$$clear$($x$$, $y$$, $width$$, $height$$) {
    $x$$ = void 0 === $x$$ ? this.viewPort.x : $x$$;
    $y$$ = void 0 === $y$$ ? this.viewPort.y : $y$$;
    $width$$ = void 0 === $width$$ ? this.viewPort.width : $width$$;
    $height$$ = void 0 === $height$$ ? this.viewPort.height : $height$$;
    this._wasReset = !1;
    this.context.clearRect($x$$, $y$$, $width$$, $height$$);
    if (this._workAround) {
      var $originalFillStyle$$ = this.context.fillStyle;
      this.context.fillStyle = this._backgroundColor;
      this.context.fillRect($x$$, $y$$, $width$$, $height$$);
      this.context.fillStyle = $originalFillStyle$$;
    }
  };
  hamonengine.graphics.layer.prototype.reset = function $hamonengine$graphics$layer$$reset$() {
    this._wasReset || (this.context.resetTransform(), this._wasReset = !0);
  };
  hamonengine.graphics.layer.prototype.save = function $hamonengine$graphics$layer$$save$() {
    this.allowSaveState && this.context.save();
  };
  hamonengine.graphics.layer.prototype.restore = function $hamonengine$graphics$layer$$restore$() {
    this.allowSaveState && this.context.restore();
  };
  hamonengine.graphics.layer.prototype.fillLayerImage = function $hamonengine$graphics$layer$$fillLayerImage$($image$$, $x$$, $y$$) {
    $x$$ = void 0 === $x$$ ? this.viewPort.x : $x$$;
    $y$$ = void 0 === $y$$ ? this.viewPort.y : $y$$;
    this.context.drawImage($image$$, $x$$, $y$$, this.viewPort.width, this.viewPort.height);
  };
  hamonengine.graphics.layer.prototype.beginPainting = function $hamonengine$graphics$layer$$beginPainting$() {
    this.clear();
    this.borderColor && (this.context.strokeStyle = this.borderColor, this.context.strokeRect(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height));
    !this.clipToViewPort || 0 === this.viewPort.x && 0 === this.viewPort.y && this.viewPort.width === this.width && this.viewPort.height === this.height || (this.context.beginPath(), this.context.rect(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height), this.context.clip());
  };
  hamonengine.graphics.layer.prototype.endPainting = function $hamonengine$graphics$layer$$endPainting$() {
    this.reset();
  };
  hamonengine.graphics.layer.prototype.drawLayer = function $hamonengine$graphics$layer$$drawLayer$($layer$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$) {
    $destinationWidth$$ = void 0 === $destinationWidth$$ ? this.width : $destinationWidth$$;
    $destinationHeight$$ = void 0 === $destinationHeight$$ ? this.height : $destinationHeight$$;
    if (!($layer$$ instanceof hamonengine.graphics.layer)) {
      throw "Parameter layer is not of type hamonengine.graphics.layer.";
    }
    this.context.drawImage($layer$$.canvas, void 0 === $destinationX$$ ? 0 : $destinationX$$, void 0 === $destinationY$$ ? 0 : $destinationY$$, $destinationWidth$$, $destinationHeight$$);
  };
  hamonengine.graphics.layer.prototype.drawText = function $hamonengine$graphics$layer$$drawText$($text$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var15_color$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var16_metrics_metrics$7$$ = void 0 === $$jscomp$destructuring$var15_color$$ ? {} : $$jscomp$destructuring$var15_color$$;
    $$jscomp$destructuring$var15_color$$ = void 0 === $$jscomp$destructuring$var16_metrics_metrics$7$$.color ? "white" : $$jscomp$destructuring$var16_metrics_metrics$7$$.color;
    var $textDrawType$$ = void 0 === $$jscomp$destructuring$var16_metrics_metrics$7$$.textDrawType ? TEXT_DRAW_TYPE.FILL : $$jscomp$destructuring$var16_metrics_metrics$7$$.textDrawType, $textOffset$$ = void 0 === $$jscomp$destructuring$var16_metrics_metrics$7$$.textOffset ? "left" : $$jscomp$destructuring$var16_metrics_metrics$7$$.textOffset;
    this.context.font = void 0 === $$jscomp$destructuring$var16_metrics_metrics$7$$.font ? "16px serif" : $$jscomp$destructuring$var16_metrics_metrics$7$$.font;
    this.context.textBaseline = "top";
    switch($textOffset$$) {
      case "center":
        $$jscomp$destructuring$var16_metrics_metrics$7$$ = this.context.measureText($text$$);
        $sourceX$$ -= $$jscomp$destructuring$var16_metrics_metrics$7$$.width / 2;
        break;
      case "left":
        break;
      case "right":
        $$jscomp$destructuring$var16_metrics_metrics$7$$ = this.context.measureText($text$$);
        $sourceX$$ -= $$jscomp$destructuring$var16_metrics_metrics$7$$.width;
        break;
      default:
        $sourceX$$ -= parseInt($textOffset$$);
    }
    $textDrawType$$ === TEXT_DRAW_TYPE.STROKE ? (this.context.strokeStyle = $$jscomp$destructuring$var15_color$$, this.context.strokeText($text$$, $sourceX$$, $sourceY$$)) : (this.context.fillStyle = $$jscomp$destructuring$var15_color$$, this.context.fillText($text$$, $sourceX$$, $sourceY$$));
  };
  hamonengine.graphics.layer.prototype.drawImage = function $hamonengine$graphics$layer$$drawImage$($image$$, $sourceX$$, $sourceY$$, $sourceWidth$$, $sourceHeight$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$) {
    $image$$.complete && this.context.drawImage($image$$ instanceof hamonengine.graphics.imageext ? $image$$.image : $image$$, $sourceX$$, $sourceY$$, $sourceWidth$$, $sourceHeight$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$);
  };
  hamonengine.graphics.layer.prototype.drawVector = function $hamonengine$graphics$layer$$drawVector$($vector$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var17_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var18_color$$ = void 0 === $$jscomp$destructuring$var17_lineWidth$$ ? {} : $$jscomp$destructuring$var17_lineWidth$$;
    $$jscomp$destructuring$var17_lineWidth$$ = void 0 === $$jscomp$destructuring$var18_color$$.lineWidth ? 1 : $$jscomp$destructuring$var18_color$$.lineWidth;
    $$jscomp$destructuring$var18_color$$ = void 0 === $$jscomp$destructuring$var18_color$$.color ? "white" : $$jscomp$destructuring$var18_color$$.color;
    if (!($vector$$ instanceof hamonengine.geometry.vector2 || $vector$$ instanceof hamonengine.geometry.vector3)) {
      throw "Parameter vector is not of type hamonengine.geometry.vector2 or of type hamonengine.geometry.vector3.";
    }
    this.context.lineWidth = $$jscomp$destructuring$var17_lineWidth$$;
    this.context.strokeStyle = $$jscomp$destructuring$var18_color$$;
    this.context.beginPath();
    this.context.moveTo($sourceX$$, $sourceY$$);
    this.context.lineTo($sourceX$$ + $vector$$.x, $sourceY$$ + $vector$$.y);
    this.context.stroke();
  };
  hamonengine.graphics.layer.prototype.drawLineSegment = function $hamonengine$graphics$layer$$drawLineSegment$($lineSegment_normalSize$$, $sourceX$jscomp$3_x2$$, $sourceY$jscomp$3_x$jscomp$89_y2$$, $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$) {
    $sourceX$jscomp$3_x2$$ = void 0 === $sourceX$jscomp$3_x2$$ ? 0 : $sourceX$jscomp$3_x2$$;
    $sourceY$jscomp$3_x$jscomp$89_y2$$ = void 0 === $sourceY$jscomp$3_x$jscomp$89_y2$$ ? 0 : $sourceY$jscomp$3_x$jscomp$89_y2$$;
    var $$jscomp$destructuring$var20_color$jscomp$4_y1$$ = void 0 === $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$ ? {} : $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$, $lineWidth$jscomp$1_normal_x1$$ = void 0 === $$jscomp$destructuring$var20_color$jscomp$4_y1$$.lineWidth ? 1 : $$jscomp$destructuring$var20_color$jscomp$4_y1$$.lineWidth;
    $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$ = void 0 === $$jscomp$destructuring$var20_color$jscomp$4_y1$$.drawNormals ? !0 : $$jscomp$destructuring$var20_color$jscomp$4_y1$$.drawNormals;
    $$jscomp$destructuring$var20_color$jscomp$4_y1$$ = void 0 === $$jscomp$destructuring$var20_color$jscomp$4_y1$$.color ? "white" : $$jscomp$destructuring$var20_color$jscomp$4_y1$$.color;
    if (!($lineSegment_normalSize$$ instanceof hamonengine.geometry.lineSegment)) {
      throw "Parameter lineSegment is not of type hamonengine.geometry.lineSegment.";
    }
    this.context.lineWidth = $lineWidth$jscomp$1_normal_x1$$;
    this.context.strokeStyle = $$jscomp$destructuring$var20_color$jscomp$4_y1$$;
    $lineWidth$jscomp$1_normal_x1$$ = $sourceX$jscomp$3_x2$$ + $lineSegment_normalSize$$.x;
    $$jscomp$destructuring$var20_color$jscomp$4_y1$$ = $sourceY$jscomp$3_x$jscomp$89_y2$$ + $lineSegment_normalSize$$.y;
    $sourceX$jscomp$3_x2$$ += $lineSegment_normalSize$$.x2;
    $sourceY$jscomp$3_x$jscomp$89_y2$$ += $lineSegment_normalSize$$.y2;
    this.context.beginPath();
    this.context.moveTo($lineWidth$jscomp$1_normal_x1$$, $$jscomp$destructuring$var20_color$jscomp$4_y1$$);
    this.context.lineTo($sourceX$jscomp$3_x2$$, $sourceY$jscomp$3_x$jscomp$89_y2$$);
    this.context.stroke();
    hamonengine.debug && $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$ && (this.context.strokeStyle = "white", $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$ = $lineSegment_normalSize$$.midPoint, $sourceY$jscomp$3_x$jscomp$89_y2$$ = $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$.x, $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$ = $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$.y, 
    $sourceY$jscomp$3_x$jscomp$89_y2$$ = Math.bitRound($sourceY$jscomp$3_x$jscomp$89_y2$$) + $lineWidth$jscomp$1_normal_x1$$, $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$ = Math.bitRound($$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$) + $$jscomp$destructuring$var20_color$jscomp$4_y1$$, this.invertYAxis && ($$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$ = this.viewPort.height - $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$), 
    this.invertXAxis && ($sourceY$jscomp$3_x$jscomp$89_y2$$ = this.viewPort.width - $sourceY$jscomp$3_x$jscomp$89_y2$$), this.context.beginPath(), this.context.moveTo($sourceY$jscomp$3_x$jscomp$89_y2$$, $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$), $lineWidth$jscomp$1_normal_x1$$ = $lineSegment_normalSize$$.normal, $lineSegment_normalSize$$ = Math.bitRound($lineSegment_normalSize$$.length / 2), this.invertYAxis && ($lineWidth$jscomp$1_normal_x1$$.y = -$lineWidth$jscomp$1_normal_x1$$.y), 
    this.invertXAxis && ($lineWidth$jscomp$1_normal_x1$$.x = -$lineWidth$jscomp$1_normal_x1$$.x), this.context.lineTo($sourceY$jscomp$3_x$jscomp$89_y2$$ + $lineWidth$jscomp$1_normal_x1$$.x * $lineSegment_normalSize$$, $$jscomp$destructuring$var19_$jscomp$destructuring$var21_drawNormals_y$$ + $lineWidth$jscomp$1_normal_x1$$.y * $lineSegment_normalSize$$), this.context.stroke());
  };
  hamonengine.graphics.layer.prototype.drawRect = function $hamonengine$graphics$layer$$drawRect$($rect$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var22_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var23_fillColor$$ = void 0 === $$jscomp$destructuring$var22_lineWidth$$ ? {} : $$jscomp$destructuring$var22_lineWidth$$;
    $$jscomp$destructuring$var22_lineWidth$$ = void 0 === $$jscomp$destructuring$var23_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var23_fillColor$$.lineWidth;
    var $color$$ = void 0 === $$jscomp$destructuring$var23_fillColor$$.color ? "white" : $$jscomp$destructuring$var23_fillColor$$.color, $fill$$ = void 0 === $$jscomp$destructuring$var23_fillColor$$.fill ? !1 : $$jscomp$destructuring$var23_fillColor$$.fill;
    $$jscomp$destructuring$var23_fillColor$$ = void 0 === $$jscomp$destructuring$var23_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var23_fillColor$$.fillColor;
    this.simpleDrawRect($rect$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var22_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var23_fillColor$$});
    var $wrappingPosition$$ = new hamonengine.geometry.vector2;
    if (this.wrapHorizontal) {
      var $xOffset$8_xOffset$jscomp$2_yOffset$$ = $sourceX$$ + $rect$$.x - this.viewPort.x;
      0 >= $xOffset$8_xOffset$jscomp$2_yOffset$$ && (this.simpleDrawRect($rect$$, this.viewPort.width + $xOffset$8_xOffset$jscomp$2_yOffset$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var22_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var23_fillColor$$}), $wrappingPosition$$.x = this.viewPort.width + $xOffset$8_xOffset$jscomp$2_yOffset$$);
      $sourceX$$ + $rect$$.width >= this.viewPort.width && ($xOffset$8_xOffset$jscomp$2_yOffset$$ = this.viewPort.width - ($sourceX$$ + $rect$$.x), this.simpleDrawRect($rect$$, this.viewPort.x - $xOffset$8_xOffset$jscomp$2_yOffset$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var22_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var23_fillColor$$}), $wrappingPosition$$.x = this.viewPort.x - $xOffset$8_xOffset$jscomp$2_yOffset$$);
    }
    this.wrapVertical && ($xOffset$8_xOffset$jscomp$2_yOffset$$ = $sourceY$$ + $rect$$.y - this.viewPort.y, 0 >= $xOffset$8_xOffset$jscomp$2_yOffset$$ && (this.simpleDrawRect($rect$$, $sourceX$$, this.viewPort.height + $xOffset$8_xOffset$jscomp$2_yOffset$$, {lineWidth:$$jscomp$destructuring$var22_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var23_fillColor$$}), $wrappingPosition$$.y = this.viewPort.height + $xOffset$8_xOffset$jscomp$2_yOffset$$), $sourceY$$ + $rect$$.height >= 
    this.viewPort.height && ($sourceY$$ = this.viewPort.height - ($sourceY$$ + $rect$$.y), this.simpleDrawRect($rect$$, $sourceX$$, this.viewPort.y - $sourceY$$, {lineWidth:$$jscomp$destructuring$var22_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var23_fillColor$$}), $wrappingPosition$$.y = this.viewPort.y - $sourceY$$));
    this.wrapVertical && this.wrapHorizontal && $wrappingPosition$$.x && $wrappingPosition$$.y && this.simpleDrawRect($rect$$, $wrappingPosition$$.x, $wrappingPosition$$.y, {lineWidth:$$jscomp$destructuring$var22_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var23_fillColor$$});
  };
  hamonengine.graphics.layer.prototype.simpleDrawRect = function $hamonengine$graphics$layer$$simpleDrawRect$($rect$$, $sourceX$jscomp$5_x$$, $sourceY$jscomp$5_y$$, $$jscomp$destructuring$var24_fill$$) {
    var $$jscomp$destructuring$var25_fillColor$$ = void 0 === $$jscomp$destructuring$var24_fill$$ ? {} : $$jscomp$destructuring$var24_fill$$, $lineWidth$$ = void 0 === $$jscomp$destructuring$var25_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var25_fillColor$$.lineWidth, $color$$ = void 0 === $$jscomp$destructuring$var25_fillColor$$.color ? "white" : $$jscomp$destructuring$var25_fillColor$$.color;
    $$jscomp$destructuring$var24_fill$$ = void 0 === $$jscomp$destructuring$var25_fillColor$$.fill ? !1 : $$jscomp$destructuring$var25_fillColor$$.fill;
    $$jscomp$destructuring$var25_fillColor$$ = void 0 === $$jscomp$destructuring$var25_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var25_fillColor$$.fillColor;
    if (!($rect$$ instanceof hamonengine.geometry.rect)) {
      throw "Parameter rect is not of type hamonengine.geometry.rect.";
    }
    this.context.lineWidth = $lineWidth$$;
    this.context.strokeStyle = $color$$;
    this.context.fillStyle = $$jscomp$destructuring$var25_fillColor$$;
    $sourceX$jscomp$5_x$$ = $rect$$.x + (void 0 === $sourceX$jscomp$5_x$$ ? 0 : $sourceX$jscomp$5_x$$);
    $sourceY$jscomp$5_y$$ = $rect$$.y + (void 0 === $sourceY$jscomp$5_y$$ ? 0 : $sourceY$jscomp$5_y$$);
    this.invertYAxis && ($sourceY$jscomp$5_y$$ = this.viewPort.height - $sourceY$jscomp$5_y$$);
    this.invertXAxis && ($sourceX$jscomp$5_x$$ = this.viewPort.width - $sourceX$jscomp$5_x$$);
    this.context.beginPath();
    this.context.moveTo($sourceX$jscomp$5_x$$, $sourceY$jscomp$5_y$$);
    this.context.strokeRect($sourceX$jscomp$5_x$$, $sourceY$jscomp$5_y$$, $rect$$.width, $rect$$.height);
    this.context.closePath();
    $$jscomp$destructuring$var24_fill$$ && this.context.fillRect($sourceX$jscomp$5_x$$, $sourceY$jscomp$5_y$$, $rect$$.width, $rect$$.height);
    this.context.stroke();
  };
  hamonengine.graphics.layer.prototype.drawPolygon = function $hamonengine$graphics$layer$$drawPolygon$($polygon$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var26_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var27_fillColor$$ = void 0 === $$jscomp$destructuring$var26_lineWidth$$ ? {} : $$jscomp$destructuring$var26_lineWidth$$;
    $$jscomp$destructuring$var26_lineWidth$$ = void 0 === $$jscomp$destructuring$var27_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var27_fillColor$$.lineWidth;
    var $color$$ = void 0 === $$jscomp$destructuring$var27_fillColor$$.color ? "white" : $$jscomp$destructuring$var27_fillColor$$.color, $drawNormals$$ = void 0 === $$jscomp$destructuring$var27_fillColor$$.drawNormals ? !1 : $$jscomp$destructuring$var27_fillColor$$.drawNormals, $fill$$ = void 0 === $$jscomp$destructuring$var27_fillColor$$.fill ? !1 : $$jscomp$destructuring$var27_fillColor$$.fill;
    $$jscomp$destructuring$var27_fillColor$$ = void 0 === $$jscomp$destructuring$var27_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var27_fillColor$$.fillColor;
    this.simpleDrawPolygon($polygon$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var26_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var27_fillColor$$});
    var $wrappingPosition$$ = new hamonengine.geometry.vector2;
    if (this.wrapHorizontal) {
      var $xOffset$10_xOffset$jscomp$3_yOffset$$ = $sourceX$$ + $polygon$$.min.x - this.viewPort.x;
      0 >= $xOffset$10_xOffset$jscomp$3_yOffset$$ && (this.simpleDrawPolygon($polygon$$, this.viewPort.width + $xOffset$10_xOffset$jscomp$3_yOffset$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var26_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var27_fillColor$$}), $wrappingPosition$$.x = this.viewPort.width + $xOffset$10_xOffset$jscomp$3_yOffset$$);
      $sourceX$$ + $polygon$$.width >= this.viewPort.width && ($xOffset$10_xOffset$jscomp$3_yOffset$$ = this.viewPort.width - ($sourceX$$ + $polygon$$.min.x), this.simpleDrawPolygon($polygon$$, this.viewPort.x - $xOffset$10_xOffset$jscomp$3_yOffset$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var26_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var27_fillColor$$}), $wrappingPosition$$.x = this.viewPort.x - $xOffset$10_xOffset$jscomp$3_yOffset$$);
    }
    this.wrapVertical && ($xOffset$10_xOffset$jscomp$3_yOffset$$ = $sourceY$$ + $polygon$$.min.y - this.viewPort.y, 0 >= $xOffset$10_xOffset$jscomp$3_yOffset$$ && (this.simpleDrawPolygon($polygon$$, $sourceX$$, this.viewPort.height + $xOffset$10_xOffset$jscomp$3_yOffset$$, {lineWidth:$$jscomp$destructuring$var26_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var27_fillColor$$}), $wrappingPosition$$.y = this.viewPort.height + $xOffset$10_xOffset$jscomp$3_yOffset$$), 
    $sourceY$$ + $polygon$$.height >= this.viewPort.height && ($sourceY$$ = this.viewPort.height - ($sourceY$$ + $polygon$$.min.y), this.simpleDrawPolygon($polygon$$, $sourceX$$, this.viewPort.y - $sourceY$$, {lineWidth:$$jscomp$destructuring$var26_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var27_fillColor$$}), $wrappingPosition$$.y = this.viewPort.y - $sourceY$$));
    this.wrapVertical && this.wrapHorizontal && $wrappingPosition$$.x && $wrappingPosition$$.y && this.simpleDrawPolygon($polygon$$, $wrappingPosition$$.x, $wrappingPosition$$.y, {lineWidth:$$jscomp$destructuring$var26_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var27_fillColor$$});
  };
  hamonengine.graphics.layer.prototype.simpleDrawPolygon = function $hamonengine$graphics$layer$$simpleDrawPolygon$($polygon$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var28_drawNormals$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$ = void 0 === $$jscomp$destructuring$var28_drawNormals$$ ? {} : $$jscomp$destructuring$var28_drawNormals$$, $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$ = void 0 === $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.lineWidth ? 1 : $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.lineWidth, $color$jscomp$8_vertex_x$$ = void 0 === $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.color ? 
    "white" : $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.color;
    $$jscomp$destructuring$var28_drawNormals$$ = void 0 === $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.drawNormals ? !1 : $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.drawNormals;
    var $fill$$ = void 0 === $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.fill ? !1 : $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.fill;
    $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$ = void 0 === $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.fillColor ? "white" : $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.fillColor;
    if (!($polygon$$ instanceof hamonengine.geometry.polygon)) {
      throw "Parameter polygon is not of type hamonengine.geometry.polygon.";
    }
    this.context.lineWidth = $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$;
    this.context.strokeStyle = $color$jscomp$8_vertex_x$$;
    this.context.fillStyle = $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$;
    this.context.beginPath();
    for ($edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$ = 0; $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$ < $polygon$$.vertices.length; $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$++) {
      $color$jscomp$8_vertex_x$$ = Math.bitRound($sourceX$$ + $polygon$$.vertices[$edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$].x), $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$ = Math.bitRound($sourceY$$ + $polygon$$.vertices[$edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$].y), this.invertYAxis && ($$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$ = this.viewPort.height - $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$), 
      this.invertXAxis && ($color$jscomp$8_vertex_x$$ = this.viewPort.width - $color$jscomp$8_vertex_x$$), 0 === $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$ ? this.context.moveTo($color$jscomp$8_vertex_x$$, $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$) : this.context.lineTo($color$jscomp$8_vertex_x$$, $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$);
    }
    this.context.closePath();
    $fill$$ && this.context.fill();
    this.context.stroke();
    if (hamonengine.debug && $$jscomp$destructuring$var28_drawNormals$$) {
      for (this.context.strokeStyle = "white", $$jscomp$destructuring$var28_drawNormals$$ = 0; $$jscomp$destructuring$var28_drawNormals$$ < $polygon$$.vertices.length; $$jscomp$destructuring$var28_drawNormals$$++) {
        $color$jscomp$8_vertex_x$$ = $polygon$$.vertices[$$jscomp$destructuring$var28_drawNormals$$], $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$ = $polygon$$.edges[$$jscomp$destructuring$var28_drawNormals$$], $fill$$ = Math.bitRound($sourceX$$ + $color$jscomp$8_vertex_x$$.x + $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$.x / 2), $color$jscomp$8_vertex_x$$ = Math.bitRound($sourceY$$ + $color$jscomp$8_vertex_x$$.y + $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$.y / 
        2), this.invertYAxis && ($color$jscomp$8_vertex_x$$ = this.viewPort.height - $color$jscomp$8_vertex_x$$), this.invertXAxis && ($fill$$ = this.viewPort.width - $fill$$), this.context.beginPath(), this.context.moveTo($fill$$, $color$jscomp$8_vertex_x$$), $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$ = $polygon$$.normals[$$jscomp$destructuring$var28_drawNormals$$], $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$ = Math.bitRound($edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$.length / 
        2), this.invertYAxis && ($$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.y = -$$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.y), this.invertXAxis && ($$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.x = -$$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.x), this.context.lineTo($fill$$ + $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.x * $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$, 
        $color$jscomp$8_vertex_x$$ + $$jscomp$destructuring$var29_fillColor$jscomp$3_normal$jscomp$1_y$$.y * $edge$jscomp$1_index$jscomp$49_lineWidth$jscomp$5_normalSize$$), this.context.stroke();
      }
    }
  };
  hamonengine.graphics.layer.prototype.drawShape = function $hamonengine$graphics$layer$$drawShape$($shape$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var30_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var31_fillColor$$ = void 0 === $$jscomp$destructuring$var30_lineWidth$$ ? {} : $$jscomp$destructuring$var30_lineWidth$$;
    $$jscomp$destructuring$var30_lineWidth$$ = void 0 === $$jscomp$destructuring$var31_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var31_fillColor$$.lineWidth;
    var $color$$ = void 0 === $$jscomp$destructuring$var31_fillColor$$.color ? "white" : $$jscomp$destructuring$var31_fillColor$$.color, $drawNormals$$ = void 0 === $$jscomp$destructuring$var31_fillColor$$.drawNormals ? !1 : $$jscomp$destructuring$var31_fillColor$$.drawNormals, $fill$$ = void 0 === $$jscomp$destructuring$var31_fillColor$$.fill ? !1 : $$jscomp$destructuring$var31_fillColor$$.fill;
    $$jscomp$destructuring$var31_fillColor$$ = void 0 === $$jscomp$destructuring$var31_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var31_fillColor$$.fillColor;
    $shape$$ instanceof hamonengine.geometry.rect && this.drawRect($shape$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var30_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var31_fillColor$$});
    $shape$$ instanceof hamonengine.geometry.polygon && this.drawPolygon($shape$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var30_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var31_fillColor$$});
    $shape$$ instanceof hamonengine.geometry.lineSegment && this.drawLineSegment($shape$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var30_lineWidth$$, drawNormals:$drawNormals$$, color:$color$$});
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.layer.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, allowEventBinding:{configurable:!0, enumerable:!0, get:function() {
    return this._allowEventBinding;
  }}, context:{configurable:!0, enumerable:!0, get:function() {
    return this._canvasContext;
  }}, canvas:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas;
  }}, clipToViewPort:{configurable:!0, enumerable:!0, get:function() {
    return this._clipToViewPort;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas.width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas.height;
  }}, offsetX:{configurable:!0, enumerable:!0, get:function() {
    return this.canvas.offsetLeft;
  }}, offsetY:{configurable:!0, enumerable:!0, get:function() {
    return this.canvas.offsetTop;
  }}, position:{configurable:!0, enumerable:!0, get:function() {
    var $boundRect$$ = this.canvas.getBoundingClientRect() || {left:0, top:0};
    return new hamonengine.geometry.vector2($boundRect$$.left, $boundRect$$.top);
  }}, viewPort:{configurable:!0, enumerable:!0, get:function() {
    return this._viewPort;
  }}, wrapHorizontal:{configurable:!0, enumerable:!0, get:function() {
    return this._wrapHorizontal;
  }, set:function($v$$) {
    this._wrapHorizontal = $v$$;
  }}, wrapVertical:{configurable:!0, enumerable:!0, get:function() {
    return this._wrapVertical;
  }, set:function($v$$) {
    this._wrapVertical = $v$$;
  }}, allowSaveState:{configurable:!0, enumerable:!0, get:function() {
    return this._allowSaveStateEnabled;
  }, set:function($v$$) {
    this._allowSaveStateEnabled = $v$$;
  }}, borderColor:{configurable:!0, enumerable:!0, get:function() {
    return this._viewPortBorderColor;
  }, set:function($v$$) {
    this._viewPortBorderColor = $v$$;
  }}, invertYAxis:{configurable:!0, enumerable:!0, get:function() {
    return this._invertYAxis;
  }, set:function($v$$) {
    this._invertYAxis = $v$$;
  }}, invertXAxis:{configurable:!0, enumerable:!0, get:function() {
    return this._invertXAxis;
  }, set:function($v$$) {
    this._invertXAxis = $v$$;
  }}, alpha:{configurable:!0, enumerable:!0, get:function() {
    return this.context.globalAlpha;
  }, set:function($v$$) {
    this.context.globalAlpha = $v$$;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.sprite = function $hamonengine$graphics$sprite$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.graphics.sprite && ($options$$ = {image:$options$$._image && $options$$._image.clone(), dimensions:$options$$._dimensions, theta:$options$$.theta});
    this._name = $options$$.name;
    this._image = $options$$.image || new hamonengine.graphics.imageext;
    this._url = $options$$.url || "";
    this._dimensions = $options$$.dimensions ? $options$$.dimensions : this._image instanceof HTMLImageElement ? new hamonengine.geometry.rect(0, 0, this._image.width, this._image.height) : new hamonengine.geometry.rect;
    this._theta = $options$$.theta || 0.0;
    this._scaleVector = new hamonengine.geometry.vector2(1.0, 1.0);
    this._spriteOrientation = 0;
    this._showFullImage = this._showDiagnosisLines = !1;
    this._maxWrapping = 0;
    hamonengine.debug && hamonengine.verbose && (console.debug("[hamonengine.graphics.sprite.constructor] Starting Dimensions: {" + this._dimensions.toString() + "}"), console.debug("[hamonengine.graphics.sprite.constructor] Name: " + this._name), console.debug("[hamonengine.graphics.sprite.constructor] Theta: " + this._theta), console.debug("[hamonengine.graphics.sprite.constructor] ScaleVector: {" + this._scaleVector.toString() + "}"));
  };
  hamonengine.graphics.sprite.prototype.copyProperties = function $hamonengine$graphics$sprite$$copyProperties$($properties$$) {
    this._theta = $properties$$.theta;
    this._scaleVector = $properties$$._scaleVector;
    this._spriteOrientation = $properties$$._spriteOrientation;
    this._showDiagnosisLines = $properties$$._showDiagnosisLines;
    this._showFullImage = $properties$$._showFullImage;
  };
  hamonengine.graphics.sprite.prototype.clone = function $hamonengine$graphics$sprite$$clone$() {
    return new hamonengine.graphics.sprite(this);
  };
  hamonengine.graphics.sprite.prototype.load = function $hamonengine$graphics$sprite$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return $src$$ = $src$$ || $$jscomp$async$this$$._url, $$jscomp$generator$state$$ = -1, {value:new Promise(function($resolve$$, $reject$$) {
                $$jscomp$async$this$$._image instanceof hamonengine.graphics.imageext ? $$jscomp$async$this$$._image.load($src$$).then(function() {
                  $$jscomp$async$this$$._dimensions = new hamonengine.geometry.rect(0, 0, $$jscomp$async$this$$._image.width, $$jscomp$async$this$$._image.height);
                  $resolve$$($$jscomp$async$this$$);
                }).catch(function($err$$) {
                  $reject$$($err$$);
                }) : $resolve$$($$jscomp$async$this$$);
              }), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.graphics.sprite.prototype.rotate = function $hamonengine$graphics$sprite$$rotate$($theta$$) {
    this._theta = $theta$$ || 0.0;
    return this;
  };
  hamonengine.graphics.sprite.prototype.scale = function $hamonengine$graphics$sprite$$scale$($x$$, $y$$) {
    this._scaleVector.x = $x$$;
    this._scaleVector.y = $y$$;
    return this;
  };
  hamonengine.graphics.sprite.prototype.mirror = function $hamonengine$graphics$sprite$$mirror$($state$$) {
    this._spriteOrientation = bitflag.toggle(this._spriteOrientation, 2, $state$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.flip = function $hamonengine$graphics$sprite$$flip$($state$$) {
    this._spriteOrientation = bitflag.toggle(this._spriteOrientation, 1, $state$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.blendColor = function $hamonengine$graphics$sprite$$blendColor$($r$$, $g$$, $b$$, $a$$, $blendingOps$$) {
    $blendingOps$$ = void 0 === $blendingOps$$ ? BLENDING_OPS.REPLACE : $blendingOps$$;
    this._image.blendColorRegion(void 0 === $r$$ ? 0 : $r$$, void 0 === $g$$ ? 0 : $g$$, void 0 === $b$$ ? 0 : $b$$, void 0 === $a$$ ? 0 : $a$$, this._dimensions, $blendingOps$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.adjustColorChannel = function $hamonengine$graphics$sprite$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$) {
    this._image.adjustColorChannel(void 0 === $r$$ ? 1.0 : $r$$, void 0 === $g$$ ? 1.0 : $g$$, void 0 === $b$$ ? 1.0 : $b$$, void 0 === $a$$ ? 1.0 : $a$$, this._dimensions);
    return this;
  };
  hamonengine.graphics.sprite.prototype.bitblit = function $hamonengine$graphics$sprite$$bitblit$($sprite$$, $transparency$$) {
    this._image.bitblit($sprite$$._image, $sprite$$._dimensions, this._dimensions, void 0 === $transparency$$ ? 1.0 : $transparency$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.drawRaw = function $hamonengine$graphics$sprite$$drawRaw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this._dimensions.width : $width$$;
    $height$$ = void 0 === $height$$ ? this._dimensions.height : $height$$;
    this._image.complete && (this.showFullImage ? $layer$$.context.drawImage(this._image.image, Math.bitRound($x$$), Math.bitRound($y$$), Math.bitRound($width$$), Math.bitRound($height$$)) : $layer$$.drawImage(this._image, this._dimensions.x, this._dimensions.y, this._dimensions.width, this._dimensions.height, Math.bitRound($x$$), Math.bitRound($y$$), Math.bitRound($width$$), Math.bitRound($height$$)));
  };
  hamonengine.graphics.sprite.prototype.draw = function $hamonengine$graphics$sprite$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this._dimensions.width : $width$$;
    $height$$ = void 0 === $height$$ ? this._dimensions.height : $height$$;
    $x$$ = Math.bitRound($x$$);
    $y$$ = Math.bitRound($y$$);
    var $xCenterOffset_xCenterOffset$15$$ = Math.bitRound($width$$ / 2) + $x$$, $yCenterOffset_yCenterOffset$16$$ = Math.bitRound($height$$ / 2) + $y$$, $yOrientation$$ = bitflag.isSet(this._spriteOrientation, 1) ? -1.0 : 1.0, $xOrientation$$ = bitflag.isSet(this._spriteOrientation, 2) ? -1.0 : 1.0;
    $layer$$.save();
    if (1 !== this._scaleVector.x || 1 !== this._scaleVector.y) {
      $layer$$.context.translate($x$$, $y$$), $layer$$.context.scale(this._scaleVector.x, this._scaleVector.y), $layer$$.context.translate(-$x$$, -$y$$);
    }
    0 < this._spriteOrientation && ($layer$$.context.translate($xCenterOffset_xCenterOffset$15$$, $yCenterOffset_yCenterOffset$16$$), $layer$$.context.scale($xOrientation$$, $yOrientation$$), $layer$$.context.translate(-$xCenterOffset_xCenterOffset$15$$, -$yCenterOffset_yCenterOffset$16$$));
    0.0 !== this.theta && ($layer$$.context.translate($xCenterOffset_xCenterOffset$15$$, $yCenterOffset_yCenterOffset$16$$), $layer$$.context.rotate(this.theta), $layer$$.context.translate(-$xCenterOffset_xCenterOffset$15$$, -$yCenterOffset_yCenterOffset$16$$));
    ($layer$$.wrapHorizontal || $layer$$.wrapVertical) && this.drawSpriteWrapping($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$, $xOrientation$$, $yOrientation$$);
    this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$);
    if (hamonengine.debug && this.showDiagnosisLines) {
      $xCenterOffset_xCenterOffset$15$$ = Math.bitRound($width$$ / 2) + $x$$;
      $yCenterOffset_yCenterOffset$16$$ = Math.bitRound($height$$ / 2) + $y$$;
      if ($layer$$.wrapHorizontal || $layer$$.wrapVertical) {
        $layer$$.context.strokeStyle = "red", $layer$$.context.lineWidth = 2, $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$15$$, $yCenterOffset_yCenterOffset$16$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$15$$ + $layer$$.viewPort.width, $yCenterOffset_yCenterOffset$16$$), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$15$$, $yCenterOffset_yCenterOffset$16$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$15$$ - 
        $layer$$.viewPort.width, $yCenterOffset_yCenterOffset$16$$), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$15$$, $yCenterOffset_yCenterOffset$16$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$15$$, $yCenterOffset_yCenterOffset$16$$ + $layer$$.viewPort.height), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$15$$, $yCenterOffset_yCenterOffset$16$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$15$$, 
        $yCenterOffset_yCenterOffset$16$$ - $layer$$.viewPort.height), $layer$$.context.stroke(), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$ + $layer$$.viewPort.width, $y$$, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$ - $layer$$.viewPort.width, $y$$, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$ + $layer$$.viewPort.height, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$ - 
        $layer$$.viewPort.height, $width$$, $height$$), $layer$$.context.strokeStyle = "white", $layer$$.context.strokeRect($xCenterOffset_xCenterOffset$15$$ - $layer$$.viewPort.width / 2, $yCenterOffset_yCenterOffset$16$$ - $layer$$.viewPort.height / 2, $layer$$.viewPort.width, $layer$$.viewPort.height);
      }
      $layer$$.context.strokeStyle = "red";
      $layer$$.context.strokeRect($x$$, $y$$, $width$$, $height$$);
      $layer$$.context.strokeStyle = "cyan";
      $layer$$.context.strokeRect($layer$$.viewPort.x, $layer$$.viewPort.y, $layer$$.viewPort.width, $layer$$.viewPort.height);
    }
    $layer$$.restore();
  };
  hamonengine.graphics.sprite.prototype.drawSpriteWrapping = function $hamonengine$graphics$sprite$$drawSpriteWrapping$($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$95_xOffset$$, $y$jscomp$75_yOffset$$, $width$$, $height$$, $xOrientation$$, $yOrientation$$) {
    var $cosAngle_wrapLoop$18_wrapLoop$19$$ = Math.cos(-this.theta), $sinAngle$$ = Math.sin(-this.theta), $widthScaled_wrapLoop_wrapLoop$17$$ = $width$$ * this._scaleVector.x, $heightScaled$$ = $height$$ * this._scaleVector.y, $wrappingDirection$$ = new hamonengine.geometry.vector2;
    if ($layer$$.wrapHorizontal) {
      var $horizontalLength_v1y$$ = $layer$$.viewPort.width / this._scaleVector.x * $xOrientation$$;
      var $v1x$$ = Math.bitRound($cosAngle_wrapLoop$18_wrapLoop$19$$ * $horizontalLength_v1y$$);
      $horizontalLength_v1y$$ = Math.bitRound($sinAngle$$ * $horizontalLength_v1y$$);
      if ($x$jscomp$95_xOffset$$ - $widthScaled_wrapLoop_wrapLoop$17$$ <= $layer$$.viewPort.x) {
        if ($wrappingDirection$$.x = 1, $widthScaled_wrapLoop_wrapLoop$17$$ = Math.abs(parseInt(($x$jscomp$95_xOffset$$ - $widthScaled_wrapLoop_wrapLoop$17$$) / $layer$$.viewPort.width, 10)) + 1, 0 === this._maxWrapping || $widthScaled_wrapLoop_wrapLoop$17$$ < this._maxWrapping) {
          this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$95_xOffset$$ + $v1x$$ * $widthScaled_wrapLoop_wrapLoop$17$$, $y$jscomp$75_yOffset$$ + $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$17$$, $width$$, $height$$), 0 < --$widthScaled_wrapLoop_wrapLoop$17$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$95_xOffset$$ + $v1x$$ * $widthScaled_wrapLoop_wrapLoop$17$$, $y$jscomp$75_yOffset$$ + $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$17$$, 
          $width$$, $height$$);
        }
      } else {
        $x$jscomp$95_xOffset$$ + $widthScaled_wrapLoop_wrapLoop$17$$ >= $layer$$.viewPort.width && ($wrappingDirection$$.x = -1, $widthScaled_wrapLoop_wrapLoop$17$$ = parseInt(($x$jscomp$95_xOffset$$ + $widthScaled_wrapLoop_wrapLoop$17$$) / $layer$$.viewPort.width, 10), 0 === this._maxWrapping || $widthScaled_wrapLoop_wrapLoop$17$$ < this._maxWrapping) && (this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$95_xOffset$$ - $v1x$$ * $widthScaled_wrapLoop_wrapLoop$17$$, $y$jscomp$75_yOffset$$ - 
        $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$17$$, $width$$, $height$$), 0 < --$widthScaled_wrapLoop_wrapLoop$17$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$95_xOffset$$ - $v1x$$ * $widthScaled_wrapLoop_wrapLoop$17$$, $y$jscomp$75_yOffset$$ - $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$17$$, $width$$, $height$$));
      }
    }
    if ($layer$$.wrapVertical) {
      var $v2y_verticalLength$$ = $layer$$.viewPort.height / this._scaleVector.y * $yOrientation$$;
      var $v2x$$ = Math.bitRound($sinAngle$$ * $v2y_verticalLength$$);
      $v2y_verticalLength$$ = Math.bitRound($cosAngle_wrapLoop$18_wrapLoop$19$$ * $v2y_verticalLength$$);
      if ($y$jscomp$75_yOffset$$ - $heightScaled$$ <= $layer$$.viewPort.y) {
        if ($wrappingDirection$$.y = 1, $cosAngle_wrapLoop$18_wrapLoop$19$$ = Math.abs(parseInt(($y$jscomp$75_yOffset$$ - $heightScaled$$) / $layer$$.viewPort.height, 10)) + 1, 0 === this._maxWrapping || $cosAngle_wrapLoop$18_wrapLoop$19$$ < this._maxWrapping) {
          this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$95_xOffset$$ - $v2x$$ * $cosAngle_wrapLoop$18_wrapLoop$19$$, $y$jscomp$75_yOffset$$ + $v2y_verticalLength$$ * $cosAngle_wrapLoop$18_wrapLoop$19$$, $width$$, $height$$), 0 < --$cosAngle_wrapLoop$18_wrapLoop$19$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$95_xOffset$$ - $v2x$$ * $cosAngle_wrapLoop$18_wrapLoop$19$$, $y$jscomp$75_yOffset$$ + $v2y_verticalLength$$ * $cosAngle_wrapLoop$18_wrapLoop$19$$, $width$$, 
          $height$$);
        }
      } else {
        $y$jscomp$75_yOffset$$ + $heightScaled$$ >= $layer$$.viewPort.height && ($wrappingDirection$$.y = -1, $cosAngle_wrapLoop$18_wrapLoop$19$$ = parseInt(($y$jscomp$75_yOffset$$ + $heightScaled$$) / $layer$$.viewPort.height, 10), 0 === this._maxWrapping || $cosAngle_wrapLoop$18_wrapLoop$19$$ < this._maxWrapping) && (this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$95_xOffset$$ + $v2x$$ * $cosAngle_wrapLoop$18_wrapLoop$19$$, $y$jscomp$75_yOffset$$ - $v2y_verticalLength$$ * $cosAngle_wrapLoop$18_wrapLoop$19$$, 
        $width$$, $height$$), 0 < --$cosAngle_wrapLoop$18_wrapLoop$19$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$95_xOffset$$ + $v2x$$ * $cosAngle_wrapLoop$18_wrapLoop$19$$, $y$jscomp$75_yOffset$$ - $v2y_verticalLength$$ * $cosAngle_wrapLoop$18_wrapLoop$19$$, $width$$, $height$$));
      }
    }
    $layer$$.wrapVertical && $layer$$.wrapHorizontal && ($x$jscomp$95_xOffset$$ = $x$jscomp$95_xOffset$$ - $wrappingDirection$$.y * $v2x$$ + $wrappingDirection$$.x * $v1x$$, $y$jscomp$75_yOffset$$ = $y$jscomp$75_yOffset$$ + $wrappingDirection$$.y * $v2y_verticalLength$$ + $wrappingDirection$$.x * $horizontalLength_v1y$$, $x$jscomp$95_xOffset$$ && $y$jscomp$75_yOffset$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$95_xOffset$$, $y$jscomp$75_yOffset$$, $width$$, $height$$));
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.sprite.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }, set:function($v$$) {
    this._name = $v$$;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._dimensions.height;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._dimensions.width;
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return this._theta;
  }}, showDiagnosisLines:{configurable:!0, enumerable:!0, get:function() {
    return this._showDiagnosisLines;
  }, set:function($v$$) {
    this._showDiagnosisLines = $v$$;
  }}, showFullImage:{configurable:!0, enumerable:!0, get:function() {
    return this._showFullImage;
  }, set:function($v$$) {
    this._showFullImage = $v$$;
  }}, maxWrapping:{configurable:!0, enumerable:!0, set:function($v$$) {
    this._maxWrapping = $v$$;
  }}, image:{configurable:!0, enumerable:!0, get:function() {
    return this._image;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.animsprite = function $hamonengine$graphics$animsprite$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.graphics.sprite.call(this, $options$$);
    $options$$ instanceof hamonengine.graphics.animsprite && ($options$$ = {frames:$options$$._frames.map(function($frame$$) {
      return $frame$$.clone();
    }), animationRate:$options$$._animationRate, animationCycles:$options$$._animationCycles});
    this._frames = $options$$.frames || [];
    this._animationRate = $options$$.animationRate || 0;
    this._animationCycles = $options$$.animationCycles || -1;
    this._numberOfAnimationCycles = this._timeSinceLastFrame = this._index = 0;
    this._enableAnimation = !0;
    hamonengine.debug && (console.debug("[hamonengine.graphics.animsprite.constructor] Starting Animation Rate: " + this._animationRate), console.debug("[hamonengine.graphics.animsprite.constructor] Starting Animation Cycle: " + this._animationCycles), console.debug("[hamonengine.graphics.animsprite.constructor] Starting Index: " + this._index), console.debug("[hamonengine.graphics.animsprite.constructor] Starting Enable Animation: " + this._enableAnimation));
  };
  $jscomp.inherits(hamonengine.graphics.animsprite, hamonengine.graphics.sprite);
  hamonengine.graphics.animsprite.prototype.clone = function $hamonengine$graphics$animsprite$$clone$() {
    return new hamonengine.graphics.animsprite(this);
  };
  hamonengine.graphics.animsprite.prototype.start = function $hamonengine$graphics$animsprite$$start$() {
    this._enableAnimation = !0;
    this._numberOfAnimationCycles = 0;
  };
  hamonengine.graphics.animsprite.prototype.stop = function $hamonengine$graphics$animsprite$$stop$() {
    this._enableAnimation = !1;
  };
  hamonengine.graphics.animsprite.prototype.pause = function $hamonengine$graphics$animsprite$$pause$() {
    this._enableAnimation = !this._enableAnimation;
  };
  hamonengine.graphics.animsprite.prototype.next = function $hamonengine$graphics$animsprite$$next$() {
    this.index++;
  };
  hamonengine.graphics.animsprite.prototype.prev = function $hamonengine$graphics$animsprite$$prev$() {
    var $index$$ = this.index - 1;
    this.index = 0 > $index$$ ? this._frames.length + $index$$ : $index$$;
  };
  hamonengine.graphics.animsprite.prototype.addFrame = function $hamonengine$graphics$animsprite$$addFrame$($frame$$) {
    hamonengine.debug && console.debug("[hamonengine.graphics.animsprite.animsprite.addFrame]");
    this._frames.push($frame$$);
  };
  hamonengine.graphics.animsprite.prototype.blendColor = function $hamonengine$graphics$animsprite$$blendColor$($r$$, $g$$, $b$$, $a$$, $blendingOps$$) {
    $r$$ = void 0 === $r$$ ? 0 : $r$$;
    $g$$ = void 0 === $g$$ ? 0 : $g$$;
    $b$$ = void 0 === $b$$ ? 0 : $b$$;
    $a$$ = void 0 === $a$$ ? 0 : $a$$;
    $blendingOps$$ = void 0 === $blendingOps$$ ? BLENDING_OPS.REPLACE : $blendingOps$$;
    for (var $i$$ = 0; $i$$ < this._frames.length; $i$$++) {
      this._frames[$i$$].blendColor($r$$, $g$$, $b$$, $a$$, $blendingOps$$);
    }
  };
  hamonengine.graphics.animsprite.prototype.adjustColorChannel = function $hamonengine$graphics$animsprite$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$) {
    $r$$ = void 0 === $r$$ ? 1.0 : $r$$;
    $g$$ = void 0 === $g$$ ? 1.0 : $g$$;
    $b$$ = void 0 === $b$$ ? 1.0 : $b$$;
    $a$$ = void 0 === $a$$ ? 1.0 : $a$$;
    for (var $i$$ = 0; $i$$ < this._frames.length; $i$$++) {
      this._frames[$i$$].adjustColorChannel($r$$, $g$$, $b$$, $a$$);
    }
  };
  hamonengine.graphics.animsprite.prototype.draw = function $hamonengine$graphics$animsprite$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? null : $width$$;
    $height$$ = void 0 === $height$$ ? null : $height$$;
    var $timeSinceLastFrame$$ = this._timeSinceLastFrame + $elapsedTimeInMilliseconds$$;
    if (this._enableAnimation) {
      var $currentFrame_numberOfAnimationCycles_numberOfFrames$$ = parseInt($timeSinceLastFrame$$ / this.animationRate, 10);
      $currentFrame_numberOfAnimationCycles_numberOfFrames$$ = this.index + $currentFrame_numberOfAnimationCycles_numberOfFrames$$;
      -1 < this.animationCycles && (this._numberOfAnimationCycles += parseInt($currentFrame_numberOfAnimationCycles_numberOfFrames$$ / this._frames.length, 10), this._enableAnimation = this._numberOfAnimationCycles <= this.animationCycles);
      this.index = $currentFrame_numberOfAnimationCycles_numberOfFrames$$;
    }
    0 < this._frames.length && ($currentFrame_numberOfAnimationCycles_numberOfFrames$$ = this._frames[this.index], $currentFrame_numberOfAnimationCycles_numberOfFrames$$.copyProperties(this), $currentFrame_numberOfAnimationCycles_numberOfFrames$$.draw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$ || $currentFrame_numberOfAnimationCycles_numberOfFrames$$.width, $height$$ || $currentFrame_numberOfAnimationCycles_numberOfFrames$$.height));
    this._timeSinceLastFrame = $timeSinceLastFrame$$ % this.animationRate;
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.animsprite.prototype, {index:{configurable:!0, enumerable:!0, get:function() {
    return this._index;
  }, set:function($v$$) {
    this._index = $v$$ % this._frames.length || 0;
  }}, animationRate:{configurable:!0, enumerable:!0, get:function() {
    return this._animationRate;
  }, set:function($v$$) {
    this._animationRate = 0 < $v$$ ? $v$$ : 1;
  }}, animationCycles:{configurable:!0, enumerable:!0, get:function() {
    return this._animationCycles;
  }, set:function($v$$) {
    this._animationCycles = $v$$;
    this._enableAnimation = !0;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.spritesheet = function $hamonengine$graphics$spritesheet$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._imageResource = new hamonengine.graphics.imageext;
    this._sprites = {};
    this._spriteIndex = [];
    this._url = $options$$.url || "";
    this._name = $options$$.name || "";
    hamonengine.debug && (console.debug("[hamonengine.audio.album.constructor] Name: '" + this._name + "'"), console.debug("[hamonengine.graphics.spritesheet.constructor] Url: '" + this._url + "''"));
  };
  hamonengine.graphics.spritesheet.prototype.load = function $hamonengine$graphics$spritesheet$$load$($spriteSheetMetadata$$) {
    $spriteSheetMetadata$$ = void 0 === $spriteSheetMetadata$$ ? "" : $spriteSheetMetadata$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$jscomp$12_i$20_i$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              $spriteSheetMetadata$$ = $spriteSheetMetadata$$ || $$jscomp$async$this$$._url;
              if ("string" !== typeof $spriteSheetMetadata$$) {
                $$jscomp$generator$state$$ = 1;
                break;
              }
              $$jscomp$generator$state$$ = 2;
              return {value:connect.get($spriteSheetMetadata$$), done:!1};
            case 2:
              if (void 0 === $$jscomp$generator$throw$arg$$) {
                $$jscomp$generator$state$$ = 3;
                break;
              }
              $$jscomp$generator$state$$ = -1;
              throw $$jscomp$generator$throw$arg$$;
            case 3:
              $spriteSheetMetadataResponse$$ = $$jscomp$generator$next$arg27$$ = $$jscomp$generator$next$arg$jscomp$12_i$20_i$$, $spriteSheetMetadata$$ = JSON.parse($spriteSheetMetadataResponse$$.data);
            case 1:
              $$jscomp$async$this$$._name = $$jscomp$async$this$$._name || $spriteSheetMetadata$$.name;
              $resourceLoadingPromise$$ = $$jscomp$async$this$$._imageResource.load($spriteSheetMetadata$$.spritesheetUrl);
              if ($spriteSheetMetadata$$.sprites) {
                for ($$jscomp$generator$next$arg$jscomp$12_i$20_i$$ = 0; $$jscomp$generator$next$arg$jscomp$12_i$20_i$$ < $spriteSheetMetadata$$.sprites.length; $$jscomp$generator$next$arg$jscomp$12_i$20_i$$++) {
                  $$jscomp$generator$throw$arg$$ = $spriteSheetMetadata$$.sprites[$$jscomp$generator$next$arg$jscomp$12_i$20_i$$];
                  var $animSpriteMetadata_spriteName_spriteName$21$$ = $$jscomp$generator$throw$arg$$.name.toLowerCase();
                  $$jscomp$async$this$$._spriteIndex.push($animSpriteMetadata_spriteName_spriteName$21$$);
                  $$jscomp$async$this$$._sprites[$animSpriteMetadata_spriteName_spriteName$21$$] = new hamonengine.graphics.sprite({image:$$jscomp$async$this$$._imageResource, name:$$jscomp$generator$throw$arg$$.name, dimensions:new hamonengine.geometry.rect($$jscomp$generator$throw$arg$$.x, $$jscomp$generator$throw$arg$$.y, $$jscomp$generator$throw$arg$$.width, $$jscomp$generator$throw$arg$$.height)});
                }
              }
              if ($spriteSheetMetadata$$.animSprites) {
                for ($$jscomp$generator$next$arg$jscomp$12_i$20_i$$ = 0; $$jscomp$generator$next$arg$jscomp$12_i$20_i$$ < $spriteSheetMetadata$$.animSprites.length; $$jscomp$generator$next$arg$jscomp$12_i$20_i$$++) {
                  $animSpriteMetadata_spriteName_spriteName$21$$ = $spriteSheetMetadata$$.animSprites[$$jscomp$generator$next$arg$jscomp$12_i$20_i$$];
                  $$jscomp$generator$throw$arg$$ = new hamonengine.graphics.animsprite({animationRate:$animSpriteMetadata_spriteName_spriteName$21$$.animationRate});
                  for (var $j$$ = 0; $j$$ < $animSpriteMetadata_spriteName_spriteName$21$$.frames.length; $j$$++) {
                    var $frameMetadata$$ = $animSpriteMetadata_spriteName_spriteName$21$$.frames[$j$$];
                    $$jscomp$generator$throw$arg$$.addFrame(new hamonengine.graphics.sprite({image:$$jscomp$async$this$$._imageResource, name:$frameMetadata$$.name, dimensions:new hamonengine.geometry.rect($frameMetadata$$.x, $frameMetadata$$.y, $frameMetadata$$.width, $frameMetadata$$.height)}));
                  }
                  $animSpriteMetadata_spriteName_spriteName$21$$ = $animSpriteMetadata_spriteName_spriteName$21$$.name.toLowerCase();
                  $$jscomp$async$this$$._spriteIndex.push($animSpriteMetadata_spriteName_spriteName$21$$);
                  $$jscomp$async$this$$._sprites[$animSpriteMetadata_spriteName_spriteName$21$$] = $$jscomp$generator$throw$arg$$;
                }
              }
              $$jscomp$generator$state$$ = -1;
              return {value:$resourceLoadingPromise$$, done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $resourceLoadingPromise$$, $spriteSheetMetadataResponse$$, $$jscomp$generator$next$arg27$$, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.graphics.spritesheet.prototype.getSprite = function $hamonengine$graphics$spritesheet$$getSprite$($spriteName$$) {
    return this._sprites[$spriteName$$.toLowerCase()].clone();
  };
  hamonengine.graphics.spritesheet.prototype.getSpriteByOrdinal = function $hamonengine$graphics$spritesheet$$getSpriteByOrdinal$($index$$) {
    return this._sprites[this._spriteIndex[$index$$]].clone();
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.spritesheet.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, length:{configurable:!0, enumerable:!0, get:function() {
    return this._spriteIndex.length;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._imageResource.isLoaded();
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
var OBJECT_STATE_FLAG = {NONE:0, SOLID:1, MOVEABLE:2, VISIBLE:4}, OBJECT_FACE_DIRECTION = {NONE:0, XAXIS:1, YAXIS:2};
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.object2d = function $hamonengine$entities$object2d$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.entities.object2d && ($options$$ = {name:$options$$._name, boundingShape:$options$$._boundingShape, width:$options$$._width, height:$options$$._height, zinddex:$options$$._zindex, movementRate:$options$$._movementRate, position:$options$$._position, direction:$options$$._direction, theta:$options$$._theta, state:$options$$._state});
    this._name = $options$$.name || "";
    this._boundingShape = $options$$.boundingShape;
    this._width = $options$$.width || 0;
    this._height = $options$$.height || 0;
    this._zindex = $options$$.zindex || 0;
    this._movementRate = $options$$.movementRate || 0;
    this._position = $options$$.position || new hamonengine.geometry.vector2;
    this._direction = $options$$.direction || new hamonengine.geometry.vector2;
    this._theta = $options$$.theta || 0.0;
    void 0 !== $options$$.state ? this._state = $options$$.state : (this._state = 0, this._state |= $options$$.isSolid ? OBJECT_STATE_FLAG.SOLID : OBJECT_STATE_FLAG.NONE, this._state |= $options$$.isMovable ? OBJECT_STATE_FLAG.MOVEABLE : OBJECT_STATE_FLAG.NONE, this._state |= $options$$.isVisible ? OBJECT_STATE_FLAG.VISIBLE : OBJECT_STATE_FLAG.NONE);
    hamonengine.debug && (console.debug("[hamonengine.entities.object2d.constructor] Name: " + this.name), console.debug("[hamonengine.entities.object2d.constructor] Starting Dimensions {Width: " + this.width + ", Height: " + this.height + "}"), console.debug("[hamonengine.entities.object2d.constructor] Starting Direction: {x: " + this.direction.x + ", y: " + this.direction.y + "}"), console.debug("[hamonengine.entities.object2d.constructor] Starting Position: {x: " + this.position.x + ", y: " + 
    this.position.y + "}"), console.debug("[hamonengine.entities.object2d.constructor] Starting Theta: " + this.theta), console.debug("[hamonengine.entities.object2d.constructor] Movement Rate: " + this._movementRate), console.debug("[hamonengine.entities.object2d.constructor] isSolid: " + this.isSolid), console.debug("[hamonengine.entities.object2d.constructor] isMovable: " + this.isMovable), console.debug("[hamonengine.entities.object2d.constructor] isVisible: " + this.isVisible));
  };
  hamonengine.entities.object2d.prototype.move = function $hamonengine$entities$object2d$$move$($elapsedTimeInMilliseconds$$, $movementVector$$) {
    this.isMovable && ($movementVector$$ = (void 0 === $movementVector$$ ? null : $movementVector$$) || this.calcMove($elapsedTimeInMilliseconds$$), this.position.x += $movementVector$$.x, this.position.y += $movementVector$$.y);
    return this;
  };
  hamonengine.entities.object2d.prototype.calcMove = function $hamonengine$entities$object2d$$calcMove$($elapsedTimeInMilliseconds$$) {
    return new hamonengine.geometry.vector2(this._movementRate * this.direction.x * $elapsedTimeInMilliseconds$$, this._movementRate * this.direction.y * $elapsedTimeInMilliseconds$$);
  };
  hamonengine.entities.object2d.prototype.isCollision = function $hamonengine$entities$object2d$$isCollision$($object$$) {
    return this.boundingShape.translate(this.position).isCollision($object$$);
  };
  hamonengine.entities.object2d.prototype.isContained = function $hamonengine$entities$object2d$$isContained$($targetObject$$) {
    return this.boundingShape.isContained($targetObject$$.position, $targetObject$$.boundingShape);
  };
  hamonengine.entities.object2d.prototype.holdLeft = function $hamonengine$entities$object2d$$holdLeft$() {
    this.direction.x = -1;
  };
  hamonengine.entities.object2d.prototype.holdRight = function $hamonengine$entities$object2d$$holdRight$() {
    this.direction.x = 1;
  };
  hamonengine.entities.object2d.prototype.holdUp = function $hamonengine$entities$object2d$$holdUp$() {
    this.direction.y = -1;
  };
  hamonengine.entities.object2d.prototype.holdDown = function $hamonengine$entities$object2d$$holdDown$() {
    this.direction.y = 1;
  };
  hamonengine.entities.object2d.prototype.releaseHorizontal = function $hamonengine$entities$object2d$$releaseHorizontal$() {
    this.direction.x = 0;
  };
  hamonengine.entities.object2d.prototype.releaseVertical = function $hamonengine$entities$object2d$$releaseVertical$() {
    this.direction.y = 0;
  };
  hamonengine.entities.object2d.prototype.toString = function $hamonengine$entities$object2d$$toString$() {
    return "{name: '" + this.name + "', position: '" + this.position + "'}";
  };
  hamonengine.entities.object2d.prototype.onEnvironmentCollision = function $hamonengine$entities$object2d$$onEnvironmentCollision$($position$$, $environmentObject$$) {
    this._position = $position$$;
    return !0;
  };
  hamonengine.entities.object2d.prototype.onObjectCollision = function $hamonengine$entities$object2d$$onObjectCollision$($x$$, $y$$, $object$$) {
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.object2d.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, position:{configurable:!0, enumerable:!0, get:function() {
    return this._position;
  }, set:function($v$$) {
    this._position = $v$$;
  }}, direction:{configurable:!0, enumerable:!0, get:function() {
    return this._direction;
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return this._theta || 0.0;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._height;
  }}, zIndex:{configurable:!0, enumerable:!0, get:function() {
    return this._zindex;
  }, set:function($v$$) {
    this._zindex = $v$$;
  }}, boundingShape:{configurable:!0, enumerable:!0, get:function() {
    return this._boundingShape = this._boundingShape || new hamonengine.geometry.rect(0, 0, this.width, this.height);
  }}, isMovable:{configurable:!0, enumerable:!0, get:function() {
    return (this._state & OBJECT_STATE_FLAG.MOVEABLE) === OBJECT_STATE_FLAG.MOVEABLE;
  }}, isSolid:{configurable:!0, enumerable:!0, get:function() {
    return (this._state & OBJECT_STATE_FLAG.SOLID) === OBJECT_STATE_FLAG.SOLID;
  }}, isVisible:{configurable:!0, enumerable:!0, get:function() {
    return (this._state & OBJECT_STATE_FLAG.VISIBLE) === OBJECT_STATE_FLAG.VISIBLE;
  }, set:function($v$$) {
    this._state = $v$$ ? this._state | OBJECT_STATE_FLAG.VISIBLE : this._state ^ OBJECT_STATE_FLAG.VISIBLE;
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.spriteObject = function $hamonengine$entities$spriteObject$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.entities.object2d.call(this, $options$$);
    $options$$ instanceof hamonengine.entities.spriteObject && ($options$$ = {sprite:$options$$._sprite, directionBasis:$options$$._directionBasis});
    this._sprite = $options$$.sprite || new hamonengine.graphics.sprite;
    this._faceAxisOnMove = void 0 !== $options$$.faceAxisOnMove ? $options$$.faceAxisOnMove : OBJECT_FACE_DIRECTION.XAXIS | OBJECT_FACE_DIRECTION.YAXIS;
    this._directionBasis = $options$$.directionBasis || new hamonengine.geometry.vector2(-1, -1);
    hamonengine.debug && !this._hasBoundingShape && console.debug("[hamonengine.entities.spriteObject.constructor] BoundingShape not found, using sprite dimensions.");
  };
  $jscomp.inherits(hamonengine.entities.spriteObject, hamonengine.entities.object2d);
  hamonengine.entities.spriteObject.prototype.move = function $hamonengine$entities$spriteObject$$move$($elapsedTimeInMilliseconds$$, $movementVector$$) {
    hamonengine.entities.object2d.prototype.move.call(this, $elapsedTimeInMilliseconds$$, void 0 === $movementVector$$ ? null : $movementVector$$);
    (this.faceAxisOnMove & OBJECT_FACE_DIRECTION.XAXIS) === OBJECT_FACE_DIRECTION.XAXIS && 0 !== this.direction.x && this.sprite.mirror(this.direction.x === this._directionBasis.x).rotate();
    (this.faceAxisOnMove & OBJECT_FACE_DIRECTION.YAXIS) === OBJECT_FACE_DIRECTION.YAXIS && 0 !== this.direction.y && this.sprite.rotate(this.direction.y === this._directionBasis.y ? Math.PI_2 : -Math.PI_2);
    return this;
  };
  hamonengine.entities.spriteObject.prototype.reset = function $hamonengine$entities$spriteObject$$reset$() {
    return this.sprite.rotate().mirror(!1);
  };
  hamonengine.entities.spriteObject.prototype.render = function $hamonengine$entities$spriteObject$$render$($layer$$, $elapsedTimeInMilliseconds$$) {
    this.sprite && this.sprite.draw($layer$$, $elapsedTimeInMilliseconds$$, this.position.x, this.position.y, this.width, this.height);
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.spriteObject.prototype, {sprite:{configurable:!0, enumerable:!0, get:function() {
    return this._sprite;
  }, set:function($v$$) {
    this._sprite = $v$$;
  }}, faceAxisOnMove:{configurable:!0, enumerable:!0, get:function() {
    return this._faceAxisOnMove;
  }, set:function($v$$) {
    this._faceAxisOnMove = $v$$;
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.shapeObject = function $hamonengine$entities$shapeObject$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.entities.object2d.call(this, $options$$);
    $options$$ instanceof hamonengine.entities.shapeObject && ($options$$ = {shape:$options$$._shape});
    this._shape = $options$$.shape || new hamonengine.geometry.rect;
    this._faceAxisOnMove = void 0 !== $options$$.faceAxisOnMove ? $options$$.faceAxisOnMove : OBJECT_FACE_DIRECTION.XAXIS | OBJECT_FACE_DIRECTION.YAXIS;
    this._boundingShape = (this._hasBoundingShape = $options$$.boundingShape) || this._shape;
    this._directionBasis = $options$$.directionBasis || new hamonengine.geometry.vector2(-1, -1);
    this._mirroredState = !1;
    this._theta = 0;
    hamonengine.debug && !this._hasBoundingShape && console.debug("[hamonengine.entities.shapeObject.constructor] BoundingShape not found, using shape dimensions.");
  };
  $jscomp.inherits(hamonengine.entities.shapeObject, hamonengine.entities.object2d);
  hamonengine.entities.shapeObject.prototype.reset = function $hamonengine$entities$shapeObject$$reset$() {
    this._theta = 0;
    this._mirroredState = !1;
    return this;
  };
  hamonengine.entities.shapeObject.prototype.addVertex = function $hamonengine$entities$shapeObject$$addVertex$($x$$, $y$$) {
    (this.isPolygon ? this._shape : this._shape = this._shape.toPolygon()).addVertex($x$$, $y$$);
    return this;
  };
  hamonengine.entities.shapeObject.prototype.move = function $hamonengine$entities$shapeObject$$move$($elapsedTimeInMilliseconds$$, $movementVector$$) {
    hamonengine.entities.object2d.prototype.move.call(this, $elapsedTimeInMilliseconds$$, void 0 === $movementVector$$ ? null : $movementVector$$);
    this.isPolygon && ((this.faceAxisOnMove & OBJECT_FACE_DIRECTION.XAXIS) === OBJECT_FACE_DIRECTION.XAXIS && 0 !== this.direction.x && (this._mirroredState = this.direction.x === this._directionBasis.x, this._theta = 0), (this.faceAxisOnMove & OBJECT_FACE_DIRECTION.YAXIS) === OBJECT_FACE_DIRECTION.YAXIS && 0 !== this.direction.y && (this._theta = this.direction.y === this._directionBasis.y ? Math.PI_2 : -Math.PI_2));
    return this;
  };
  hamonengine.entities.shapeObject.prototype.isCollision = function $hamonengine$entities$shapeObject$$isCollision$($shapeObject$$) {
    if (this.isSolid && $shapeObject$$.isSolid) {
      var $direction$$ = new hamonengine.geometry.vector2;
      $shapeObject$$ instanceof hamonengine.entities.shapeObject && ($direction$$ = $shapeObject$$.position.subtract(this.position), $shapeObject$$ = $shapeObject$$.shape.translate($shapeObject$$.position));
      return this.shape.translate(this.position).isCollision($shapeObject$$, $direction$$);
    }
    return new hamonengine.geometry.vector2;
  };
  hamonengine.entities.shapeObject.prototype.render = function $hamonengine$entities$shapeObject$$render$($layer$$, $elapsedTimeInMilliseconds$jscomp$10_lineWidth$$, $$jscomp$destructuring$var32_color$$) {
    var $$jscomp$destructuring$var33_drawNormals$$ = void 0 === $$jscomp$destructuring$var32_color$$ ? {} : $$jscomp$destructuring$var32_color$$;
    $elapsedTimeInMilliseconds$jscomp$10_lineWidth$$ = void 0 === $$jscomp$destructuring$var33_drawNormals$$.lineWidth ? 3 : $$jscomp$destructuring$var33_drawNormals$$.lineWidth;
    $$jscomp$destructuring$var32_color$$ = void 0 === $$jscomp$destructuring$var33_drawNormals$$.color ? "blue" : $$jscomp$destructuring$var33_drawNormals$$.color;
    $$jscomp$destructuring$var33_drawNormals$$ = void 0 === $$jscomp$destructuring$var33_drawNormals$$.drawNormals ? !1 : $$jscomp$destructuring$var33_drawNormals$$.drawNormals;
    if (this.shape) {
      var $transformedShape$$ = this.shape.translate(this.position);
      $transformedShape$$ = this.isPolygon ? $transformedShape$$.mirror(this._mirroredState).rotateAtCenter(this._theta) : $transformedShape$$;
      $layer$$.drawShape($transformedShape$$, 0, 0, {lineWidth:$elapsedTimeInMilliseconds$jscomp$10_lineWidth$$, color:$$jscomp$destructuring$var32_color$$, drawNormals:$$jscomp$destructuring$var33_drawNormals$$});
    }
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.shapeObject.prototype, {shape:{configurable:!0, enumerable:!0, get:function() {
    return this._shape;
  }, set:function($v$$) {
    this._shape = $v$$;
    this._hasBoundingShape || (this._boundingShape = this.shape);
  }}, faceAxisOnMove:{configurable:!0, enumerable:!0, get:function() {
    return this._faceAxisOnMove;
  }, set:function($v$$) {
    this._faceAxisOnMove = $v$$;
  }}, isPolygon:{configurable:!0, enumerable:!0, get:function() {
    return this.shape instanceof hamonengine.geometry.polygon;
  }}, isRect:{configurable:!0, enumerable:!0, get:function() {
    return this.shape instanceof hamonengine.geometry.rect;
  }}, isLine:{configurable:!0, enumerable:!0, get:function() {
    return this.shape instanceof hamonengine.geometry.lineSegment;
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.cell = function $hamonengine$entities$cell$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.entities.object2d.call(this, $options$$);
    this._movementRate = 0;
    this._direction = new hamonengine.geometry.vector2;
    this._theta = 0;
    this._children = [];
    this._objects = [];
    this._zIndexSorter = new hamonengine.math.sort({compareFunc:function($a$$, $b$$) {
      return $a$$ === $b$$ ? 0 : $a$$.zIndex < $b$$.zIndex ? -1 : 1;
    }});
  };
  $jscomp.inherits(hamonengine.entities.cell, hamonengine.entities.object2d);
  hamonengine.entities.cell.prototype.addChild = function $hamonengine$entities$cell$$addChild$($child$$) {
    this._children.push($child$$);
  };
  hamonengine.entities.cell.prototype.addObject = function $hamonengine$entities$cell$$addObject$($object$$) {
    this._objects.push($object$$);
  };
  hamonengine.entities.cell.prototype.addObjects = function $hamonengine$entities$cell$$addObjects$($objects$$) {
    for (var $i$$ = 0; $i$$ < $objects$$.length; $i$$++) {
      this._objects.push($objects$$[$i$$]);
    }
  };
  hamonengine.entities.cell.prototype.process = function $hamonengine$entities$cell$$process$($elapsedTimeInMilliseconds$$) {
    if (this.objects) {
      for (var $collisionsEdges$$ = new Set, $i$$ = 0; $i$$ < this.objects.length; $i$$++) {
        var $object$$ = this.objects[$i$$];
        if ($object$$.isMovable && ($object$$.move($elapsedTimeInMilliseconds$$), this.isSolid)) {
          var $adjustedPosition_i$22$$ = hamonengine.geometry.vector2.clone($object$$.position), $collisionVector_siblingObject$$ = this.isContained($object$$);
          0 > $collisionVector_siblingObject$$.x ? $adjustedPosition_i$22$$.x = this.boundingShape.x - $object$$.boundingShape.x : 0 < $collisionVector_siblingObject$$.x && ($adjustedPosition_i$22$$.x = this.boundingShape.width - $object$$.boundingShape.right);
          0 > $collisionVector_siblingObject$$.y ? $adjustedPosition_i$22$$.y = this.boundingShape.y - $object$$.boundingShape.y : 0 < $collisionVector_siblingObject$$.y && ($adjustedPosition_i$22$$.y = this.boundingShape.height - $object$$.boundingShape.bottom);
          if (!$object$$.onEnvironmentCollision($adjustedPosition_i$22$$, this)) {
            break;
          }
        }
        for ($adjustedPosition_i$22$$ = 0; $adjustedPosition_i$22$$ < this.objects.length; $adjustedPosition_i$22$$++) {
          if ($collisionVector_siblingObject$$ = this.objects[$adjustedPosition_i$22$$], $object$$ !== $collisionVector_siblingObject$$) {
            var $edgeName$$ = $object$$.name + "->" + $collisionVector_siblingObject$$.name;
            $collisionsEdges$$.has($edgeName$$) || (console.log($object$$.isCollision($collisionVector_siblingObject$$)), $collisionsEdges$$.add($edgeName$$), $collisionsEdges$$.add($collisionVector_siblingObject$$.name + "->" + $object$$.name));
          }
        }
      }
    }
  };
  hamonengine.entities.cell.prototype.render = function $hamonengine$entities$cell$$render$($layer$$, $elapsedTimeInMilliseconds$$) {
    if (this.objects && (this._zIndexSorter.quickSort(this._objects), this.objects)) {
      for (var $i$$ = 0; $i$$ < this.objects.length; $i$$++) {
        this.objects[$i$$].render($layer$$, $elapsedTimeInMilliseconds$$);
      }
    }
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.cell.prototype, {children:{configurable:!0, enumerable:!0, get:function() {
    return this._children;
  }}, objects:{configurable:!0, enumerable:!0, get:function() {
    return this._objects;
  }}});
})();
hamonengine.core = hamonengine.core || {};
(function() {
  var $ENGINE_STATES_NAMES$$ = ["STOPPED", "STARTED", "LOADING", "RUNNING"];
  hamonengine.core.engine = function $hamonengine$core$engine$($options$$) {
    var $$jscomp$this$$ = this;
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    console.log("HamonEngine -- Using version: 0.2.0");
    this._movementRate = $options$$.movementRate || 0.25;
    this._size = $options$$.size || 64;
    this._showFPS = void 0 !== $options$$.showFPS ? $options$$.showFPS : !1;
    this._syncFrames = void 0 !== $options$$.syncFrames ? $options$$.syncFrames : !1;
    this._splashScreenWait = void 0 !== $options$$.splashScreenWait ? $options$$.splashScreenWait : 500;
    this._detectCanvas = void 0 !== $options$$.detectCanvas ? $options$$.detectCanvas : !0;
    this._allowDocumentEventBinding = void 0 !== $options$$.allowDocumentEventBinding ? $options$$.allowDocumentEventBinding : !1;
    this._captureTouchAsMouseEvents = void 0 !== $options$$.captureTouchAsMouseEvents ? $options$$.captureTouchAsMouseEvents : !0;
    var $blockArrowKeys_canvasCollection$$ = void 0 !== $options$$.blockArrowKeys ? $options$$.blockArrowKeys : !0;
    this._preventDefaultState = 0;
    this._preventDefaultState |= $options$$.blockAllKeys ? 1 : 0;
    this._preventDefaultState |= $blockArrowKeys_canvasCollection$$ ? 2 : 0;
    this._externalElements = $options$$.externalElements || [];
    this._animationId = this._lastFrameTimeStamp = this._startTimeStamp = this._state = 0;
    this._fpsCounter = new fpscounter;
    this._layers = {};
    $blockArrowKeys_canvasCollection$$ = $options$$.canvas || [];
    if (this._detectCanvas && 0 === $blockArrowKeys_canvasCollection$$.length) {
      hamonengine.debug && console.debug("[hamonengine.core.engine.constructor] DetectCanvas: true.  Attempting to detect all canvas."), Object.entries(document.getElementsByTagName("canvas")).forEach(function($$jscomp$destructuring$var34_canvasName$jscomp$1_key$$) {
        var $$jscomp$destructuring$var35_value$$ = $jscomp.makeIterator($$jscomp$destructuring$var34_canvasName$jscomp$1_key$$);
        $$jscomp$destructuring$var34_canvasName$jscomp$1_key$$ = $$jscomp$destructuring$var35_value$$.next().value;
        $$jscomp$destructuring$var35_value$$ = $$jscomp$destructuring$var35_value$$.next().value;
        $$jscomp$destructuring$var34_canvasName$jscomp$1_key$$ = $$jscomp$destructuring$var35_value$$.getAttribute("name") || "canvas" + $$jscomp$destructuring$var34_canvasName$jscomp$1_key$$;
        $$jscomp$this$$._layers[$$jscomp$destructuring$var34_canvasName$jscomp$1_key$$] = new hamonengine.graphics.layer({name:$$jscomp$destructuring$var34_canvasName$jscomp$1_key$$, canvas:$$jscomp$destructuring$var35_value$$, allowEventBinding:$$jscomp$destructuring$var35_value$$.dataset.alloweventbinding, enableImageSmoothing:$$jscomp$destructuring$var35_value$$.dataset.enableimagesmoothing, clipToViewPort:$$jscomp$destructuring$var35_value$$.dataset.cliptoviewport});
      });
    } else {
      hamonengine.debug && console.debug("[hamonengine.core.engine.constructor] DetectCanvas: false.  Using collection of options.canvas.");
      for (var $index$$ = 0, $i$$ = 0; $i$$ < $blockArrowKeys_canvasCollection$$.length; $i$$++) {
        var $canvas$$ = $blockArrowKeys_canvasCollection$$[$i$$], $canvasName$$ = $canvas$$.name || "canvas" + $index$$++;
        this._layers[$canvasName$$] = new hamonengine.graphics.layer({name:$canvasName$$, canvasId:$canvas$$.id, viewPort:$canvas$$.viewPort, allowEventBinding:$canvas$$.allowEventBinding, enableImageSmoothing:$options$$.enableImageSmoothing, clipToViewPort:$canvas$$.clipToViewPort});
      }
    }
    this._resourcesLoaded = !1;
    hamonengine.debug && (console.debug("[hamonengine.core.engine.constructor] MovementRate: " + this._movementRate), console.debug("[hamonengine.core.engine.constructor] State: " + $ENGINE_STATES_NAMES$$[this._state]), console.debug("[hamonengine.core.engine.constructor] SyncFrames: " + (this.syncFrames ? "Enabled" : "Disabled")), console.debug("[hamonengine.core.engine.constructor] SplashScreen Wait Time: " + this._splashScreenWait + " milliseconds."), console.debug("[hamonengine.core.engine.constructor] Global States"), 
    console.debug("[hamonengine.core.engine.constructor] hamonengine.geometry.settings.collisionDetection.floor: " + hamonengine.geometry.settings.collisionDetection.floor), console.debug("[hamonengine.core.engine.constructor] hamonengine.geometry.settings.collisionDetection.limit: " + hamonengine.geometry.settings.collisionDetection.limit), console.debug("[hamonengine.core.engine.constructor] hamonengine.geometry.settings.coordinateSystem: " + hamonengine.geometry.settings.coordinateSystem));
  };
  hamonengine.core.engine.prototype.getLayer = function $hamonengine$core$engine$$getLayer$($name$$) {
    return this._layers[$name$$];
  };
  hamonengine.core.engine.prototype.load = function $hamonengine$core$engine$$load$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              hamonengine.debug && console.debug("[hamonengine.core.engine.load]");
              $preloadPromise$$ = new Promise(function($resolve$$) {
                $$jscomp$async$this$$.onPreload() ? setTimeout(function() {
                  return $resolve$$();
                }, $$jscomp$async$this$$._splashScreenWait) : $resolve$$();
              });
              $$jscomp$async$this$$._state = 2;
              console.log("[hamonengine.core.engine.load] State: " + $ENGINE_STATES_NAMES$$[$$jscomp$async$this$$._state]);
              try {
                $eventBindingPromise$$ = $$jscomp$async$this$$.onEventBinding();
                if ($eventBindingPromise$$ instanceof Promise) {
                  $$jscomp$generator$state$$ = 3;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw "onEventBinding is not returning a promise!  This event must return an unhandled promise.";
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 3:
              try {
                return console.log("%c[hamonengine.core.engine.load] Engine is paused, waiting for event binding to resolve...", "color: yellow"), $$jscomp$generator$state$$ = 4, {value:$eventBindingPromise$$, done:!1};
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 4:
              try {
                if (void 0 === $$jscomp$generator$throw$arg$$) {
                  $$jscomp$generator$state$$ = 5;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw $$jscomp$generator$throw$arg$$;
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 5:
              try {
                console.log("%c[hamonengine.core.engine.load] Engine has resumed loading, event binding has completed.", "color: green");
                $loadingResource$$ = $$jscomp$async$this$$.onloadResources();
                if ($loadingResource$$ instanceof Promise) {
                  $$jscomp$generator$state$$ = 6;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw "onloadResources is not returning a promise!  This event must return an unhandled promise.";
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 6:
              try {
                return console.log("%c[hamonengine.core.engine.load] Engine is paused, waiting for resources to resolve...", "color: yellow"), $$jscomp$generator$state$$ = 7, {value:$loadingResource$$, done:!1};
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 7:
              try {
                if (void 0 === $$jscomp$generator$throw$arg$$) {
                  $$jscomp$generator$state$$ = 8;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw $$jscomp$generator$throw$arg$$;
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 8:
              try {
                return $$jscomp$async$this$$._resourcesLoaded = !0, console.log("%c[hamonengine.core.engine.load] Engine has resumed loading, resource loading completed.", "color: green"), console.log("%c[hamonengine.core.engine.load] Engine is paused, waiting for preload event to resolve...", "color: yellow"), $$jscomp$generator$state$$ = 9, {value:$preloadPromise$$, done:!1};
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 9:
              try {
                if (void 0 === $$jscomp$generator$throw$arg$$) {
                  $$jscomp$generator$state$$ = 10;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw $$jscomp$generator$throw$arg$$;
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 10:
              try {
                console.log("%c[hamonengine.core.engine.load] Preload completed.", "color: green");
                $$jscomp$generator$state$$ = 2;
                break;
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 1:
              $error$$ = $$jscomp$generator$global$error$$, console.error("[hamonengine.core.engine.load] Resources could not be loaded due to a failure! Stopping the engine."), console.error($error$$), $$jscomp$async$this$$.stop({reasons:"A critical error occured during resource loading."});
            case 2:
              return $$jscomp$generator$state$$ = -1, {value:$$jscomp$async$this$$, done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $error$$, $loadingResource$$, $eventBindingPromise$$, $$jscomp$generator$global$error$$, $preloadPromise$$, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.core.engine.prototype.start = function $hamonengine$core$engine$$start$() {
    hamonengine.debug && console.debug("[hamonengine.core.engine.start]");
    2 === this._state && (this._state = 1, console.log("[hamonengine.core.engine.start] State: " + $ENGINE_STATES_NAMES$$[this._state]), this.fpsCounter.start(), this.onDraw(0));
    return this;
  };
  hamonengine.core.engine.prototype.stop = function $hamonengine$core$engine$$stop$($$jscomp$destructuring$var36_reasons$$) {
    $$jscomp$destructuring$var36_reasons$$ = (void 0 === $$jscomp$destructuring$var36_reasons$$ ? {reasons:"Stopped By User"} : $$jscomp$destructuring$var36_reasons$$).reasons;
    hamonengine.debug && console.debug("[hamonengine.core.engine.stop]");
    window.cancelAnimationFrame(this._animationId);
    this._state = this._startTimeStamp = this._animationId = 0;
    console.log("[hamonengine.core.engine.stop] State: " + $ENGINE_STATES_NAMES$$[this._state]);
    this.onStop($$jscomp$destructuring$var36_reasons$$);
    return this;
  };
  hamonengine.core.engine.prototype.onPreload = function $hamonengine$core$engine$$onPreload$() {
    hamonengine.debug && console.debug("[hamonengine.core.engine.onPreload]");
    return !1;
  };
  hamonengine.core.engine.prototype.onloadResources = function $hamonengine$core$engine$$onloadResources$() {
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return hamonengine.debug && console.debug("[hamonengine.core.engine.onloadResources]"), $$jscomp$generator$state$$ = -1, {value:Promise.resolve(), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.core.engine.prototype.onEventBinding = function $hamonengine$core$engine$$onEventBinding$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return $$jscomp$generator$state$$ = -1, {value:new Promise(function($resolve$$, $reject$$) {
                window.addEventListener("DOMContentLoaded", function($event$$) {
                  var $touchEventMap$$ = new Map, $bindEvents$$ = function $$bindEvents$$$($elementToBind$$, $eventContainer$$) {
                    var $keyEvent$$ = function $$keyEvent$$$($type$$, $e$$) {
                      $$jscomp$async$this$$.onKeyEvent($type$$, $e$$.code, $e$$, $eventContainer$$);
                      $e$$ && ($$jscomp$async$this$$.blockByDefaultAllKeys ? $e$$.preventDefault() : $$jscomp$async$this$$.blockByDefaultArrowKeys && ("ArrowLeft" === $e$$.code || "ArrowRight" === $e$$.code || "ArrowUp" === $e$$.code || "ArrowDown" === $e$$.code) && $e$$.preventDefault());
                    }, $mouseEvent$$ = function $$mouseEvent$$$($type$$, $e$$) {
                      var $v$$ = new hamonengine.geometry.vector2($e$$.offsetX, $e$$.offsetY);
                      $$jscomp$async$this$$.onMouseEvent($type$$, $v$$, $e$$, $eventContainer$$);
                    }, $touchEvent$$ = function $$touchEvent$$$($type$$, $e$$) {
                      var $isClick_lasttouchevent$$ = $touchEventMap$$.has($eventContainer$$.name) ? $touchEventMap$$.get($eventContainer$$.name) : "";
                      $touchEventMap$$.set($eventContainer$$.name, $type$$);
                      var $position$jscomp$2_v$$ = $eventContainer$$.position;
                      if ($position$jscomp$2_v$$) {
                        for (var $touches$$ = [], $i$$ = 0; $i$$ < $e$$.touches.length; $i$$++) {
                          $touches$$.push(new hamonengine.geometry.vector2($e$$.touches[$i$$].clientX - $position$jscomp$2_v$$.x, $e$$.touches[$i$$].clientY - $position$jscomp$2_v$$.y));
                        }
                        $isClick_lasttouchevent$$ = "end" === $type$$ && "start" === $isClick_lasttouchevent$$;
                        $$jscomp$async$this$$.onTouchEvent($type$$, $touches$$, $e$$, $eventContainer$$);
                        $isClick_lasttouchevent$$ && $$jscomp$async$this$$.onTouchEvent("click", $touches$$, $e$$, $eventContainer$$);
                        $$jscomp$async$this$$.captureTouchAsMouseEvents && ($type$$ = "start" === $type$$ ? "down" : $type$$, $type$$ = "end" === $type$$ ? "up" : $type$$, $position$jscomp$2_v$$ = new hamonengine.geometry.vector2($e$$.changedTouches[0].clientX - $position$jscomp$2_v$$.x, $e$$.changedTouches[0].clientY - $position$jscomp$2_v$$.y), $$jscomp$async$this$$.onMouseEvent($type$$, $position$jscomp$2_v$$, $e$$, $eventContainer$$), $isClick_lasttouchevent$$ && $$jscomp$async$this$$.onMouseEvent("click", 
                        $position$jscomp$2_v$$, $e$$, $eventContainer$$));
                      }
                    };
                    $elementToBind$$.addEventListener("keyup", function($e$$) {
                      return $keyEvent$$("up", $e$$);
                    });
                    $elementToBind$$.addEventListener("keydown", function($e$$) {
                      return $keyEvent$$("down", $e$$);
                    });
                    $elementToBind$$.addEventListener("click", function($e$$) {
                      return $mouseEvent$$("click", $e$$);
                    });
                    $elementToBind$$.addEventListener("mouseup", function($e$$) {
                      return $mouseEvent$$("up", $e$$);
                    });
                    $elementToBind$$.addEventListener("mousedown", function($e$$) {
                      return $mouseEvent$$("down", $e$$);
                    });
                    $elementToBind$$.addEventListener("mousemove", function($e$$) {
                      return $mouseEvent$$("move", $e$$);
                    });
                    $elementToBind$$.addEventListener("mouseenter", function($e$$) {
                      return $mouseEvent$$("enter", $e$$);
                    });
                    $elementToBind$$.addEventListener("mouseleave", function($e$$) {
                      return $mouseEvent$$("leave", $e$$);
                    });
                    $elementToBind$$.addEventListener("touchstart", function($e$$) {
                      return $touchEvent$$("start", $e$$);
                    }, {passive:!1});
                    $elementToBind$$.addEventListener("touchmove", function($e$$) {
                      return $touchEvent$$("move", $e$$);
                    }, {passive:!1});
                    $elementToBind$$.addEventListener("touchend", function($e$$) {
                      return $touchEvent$$("end", $e$$);
                    }, {passive:!1});
                    $elementToBind$$.addEventListener("touchcancel", function($e$$) {
                      return $touchEvent$$("cancel", $e$$);
                    }, {passive:!1});
                  };
                  $$jscomp$async$this$$.allowDocumentEventBinding && $bindEvents$$(document, $$jscomp$async$this$$);
                  $$jscomp$async$this$$.externalElements.forEach(function($externalElement$$) {
                    return $bindEvents$$($externalElement$$, $externalElement$$);
                  });
                  $$jscomp$async$this$$.layers.forEach(function($layer$$) {
                    return $layer$$.allowEventBinding && $bindEvents$$($layer$$.canvas, $layer$$);
                  });
                });
                $resolve$$();
              }), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.core.engine.prototype.onKeyEvent = function $hamonengine$core$engine$$onKeyEvent$($type$$, $keyCode$$, $e$$, $caller$$) {
    hamonengine.debug && console.debug("[hamonengine.core.engine.onKeyEvent] Type: '" + $type$$ + "' '" + $keyCode$$ + "'");
  };
  hamonengine.core.engine.prototype.onMouseEvent = function $hamonengine$core$engine$$onMouseEvent$($type$$, $v$$, $e$$, $caller$$) {
    hamonengine.debug && hamonengine.verbose && console.debug("[hamonengine.core.engine.onMouseEvent] Type: '" + $type$$ + "' '" + $v$$.toString() + "'");
  };
  hamonengine.core.engine.prototype.onTouchEvent = function $hamonengine$core$engine$$onTouchEvent$($type$$, $touches$$, $e$$, $caller$$) {
    $e$$ && $e$$.preventDefault();
    hamonengine.debug && hamonengine.verbose && console.debug("[hamonengine.core.engine.onTouchEvent] Type: '" + $type$$ + "' '" + $e$$ + "'");
  };
  hamonengine.core.engine.prototype.onDraw = function $hamonengine$core$engine$$onDraw$($timestampInMilliseconds$$) {
    var $$jscomp$this$$ = this;
    $timestampInMilliseconds$$ = $timestampInMilliseconds$$ || 0;
    this._startTimeStamp || (this._startTimeStamp = $timestampInMilliseconds$$);
    var $elapsedTimeInMilliseconds$$ = $timestampInMilliseconds$$ - this._lastFrameTimeStamp;
    try {
      var $processingComplete$$ = !1;
      setTimeout(function() {
        $$jscomp$this$$.onProcessingFrame($elapsedTimeInMilliseconds$$);
        $processingComplete$$ = !0;
      }, 1);
      this._animationId = window.requestAnimationFrame(function($scopedTimestampInMS$$) {
        $$jscomp$this$$._state = 3;
        $$jscomp$this$$.syncFrames && !$processingComplete$$ || $$jscomp$this$$.onFrame($elapsedTimeInMilliseconds$$);
        $$jscomp$this$$.onDraw($scopedTimestampInMS$$);
      });
    } catch ($exception$$) {
      this.stop(), hamonengine.debug && console.debug($exception$$);
    }
    this._lastFrameTimeStamp = $timestampInMilliseconds$$;
    return this;
  };
  hamonengine.core.engine.prototype.onFrame = function $hamonengine$core$engine$$onFrame$($elapsedTimeInMilliseconds$$) {
    return this;
  };
  hamonengine.core.engine.prototype.onProcessingFrame = function $hamonengine$core$engine$$onProcessingFrame$($elapsedTimeInMilliseconds$$) {
    return this;
  };
  hamonengine.core.engine.prototype.onStop = function $hamonengine$core$engine$$onStop$($reasons$$) {
    return this;
  };
  $jscomp.global.Object.defineProperties(hamonengine.core.engine.prototype, {primaryLayer:{configurable:!0, enumerable:!0, get:function() {
    return this._layers.canvas0;
  }}, resourcesLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._resourcesLoaded;
  }}, fpsCounter:{configurable:!0, enumerable:!0, get:function() {
    return this._fpsCounter;
  }}, layers:{configurable:!0, enumerable:!0, get:function() {
    return Object.values(this._layers);
  }}, externalElements:{configurable:!0, enumerable:!0, get:function() {
    return this._externalElements;
  }}, syncFrames:{configurable:!0, enumerable:!0, get:function() {
    return this._syncFrames;
  }, set:function($v$$) {
    this._syncFrames = $v$$;
  }}, allowDocumentEventBinding:{configurable:!0, enumerable:!0, get:function() {
    return this._allowDocumentEventBinding;
  }}, captureTouchAsMouseEvents:{configurable:!0, enumerable:!0, get:function() {
    return this._captureTouchAsMouseEvents;
  }, set:function($v$$) {
    this._captureTouchAsMouseEvents = $v$$;
  }}, blockByDefaultAllKeys:{configurable:!0, enumerable:!0, get:function() {
    return 1 === (this._preventDefaultState & 1);
  }, set:function($v$$) {
    this._preventDefaultState = $v$$ ? this._preventDefaultState | 1 : this._preventDefaultState ^ 1;
  }}, blockByDefaultArrowKeys:{configurable:!0, enumerable:!0, get:function() {
    return 2 === (this._preventDefaultState & 2);
  }, set:function($v$$) {
    this._preventDefaultState = $v$$ ? this._preventDefaultState | 2 : this._preventDefaultState ^ 2;
  }}});
})();

