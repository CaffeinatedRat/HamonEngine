/*
 Hamonengine 波紋
 Copyright (c) 2020-2021, CaffeinatedRat.
 All rights reserved.
 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are met:

     * Redistributions of source code must retain the above copyright
       notice, this list of conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright
       notice, this list of conditions and the following disclaimer in the
       documentation and/or other materials provided with the distribution.

 THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY
 EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 DISCLAIMED. IN NO EVENT SHALL THE AUTHOR AND CONTRIBUTORS BE LIABLE FOR ANY
 DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = !1;
$jscomp.ASSUME_NO_NATIVE_MAP = !1;
$jscomp.ASSUME_NO_NATIVE_SET = !1;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function($target$$, $property$$, $descriptor$$) {
  $target$$ != Array.prototype && $target$$ != Object.prototype && ($target$$[$property$$] = $descriptor$$.value);
};
$jscomp.getGlobal = function $$jscomp$getGlobal$($maybeGlobal$$) {
  return "undefined" != typeof window && window === $maybeGlobal$$ ? $maybeGlobal$$ : "undefined" != typeof global && null != global ? global : $maybeGlobal$$;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.SYMBOL_PREFIX = "jscomp_symbol_";
$jscomp.initSymbol = function $$jscomp$initSymbol$() {
  $jscomp.initSymbol = function $$jscomp$initSymbol$() {
  };
  $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
};
$jscomp.symbolCounter_ = 0;
$jscomp.Symbol = function $$jscomp$Symbol$($opt_description$$) {
  return $jscomp.SYMBOL_PREFIX + ($opt_description$$ || "") + $jscomp.symbolCounter_++;
};
$jscomp.initSymbolIterator = function $$jscomp$initSymbolIterator$() {
  $jscomp.initSymbol();
  var $symbolIterator$$ = $jscomp.global.Symbol.iterator;
  $symbolIterator$$ || ($symbolIterator$$ = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
  "function" != typeof Array.prototype[$symbolIterator$$] && $jscomp.defineProperty(Array.prototype, $symbolIterator$$, {configurable:!0, writable:!0, value:function() {
    return $jscomp.arrayIterator(this);
  }});
  $jscomp.initSymbolIterator = function $$jscomp$initSymbolIterator$() {
  };
};
$jscomp.arrayIterator = function $$jscomp$arrayIterator$($array$$) {
  var $index$$ = 0;
  return $jscomp.iteratorPrototype(function() {
    return $index$$ < $array$$.length ? {done:!1, value:$array$$[$index$$++]} : {done:!0};
  });
};
$jscomp.iteratorPrototype = function $$jscomp$iteratorPrototype$($iterator$$) {
  $jscomp.initSymbolIterator();
  $iterator$$ = {next:$iterator$$};
  $iterator$$[$jscomp.global.Symbol.iterator] = function $$iterator$$$$jscomp$global$Symbol$iterator$() {
    return this;
  };
  return $iterator$$;
};
$jscomp.makeIterator = function $$jscomp$makeIterator$($iterable$$) {
  $jscomp.initSymbolIterator();
  var $iteratorFunction$$ = $iterable$$[Symbol.iterator];
  return $iteratorFunction$$ ? $iteratorFunction$$.call($iterable$$) : $jscomp.arrayIterator($iterable$$);
};
$jscomp.polyfill = function $$jscomp$polyfill$($property$jscomp$5_split_target$$, $impl_polyfill$$, $fromLang_obj$$, $i$$) {
  if ($impl_polyfill$$) {
    $fromLang_obj$$ = $jscomp.global;
    $property$jscomp$5_split_target$$ = $property$jscomp$5_split_target$$.split(".");
    for ($i$$ = 0; $i$$ < $property$jscomp$5_split_target$$.length - 1; $i$$++) {
      var $key$$ = $property$jscomp$5_split_target$$[$i$$];
      $key$$ in $fromLang_obj$$ || ($fromLang_obj$$[$key$$] = {});
      $fromLang_obj$$ = $fromLang_obj$$[$key$$];
    }
    $property$jscomp$5_split_target$$ = $property$jscomp$5_split_target$$[$property$jscomp$5_split_target$$.length - 1];
    $i$$ = $fromLang_obj$$[$property$jscomp$5_split_target$$];
    $impl_polyfill$$ = $impl_polyfill$$($i$$);
    $impl_polyfill$$ != $i$$ && null != $impl_polyfill$$ && $jscomp.defineProperty($fromLang_obj$$, $property$jscomp$5_split_target$$, {configurable:!0, writable:!0, value:$impl_polyfill$$});
  }
};
$jscomp.FORCE_POLYFILL_PROMISE = !1;
$jscomp.polyfill("Promise", function($NativePromise$$) {
  function $AsyncExecutor$$() {
    this.batch_ = null;
  }
  function $resolvingPromise$$($opt_value$$) {
    return $opt_value$$ instanceof $PolyfillPromise$$ ? $opt_value$$ : new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $resolve$$($opt_value$$);
    });
  }
  if ($NativePromise$$ && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return $NativePromise$$;
  }
  $AsyncExecutor$$.prototype.asyncExecute = function $$AsyncExecutor$$$$asyncExecute$($f$$) {
    null == this.batch_ && (this.batch_ = [], this.asyncExecuteBatch_());
    this.batch_.push($f$$);
    return this;
  };
  $AsyncExecutor$$.prototype.asyncExecuteBatch_ = function $$AsyncExecutor$$$$asyncExecuteBatch_$() {
    var $self$$ = this;
    this.asyncExecuteFunction(function() {
      $self$$.executeBatch_();
    });
  };
  var $nativeSetTimeout$$ = $jscomp.global.setTimeout;
  $AsyncExecutor$$.prototype.asyncExecuteFunction = function $$AsyncExecutor$$$$asyncExecuteFunction$($f$$) {
    $nativeSetTimeout$$($f$$, 0);
  };
  $AsyncExecutor$$.prototype.executeBatch_ = function $$AsyncExecutor$$$$executeBatch_$() {
    for (; this.batch_ && this.batch_.length;) {
      var $executingBatch$$ = this.batch_;
      this.batch_ = [];
      for (var $i$$ = 0; $i$$ < $executingBatch$$.length; ++$i$$) {
        var $f$$ = $executingBatch$$[$i$$];
        delete $executingBatch$$[$i$$];
        try {
          $f$$();
        } catch ($error$$) {
          this.asyncThrow_($error$$);
        }
      }
    }
    this.batch_ = null;
  };
  $AsyncExecutor$$.prototype.asyncThrow_ = function $$AsyncExecutor$$$$asyncThrow_$($exception$$) {
    this.asyncExecuteFunction(function() {
      throw $exception$$;
    });
  };
  var $PolyfillPromise$$ = function $$PolyfillPromise$$$($executor$$) {
    this.state_ = 0;
    this.result_ = void 0;
    this.onSettledCallbacks_ = [];
    var $resolveAndReject$$ = this.createResolveAndReject_();
    try {
      $executor$$($resolveAndReject$$.resolve, $resolveAndReject$$.reject);
    } catch ($e$$) {
      $resolveAndReject$$.reject($e$$);
    }
  };
  $PolyfillPromise$$.prototype.createResolveAndReject_ = function $$PolyfillPromise$$$$createResolveAndReject_$() {
    function $firstCallWins$$($method$$) {
      return function($x$$) {
        $alreadyCalled$$ || ($alreadyCalled$$ = !0, $method$$.call($thisPromise$$, $x$$));
      };
    }
    var $thisPromise$$ = this, $alreadyCalled$$ = !1;
    return {resolve:$firstCallWins$$(this.resolveTo_), reject:$firstCallWins$$(this.reject_)};
  };
  $PolyfillPromise$$.prototype.resolveTo_ = function $$PolyfillPromise$$$$resolveTo_$($value$$) {
    if ($value$$ === this) {
      this.reject_(new TypeError("A Promise cannot resolve to itself"));
    } else {
      if ($value$$ instanceof $PolyfillPromise$$) {
        this.settleSameAsPromise_($value$$);
      } else {
        a: {
          switch(typeof $value$$) {
            case "object":
              var $JSCompiler_inline_result$$ = null != $value$$;
              break a;
            case "function":
              $JSCompiler_inline_result$$ = !0;
              break a;
            default:
              $JSCompiler_inline_result$$ = !1;
          }
        }
        $JSCompiler_inline_result$$ ? this.resolveToNonPromiseObj_($value$$) : this.fulfill_($value$$);
      }
    }
  };
  $PolyfillPromise$$.prototype.resolveToNonPromiseObj_ = function $$PolyfillPromise$$$$resolveToNonPromiseObj_$($obj$$) {
    var $thenMethod$$ = void 0;
    try {
      $thenMethod$$ = $obj$$.then;
    } catch ($error$$) {
      this.reject_($error$$);
      return;
    }
    "function" == typeof $thenMethod$$ ? this.settleSameAsThenable_($thenMethod$$, $obj$$) : this.fulfill_($obj$$);
  };
  $PolyfillPromise$$.prototype.reject_ = function $$PolyfillPromise$$$$reject_$($reason$$) {
    this.settle_(2, $reason$$);
  };
  $PolyfillPromise$$.prototype.fulfill_ = function $$PolyfillPromise$$$$fulfill_$($value$$) {
    this.settle_(1, $value$$);
  };
  $PolyfillPromise$$.prototype.settle_ = function $$PolyfillPromise$$$$settle_$($settledState$$, $valueOrReason$$) {
    if (0 != this.state_) {
      throw Error("Cannot settle(" + $settledState$$ + ", " + $valueOrReason$$ | "): Promise already settled in state" + this.state_);
    }
    this.state_ = $settledState$$;
    this.result_ = $valueOrReason$$;
    this.executeOnSettledCallbacks_();
  };
  $PolyfillPromise$$.prototype.executeOnSettledCallbacks_ = function $$PolyfillPromise$$$$executeOnSettledCallbacks_$() {
    if (null != this.onSettledCallbacks_) {
      for (var $callbacks$$ = this.onSettledCallbacks_, $i$$ = 0; $i$$ < $callbacks$$.length; ++$i$$) {
        $callbacks$$[$i$$].call(), $callbacks$$[$i$$] = null;
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var $asyncExecutor$$ = new $AsyncExecutor$$;
  $PolyfillPromise$$.prototype.settleSameAsPromise_ = function $$PolyfillPromise$$$$settleSameAsPromise_$($promise$$) {
    var $methods$$ = this.createResolveAndReject_();
    $promise$$.callWhenSettled_($methods$$.resolve, $methods$$.reject);
  };
  $PolyfillPromise$$.prototype.settleSameAsThenable_ = function $$PolyfillPromise$$$$settleSameAsThenable_$($thenMethod$$, $thenable$$) {
    var $methods$$ = this.createResolveAndReject_();
    try {
      $thenMethod$$.call($thenable$$, $methods$$.resolve, $methods$$.reject);
    } catch ($error$$) {
      $methods$$.reject($error$$);
    }
  };
  $PolyfillPromise$$.prototype.then = function $$PolyfillPromise$$$$then$($onFulfilled$$, $onRejected$$) {
    function $createCallback$$($paramF$$, $defaultF$$) {
      return "function" == typeof $paramF$$ ? function($x$$) {
        try {
          $resolveChild$$($paramF$$($x$$));
        } catch ($error$$) {
          $rejectChild$$($error$$);
        }
      } : $defaultF$$;
    }
    var $resolveChild$$, $rejectChild$$, $childPromise$$ = new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $resolveChild$$ = $resolve$$;
      $rejectChild$$ = $reject$$;
    });
    this.callWhenSettled_($createCallback$$($onFulfilled$$, $resolveChild$$), $createCallback$$($onRejected$$, $rejectChild$$));
    return $childPromise$$;
  };
  $PolyfillPromise$$.prototype.catch = function $$PolyfillPromise$$$$catch$($onRejected$$) {
    return this.then(void 0, $onRejected$$);
  };
  $PolyfillPromise$$.prototype.callWhenSettled_ = function $$PolyfillPromise$$$$callWhenSettled_$($onFulfilled$$, $onRejected$$) {
    function $callback$$() {
      switch($thisPromise$$.state_) {
        case 1:
          $onFulfilled$$($thisPromise$$.result_);
          break;
        case 2:
          $onRejected$$($thisPromise$$.result_);
          break;
        default:
          throw Error("Unexpected state: " + $thisPromise$$.state_);
      }
    }
    var $thisPromise$$ = this;
    null == this.onSettledCallbacks_ ? $asyncExecutor$$.asyncExecute($callback$$) : this.onSettledCallbacks_.push(function() {
      $asyncExecutor$$.asyncExecute($callback$$);
    });
  };
  $PolyfillPromise$$.resolve = $resolvingPromise$$;
  $PolyfillPromise$$.reject = function $$PolyfillPromise$$$reject$($opt_reason$$) {
    return new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      $reject$$($opt_reason$$);
    });
  };
  $PolyfillPromise$$.race = function $$PolyfillPromise$$$race$($thenablesOrValues$$) {
    return new $PolyfillPromise$$(function($resolve$$, $reject$$) {
      for (var $iterator$$ = $jscomp.makeIterator($thenablesOrValues$$), $iterRec$$ = $iterator$$.next(); !$iterRec$$.done; $iterRec$$ = $iterator$$.next()) {
        $resolvingPromise$$($iterRec$$.value).callWhenSettled_($resolve$$, $reject$$);
      }
    });
  };
  $PolyfillPromise$$.all = function $$PolyfillPromise$$$all$($thenablesOrValues$$) {
    var $iterator$$ = $jscomp.makeIterator($thenablesOrValues$$), $iterRec$$ = $iterator$$.next();
    return $iterRec$$.done ? $resolvingPromise$$([]) : new $PolyfillPromise$$(function($resolveAll$$, $rejectAll$$) {
      function $onFulfilled$$($i$$) {
        return function($ithResult$$) {
          $resultsArray$$[$i$$] = $ithResult$$;
          $unresolvedCount$$--;
          0 == $unresolvedCount$$ && $resolveAll$$($resultsArray$$);
        };
      }
      var $resultsArray$$ = [], $unresolvedCount$$ = 0;
      do {
        $resultsArray$$.push(void 0), $unresolvedCount$$++, $resolvingPromise$$($iterRec$$.value).callWhenSettled_($onFulfilled$$($resultsArray$$.length - 1), $rejectAll$$), $iterRec$$ = $iterator$$.next();
      } while (!$iterRec$$.done);
    });
  };
  return $PolyfillPromise$$;
}, "es6", "es3");
$jscomp.executeAsyncGenerator = function $$jscomp$executeAsyncGenerator$($generator$$) {
  function $passValueToGenerator$$($value$$) {
    return $generator$$.next($value$$);
  }
  function $passErrorToGenerator$$($error$$) {
    return $generator$$.throw($error$$);
  }
  return new Promise(function($resolve$$, $reject$$) {
    function $handleGeneratorRecord$$($genRec$$) {
      $genRec$$.done ? $resolve$$($genRec$$.value) : Promise.resolve($genRec$$.value).then($passValueToGenerator$$, $passErrorToGenerator$$).then($handleGeneratorRecord$$, $reject$$);
    }
    $handleGeneratorRecord$$($generator$$.next());
  });
};
$jscomp.inherits = function $$jscomp$inherits$($childCtor$$, $parentCtor$$) {
  function $tempCtor$$() {
  }
  $tempCtor$$.prototype = $parentCtor$$.prototype;
  $childCtor$$.superClass_ = $parentCtor$$.prototype;
  $childCtor$$.prototype = new $tempCtor$$;
  $childCtor$$.prototype.constructor = $childCtor$$;
  for (var $p$$ in $parentCtor$$) {
    if ("prototype" != $p$$) {
      if (Object.defineProperties) {
        var $descriptor$$ = Object.getOwnPropertyDescriptor($parentCtor$$, $p$$);
        $descriptor$$ && Object.defineProperty($childCtor$$, $p$$, $descriptor$$);
      } else {
        $childCtor$$[$p$$] = $parentCtor$$[$p$$];
      }
    }
  }
};
$jscomp.polyfill("Array.prototype.fill", function($orig$$) {
  return $orig$$ ? $orig$$ : function($value$$, $i$$, $opt_end$$) {
    var $length$$ = this.length || 0;
    0 > $i$$ && ($i$$ = Math.max(0, $length$$ + $i$$));
    if (null == $opt_end$$ || $opt_end$$ > $length$$) {
      $opt_end$$ = $length$$;
    }
    $opt_end$$ = Number($opt_end$$);
    0 > $opt_end$$ && ($opt_end$$ = Math.max(0, $length$$ + $opt_end$$));
    for ($i$$ = Number($i$$ || 0); $i$$ < $opt_end$$; $i$$++) {
      this[$i$$] = $value$$;
    }
    return this;
  };
}, "es6", "es3");
$jscomp.owns = function $$jscomp$owns$($obj$$, $prop$$) {
  return Object.prototype.hasOwnProperty.call($obj$$, $prop$$);
};
$jscomp.polyfill("WeakMap", function($NativeWeakMap$$) {
  function $insert$$($target$$) {
    $jscomp.owns($target$$, $prop$$) || $jscomp.defineProperty($target$$, $prop$$, {value:{}});
  }
  function $patch$$($name$$) {
    var $prev$$ = Object[$name$$];
    $prev$$ && (Object[$name$$] = function $Object$$name$$$($target$$) {
      $insert$$($target$$);
      return $prev$$($target$$);
    });
  }
  if (function isConformant() {
    if (!$NativeWeakMap$$ || !Object.seal) {
      return !1;
    }
    try {
      var $x$$ = Object.seal({}), $y$$ = Object.seal({}), $map$$ = new $NativeWeakMap$$([[$x$$, 2], [$y$$, 3]]);
      if (2 != $map$$.get($x$$) || 3 != $map$$.get($y$$)) {
        return !1;
      }
      $map$$.delete($x$$);
      $map$$.set($y$$, 4);
      return !$map$$.has($x$$) && 4 == $map$$.get($y$$);
    } catch ($err$$) {
      return !1;
    }
  }()) {
    return $NativeWeakMap$$;
  }
  var $prop$$ = "$jscomp_hidden_" + Math.random().toString().substring(2);
  $patch$$("freeze");
  $patch$$("preventExtensions");
  $patch$$("seal");
  var $index$$ = 0, $PolyfillWeakMap$$ = function $$PolyfillWeakMap$$$($iter_opt_iterable$$) {
    this.id_ = ($index$$ += Math.random() + 1).toString();
    if ($iter_opt_iterable$$) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      $iter_opt_iterable$$ = $jscomp.makeIterator($iter_opt_iterable$$);
      for (var $entry_item$$; !($entry_item$$ = $iter_opt_iterable$$.next()).done;) {
        $entry_item$$ = $entry_item$$.value, this.set($entry_item$$[0], $entry_item$$[1]);
      }
    }
  };
  $PolyfillWeakMap$$.prototype.set = function $$PolyfillWeakMap$$$$set$($key$$, $value$$) {
    $insert$$($key$$);
    if (!$jscomp.owns($key$$, $prop$$)) {
      throw Error("WeakMap key fail: " + $key$$);
    }
    $key$$[$prop$$][this.id_] = $value$$;
    return this;
  };
  $PolyfillWeakMap$$.prototype.get = function $$PolyfillWeakMap$$$$get$($key$$) {
    return $jscomp.owns($key$$, $prop$$) ? $key$$[$prop$$][this.id_] : void 0;
  };
  $PolyfillWeakMap$$.prototype.has = function $$PolyfillWeakMap$$$$has$($key$$) {
    return $jscomp.owns($key$$, $prop$$) && $jscomp.owns($key$$[$prop$$], this.id_);
  };
  $PolyfillWeakMap$$.prototype.delete = function $$PolyfillWeakMap$$$$delete$($key$$) {
    return $jscomp.owns($key$$, $prop$$) && $jscomp.owns($key$$[$prop$$], this.id_) ? delete $key$$[$prop$$][this.id_] : !1;
  };
  return $PolyfillWeakMap$$;
}, "es6", "es3");
$jscomp.MapEntry = function $$jscomp$MapEntry$() {
};
$jscomp.polyfill("Map", function($NativeMap$$) {
  if (!$jscomp.ASSUME_NO_NATIVE_MAP && function() {
    if (!$NativeMap$$ || !$NativeMap$$.prototype.entries || "function" != typeof Object.seal) {
      return !1;
    }
    try {
      var $key$$ = Object.seal({x:4}), $map$$ = new $NativeMap$$($jscomp.makeIterator([[$key$$, "s"]]));
      if ("s" != $map$$.get($key$$) || 1 != $map$$.size || $map$$.get({x:4}) || $map$$.set({x:4}, "t") != $map$$ || 2 != $map$$.size) {
        return !1;
      }
      var $iter$$ = $map$$.entries(), $item$$ = $iter$$.next();
      if ($item$$.done || $item$$.value[0] != $key$$ || "s" != $item$$.value[1]) {
        return !1;
      }
      $item$$ = $iter$$.next();
      return $item$$.done || 4 != $item$$.value[0].x || "t" != $item$$.value[1] || !$iter$$.next().done ? !1 : !0;
    } catch ($err$$) {
      return !1;
    }
  }()) {
    return $NativeMap$$;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var $idMap$$ = new WeakMap, $PolyfillMap$$ = function $$PolyfillMap$$$($iter$jscomp$2_opt_iterable$$) {
    this.data_ = {};
    this.head_ = $createHead$$();
    this.size = 0;
    if ($iter$jscomp$2_opt_iterable$$) {
      $iter$jscomp$2_opt_iterable$$ = $jscomp.makeIterator($iter$jscomp$2_opt_iterable$$);
      for (var $entry$jscomp$1_item$$; !($entry$jscomp$1_item$$ = $iter$jscomp$2_opt_iterable$$.next()).done;) {
        $entry$jscomp$1_item$$ = $entry$jscomp$1_item$$.value, this.set($entry$jscomp$1_item$$[0], $entry$jscomp$1_item$$[1]);
      }
    }
  };
  $PolyfillMap$$.prototype.set = function $$PolyfillMap$$$$set$($key$$, $value$$) {
    var $r$$ = $maybeGetEntry$$(this, $key$$);
    $r$$.list || ($r$$.list = this.data_[$r$$.id] = []);
    $r$$.entry ? $r$$.entry.value = $value$$ : ($r$$.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:$key$$, value:$value$$}, $r$$.list.push($r$$.entry), this.head_.previous.next = $r$$.entry, this.head_.previous = $r$$.entry, this.size++);
    return this;
  };
  $PolyfillMap$$.prototype.delete = function $$PolyfillMap$$$$delete$($key$jscomp$34_r$$) {
    $key$jscomp$34_r$$ = $maybeGetEntry$$(this, $key$jscomp$34_r$$);
    return $key$jscomp$34_r$$.entry && $key$jscomp$34_r$$.list ? ($key$jscomp$34_r$$.list.splice($key$jscomp$34_r$$.index, 1), $key$jscomp$34_r$$.list.length || delete this.data_[$key$jscomp$34_r$$.id], $key$jscomp$34_r$$.entry.previous.next = $key$jscomp$34_r$$.entry.next, $key$jscomp$34_r$$.entry.next.previous = $key$jscomp$34_r$$.entry.previous, $key$jscomp$34_r$$.entry.head = null, this.size--, !0) : !1;
  };
  $PolyfillMap$$.prototype.clear = function $$PolyfillMap$$$$clear$() {
    this.data_ = {};
    this.head_ = this.head_.previous = $createHead$$();
    this.size = 0;
  };
  $PolyfillMap$$.prototype.has = function $$PolyfillMap$$$$has$($key$$) {
    return !!$maybeGetEntry$$(this, $key$$).entry;
  };
  $PolyfillMap$$.prototype.get = function $$PolyfillMap$$$$get$($entry$jscomp$2_key$$) {
    return ($entry$jscomp$2_key$$ = $maybeGetEntry$$(this, $entry$jscomp$2_key$$).entry) && $entry$jscomp$2_key$$.value;
  };
  $PolyfillMap$$.prototype.entries = function $$PolyfillMap$$$$entries$() {
    return $makeIterator$$(this, function($entry$$) {
      return [$entry$$.key, $entry$$.value];
    });
  };
  $PolyfillMap$$.prototype.keys = function $$PolyfillMap$$$$keys$() {
    return $makeIterator$$(this, function($entry$$) {
      return $entry$$.key;
    });
  };
  $PolyfillMap$$.prototype.values = function $$PolyfillMap$$$$values$() {
    return $makeIterator$$(this, function($entry$$) {
      return $entry$$.value;
    });
  };
  $PolyfillMap$$.prototype.forEach = function $$PolyfillMap$$$$forEach$($callback$$, $opt_thisArg$$) {
    for (var $iter$$ = this.entries(), $entry$jscomp$6_item$$; !($entry$jscomp$6_item$$ = $iter$$.next()).done;) {
      $entry$jscomp$6_item$$ = $entry$jscomp$6_item$$.value, $callback$$.call($opt_thisArg$$, $entry$jscomp$6_item$$[1], $entry$jscomp$6_item$$[0], this);
    }
  };
  $PolyfillMap$$.prototype[Symbol.iterator] = $PolyfillMap$$.prototype.entries;
  var $maybeGetEntry$$ = function $$maybeGetEntry$$$($index$jscomp$45_map$$, $key$$) {
    var $id$jscomp$4_id$jscomp$inline_66_type$$ = $key$$ && typeof $key$$;
    "object" == $id$jscomp$4_id$jscomp$inline_66_type$$ || "function" == $id$jscomp$4_id$jscomp$inline_66_type$$ ? $idMap$$.has($key$$) ? $id$jscomp$4_id$jscomp$inline_66_type$$ = $idMap$$.get($key$$) : ($id$jscomp$4_id$jscomp$inline_66_type$$ = "" + ++$mapIndex$$, $idMap$$.set($key$$, $id$jscomp$4_id$jscomp$inline_66_type$$)) : $id$jscomp$4_id$jscomp$inline_66_type$$ = "p_" + $key$$;
    var $list$$ = $index$jscomp$45_map$$.data_[$id$jscomp$4_id$jscomp$inline_66_type$$];
    if ($list$$ && $jscomp.owns($index$jscomp$45_map$$.data_, $id$jscomp$4_id$jscomp$inline_66_type$$)) {
      for ($index$jscomp$45_map$$ = 0; $index$jscomp$45_map$$ < $list$$.length; $index$jscomp$45_map$$++) {
        var $entry$$ = $list$$[$index$jscomp$45_map$$];
        if ($key$$ !== $key$$ && $entry$$.key !== $entry$$.key || $key$$ === $entry$$.key) {
          return {id:$id$jscomp$4_id$jscomp$inline_66_type$$, list:$list$$, index:$index$jscomp$45_map$$, entry:$entry$$};
        }
      }
    }
    return {id:$id$jscomp$4_id$jscomp$inline_66_type$$, list:$list$$, index:-1, entry:void 0};
  }, $makeIterator$$ = function $$makeIterator$$$($map$$, $func$$) {
    var $entry$$ = $map$$.head_;
    return $jscomp.iteratorPrototype(function() {
      if ($entry$$) {
        for (; $entry$$.head != $map$$.head_;) {
          $entry$$ = $entry$$.previous;
        }
        for (; $entry$$.next != $entry$$.head;) {
          return $entry$$ = $entry$$.next, {done:!1, value:$func$$($entry$$)};
        }
        $entry$$ = null;
      }
      return {done:!0, value:void 0};
    });
  }, $createHead$$ = function $$createHead$$$() {
    var $head$$ = {};
    return $head$$.previous = $head$$.next = $head$$.head = $head$$;
  }, $mapIndex$$ = 0;
  return $PolyfillMap$$;
}, "es6", "es3");
$jscomp.polyfill("Set", function($NativeSet$$) {
  if (!$jscomp.ASSUME_NO_NATIVE_SET && function() {
    if (!$NativeSet$$ || !$NativeSet$$.prototype.entries || "function" != typeof Object.seal) {
      return !1;
    }
    try {
      var $value$$ = Object.seal({x:4}), $set$$ = new $NativeSet$$($jscomp.makeIterator([$value$$]));
      if (!$set$$.has($value$$) || 1 != $set$$.size || $set$$.add($value$$) != $set$$ || 1 != $set$$.size || $set$$.add({x:4}) != $set$$ || 2 != $set$$.size) {
        return !1;
      }
      var $iter$$ = $set$$.entries(), $item$$ = $iter$$.next();
      if ($item$$.done || $item$$.value[0] != $value$$ || $item$$.value[1] != $value$$) {
        return !1;
      }
      $item$$ = $iter$$.next();
      return $item$$.done || $item$$.value[0] == $value$$ || 4 != $item$$.value[0].x || $item$$.value[1] != $item$$.value[0] ? !1 : $iter$$.next().done;
    } catch ($err$$) {
      return !1;
    }
  }()) {
    return $NativeSet$$;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var $PolyfillSet$$ = function $$PolyfillSet$$$($iter$jscomp$5_opt_iterable$$) {
    this.map_ = new Map;
    if ($iter$jscomp$5_opt_iterable$$) {
      $iter$jscomp$5_opt_iterable$$ = $jscomp.makeIterator($iter$jscomp$5_opt_iterable$$);
      for (var $entry$$; !($entry$$ = $iter$jscomp$5_opt_iterable$$.next()).done;) {
        this.add($entry$$.value);
      }
    }
    this.size = this.map_.size;
  };
  $PolyfillSet$$.prototype.add = function $$PolyfillSet$$$$add$($value$$) {
    this.map_.set($value$$, $value$$);
    this.size = this.map_.size;
    return this;
  };
  $PolyfillSet$$.prototype.delete = function $$PolyfillSet$$$$delete$($result_value$$) {
    $result_value$$ = this.map_.delete($result_value$$);
    this.size = this.map_.size;
    return $result_value$$;
  };
  $PolyfillSet$$.prototype.clear = function $$PolyfillSet$$$$clear$() {
    this.map_.clear();
    this.size = 0;
  };
  $PolyfillSet$$.prototype.has = function $$PolyfillSet$$$$has$($value$$) {
    return this.map_.has($value$$);
  };
  $PolyfillSet$$.prototype.entries = function $$PolyfillSet$$$$entries$() {
    return this.map_.entries();
  };
  $PolyfillSet$$.prototype.values = function $$PolyfillSet$$$$values$() {
    return this.map_.values();
  };
  $PolyfillSet$$.prototype.keys = $PolyfillSet$$.prototype.values;
  $PolyfillSet$$.prototype[Symbol.iterator] = $PolyfillSet$$.prototype.values;
  $PolyfillSet$$.prototype.forEach = function $$PolyfillSet$$$$forEach$($callback$$, $opt_thisArg$$) {
    var $set$$ = this;
    this.map_.forEach(function($value$$) {
      return $callback$$.call($opt_thisArg$$, $value$$, $value$$, $set$$);
    });
  };
  return $PolyfillSet$$;
}, "es6", "es3");
$jscomp.polyfill("Object.entries", function($orig$$) {
  return $orig$$ ? $orig$$ : function($obj$$) {
    var $result$$ = [], $key$$;
    for ($key$$ in $obj$$) {
      $jscomp.owns($obj$$, $key$$) && $result$$.push([$key$$, $obj$$[$key$$]]);
    }
    return $result$$;
  };
}, "es8", "es3");
$jscomp.polyfill("Object.values", function($orig$$) {
  return $orig$$ ? $orig$$ : function($obj$$) {
    var $result$$ = [], $key$$;
    for ($key$$ in $obj$$) {
      $jscomp.owns($obj$$, $key$$) && $result$$.push($obj$$[$key$$]);
    }
    return $result$$;
  };
}, "es8", "es3");
var hamonengine = {debug:!0};
var bitflag = function $bitflag$() {
};
bitflag.toggle = function $bitflag$toggle$($value$$, $bitToToggle$$, $state$$) {
  return void 0 !== $state$$ ? $state$$ ? $value$$ | 1 << $bitToToggle$$ : $value$$ & ~(1 << $bitToToggle$$) : $value$$ ^ 1 << $bitToToggle$$;
};
bitflag.isSet = function $bitflag$isSet$($value$$, $bitToCheck_valueToCheck$$) {
  $bitToCheck_valueToCheck$$ = 1 << $bitToCheck_valueToCheck$$;
  return ($value$$ & $bitToCheck_valueToCheck$$) === $bitToCheck_valueToCheck$$;
};
var connect = function $connect$($options$$) {
  $options$$ = void 0 === $options$$ ? {} : $options$$;
  this._timeout = $options$$.timeout;
};
connect.get = function $connect$get$($url$$, $options$$) {
  $options$$ = (void 0 === $options$$ ? {} : $options$$).timeout;
  if (!$url$$) {
    throw "Invalid url '" + $url$$ + "'";
  }
  var $xhr$$ = new XMLHttpRequest;
  if (!$xhr$$) {
    throw "Unable to create XMLHttpRequest";
  }
  void 0 !== $options$$ && ($xhr$$.timeout = $options$$);
  return new Promise(function($resolve$$, $reject$$) {
    $xhr$$.addEventListener("load", function($e$$) {
      var $status$$ = $xhr$$.status;
      0 === $status$$ || 200 <= $status$$ && 400 > $status$$ ? $resolve$$({data:$xhr$$.responseText, status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$}) : $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.addEventListener("error", function($e$$) {
      return $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.open("GET", $url$$);
    $xhr$$.send();
  });
};
connect.post = function $connect$post$($url$$, $data$$, $$jscomp$destructuring$var1_options$$) {
  $$jscomp$destructuring$var1_options$$ = void 0 === $$jscomp$destructuring$var1_options$$ ? {} : $$jscomp$destructuring$var1_options$$;
  var $timeout$$ = $$jscomp$destructuring$var1_options$$.timeout, $contentType$$ = $$jscomp$destructuring$var1_options$$.contentType, $accept$$ = $$jscomp$destructuring$var1_options$$.accept;
  if (!$url$$) {
    throw "Invalid url '" + $url$$ + "'";
  }
  var $xhr$$ = new XMLHttpRequest;
  if (!$xhr$$) {
    throw "Unable to create XMLHttpRequest";
  }
  void 0 !== $timeout$$ && ($xhr$$.timeout = $timeout$$);
  return new Promise(function($resolve$$, $reject$$) {
    $xhr$$.addEventListener("load", function($e$$) {
      0 === status || 200 <= status && 400 > status ? $resolve$$({data:$xhr$$.responseText, status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$}) : $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.addEventListener("error", function($e$$) {
      return $reject$$({status:$xhr$$.status, statusText:$xhr$$.statusText, event:$e$$});
    });
    $xhr$$.open("POST", $url$$);
    void 0 !== $contentType$$ ? $xhr$$.setRequestHeader("Content-Type", $contentType$$) : $xhr$$.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
    void 0 !== $accept$$ ? $xhr$$.setRequestHeader("Accept", $accept$$) : $xhr$$.setRequestHeader("Accept", "application/x-www-form-urlencoded");
    $xhr$$.send($data$$);
  });
};
$jscomp.global.Object.defineProperties(connect.prototype, {timeout:{configurable:!0, enumerable:!0, get:function() {
  return this._timeout;
}}});
var MILLISECONDS = 1000, fpscounter = function $fpscounter$($options$$) {
  this._spf = this._fps = this._frameCounter = this._globalStartTime = 0;
  this._minFPS = MILLISECONDS;
  this._maxFPS = 0;
};
fpscounter.prototype.start = function $fpscounter$$start$() {
  this._globalStartTime = Date.now();
  this._spf = this._fps = this._frameCounter = 0;
  this._minFPS = MILLISECONDS;
  this._maxFPS = 0;
};
fpscounter.prototype.begin = function $fpscounter$$begin$() {
  this._frameStartTime = Date.now();
};
fpscounter.prototype.end = function $fpscounter$$end$() {
  if (0 === this._startTime) {
    throw "[fpscounter.end] Begin was not called before end.";
  }
  var $frameEndTime$$ = Date.now();
  this._frameCounter++;
  this._spf = ($frameEndTime$$ - this._frameStartTime) * MILLISECONDS;
  $frameEndTime$$ > this._globalStartTime + MILLISECONDS && (this._fps = Math.round(MILLISECONDS * this._frameCounter / ($frameEndTime$$ - this._globalStartTime)), this._minFPS = Math.min(this._minFPS, this._fps), this._maxFPS = Math.max(this._maxFPS, this._fps), this._globalStartTime = $frameEndTime$$, this._frameCounter = 0);
};
$jscomp.global.Object.defineProperties(fpscounter.prototype, {SPF:{configurable:!0, enumerable:!0, get:function() {
  return this._spf;
}}, FPS:{configurable:!0, enumerable:!0, get:function() {
  return this._fps;
}}, minFPS:{configurable:!0, enumerable:!0, get:function() {
  return this._minFPS;
}}, maxFPS:{configurable:!0, enumerable:!0, get:function() {
  return this._maxFPS;
}}});
var LOG_TYPE = {DISABLED:0, INFO:1, WARNING:2, CRITICAL:4, DEBUG:8, ALL:15};
hamonengine.util = hamonengine.util || {loggerlevel:LOG_TYPE.DISABLED};
(function() {
  hamonengine.util.logger = function $hamonengine$util$logger$() {
  };
  hamonengine.util.logger.debug = function $hamonengine$util$logger$debug$($message$$) {
    (hamonengine.util.loggerlevel & LOG_TYPE.DEBUG) === LOG_TYPE.DEBUG && console.log($message$$);
  };
  hamonengine.util.logger.info = function $hamonengine$util$logger$info$($message$$) {
    (hamonengine.util.loggerlevel & LOG_TYPE.INFO) === LOG_TYPE.INFO && console.info($message$$);
  };
  hamonengine.util.logger.warning = function $hamonengine$util$logger$warning$($message$$) {
    (hamonengine.util.loggerlevel & LOG_TYPE.WARNING) === LOG_TYPE.WARNING && console.warn($message$$);
  };
})();
var worker = function $worker$($options$$) {
  $options$$ = void 0 === $options$$ ? {} : $options$$;
  $options$$ instanceof worker && ($options$$ = {blob:$options$$.blob, method:$options$$.method});
  if (!$options$$.method) {
    throw console.error("[worker.constructor] Unable to create a workert: options.method is undefined!"), "Cannot create the worker";
  }
  this._method = $options$$.method;
  this._blob = $options$$.blob || new Blob(["onmessage = " + $options$$.method.toString() + ";"], {type:"text/javascript"});
  this._url = URL.createObjectURL(this._blob);
  this._worker = new Worker(this._url);
};
worker.create = function $worker$create$($method$$) {
  return new worker({method:$method$$});
};
worker.prototype.run = function $worker$$run$($data$$) {
  var $$jscomp$async$this$$ = this;
  return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
    function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
      for (;;) {
        switch($$jscomp$generator$state$$) {
          case 0:
            return $$jscomp$generator$state$$ = -1, {value:new Promise(function($resolve$$, $reject$$) {
              $$jscomp$async$this$$.worker.onmessage = function $$$jscomp$async$this$$$worker$onmessage$($e$$) {
                $resolve$$($e$$.data);
                URL.revokeObjectURL($$jscomp$async$this$$.url);
              };
              $$jscomp$async$this$$.worker.onerror = function $$$jscomp$async$this$$$worker$onerror$($e$$) {
                $reject$$($e$$);
                URL.revokeObjectURL($$jscomp$async$this$$.url);
              };
              $$jscomp$async$this$$.worker.postMessage($data$$);
            }), done:!0};
          default:
            return {value:void 0, done:!0};
        }
      }
    }
    var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
      return $$jscomp$generator$impl$$($arg$$, void 0);
    }, throw:function($arg$$) {
      return $$jscomp$generator$impl$$(void 0, $arg$$);
    }, return:function($arg$$) {
      throw Error("Not yet implemented");
    }};
    $jscomp.initSymbolIterator();
    $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
      return this;
    };
    return $iterator$$;
  }());
};
$jscomp.global.Object.defineProperties(worker.prototype, {blob:{configurable:!0, enumerable:!0, get:function() {
  return this._blob;
}}, method:{configurable:!0, enumerable:!0, get:function() {
  return this._method;
}}, url:{configurable:!0, enumerable:!0, get:function() {
  return this._url;
}}, worker:{configurable:!0, enumerable:!0, get:function() {
  return this._worker;
}}});
hamonengine.math = hamonengine.math || {};
(function() {
  Math.PI2 = 6.283185307179586476925286766559;
  Math.PI3_2 = 3 * Math.PI / 2;
  Math.PI_2 = Math.PI / 2;
  Math.HalfPI = 1.5707963267948966192313216916398;
  Math.QuarterPI = 4.7123889803846898576939650749193;
  Math.maxInt32 = 2147483647;
  Math.maxUInt32 = 4294967296;
  Math.bitRound = function $Math$bitRound$($x$$) {
    return 0.5 + $x$$ << 0;
  };
  Math.truncate = function $Math$truncate$($x$$) {
    return $x$$ >= Math.maxInt32 ? Math.maxInt32 : ~~$x$$;
  };
  Math.sqr = function $Math$sqr$($x$$) {
    return $x$$ * $x$$;
  };
  Math.toDegrees = function $Math$toDegrees$($degrees$$) {
    return $degrees$$ * Math.PI / 180;
  };
  Math.toRadians = function $Math$toRadians$($radians$$) {
    return 180 * $radians$$ / Math.PI;
  };
})();
hamonengine.math = hamonengine.math || {};
(function() {
  hamonengine.math.sort = function $hamonengine$math$sort$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._compareFunc = $options$$.compareFunc ? $options$$.compareFunc : hamonengine.math.sort.sort.ascending;
  };
  hamonengine.math.sort.prototype.quickSort = function $hamonengine$math$sort$$quickSort$($arr$$) {
    hamonengine.math.sort.iquicksort(this._compareFunc, $arr$$, 0, $arr$$.length - 1);
  };
  hamonengine.math.sort.ascending = function $hamonengine$math$sort$ascending$($a$$, $b$$) {
    return $a$$ === $b$$ ? 0 : $a$$ < $b$$ ? -1 : 1;
  };
  hamonengine.math.sort.descending = function $hamonengine$math$sort$descending$($a$$, $b$$) {
    return $a$$ === $b$$ ? 0 : $a$$ < $b$$ ? 1 : -1;
  };
  hamonengine.math.sort.iquicksort = function $hamonengine$math$sort$iquicksort$($compareFunction$$, $arr$$, $left$$, $right$$) {
    for (var $i$$ = $left$$, $j$$ = $right$$, $pivot$$ = $arr$$[Math.truncate(($left$$ + $right$$) / 2)]; $i$$ <= $j$$;) {
      for (; 0 > $compareFunction$$($arr$$[$i$$], $pivot$$);) {
        $i$$++;
      }
      for (; 0 < $compareFunction$$($arr$$[$j$$], $pivot$$);) {
        $j$$--;
      }
      if ($i$$ <= $j$$) {
        var $tmp$$ = $arr$$[$i$$];
        $arr$$[$i$$] = $arr$$[$j$$];
        $arr$$[$j$$] = $tmp$$;
        $i$$++;
        $j$$--;
      }
    }
    $left$$ < $j$$ && hamonengine.math.sort.iquicksort($compareFunction$$, $arr$$, $left$$, $j$$);
    $i$$ < $right$$ && hamonengine.math.sort.iquicksort($compareFunction$$, $arr$$, $i$$, $right$$);
  };
})();
hamonengine.math = hamonengine.math || {};
(function() {
  var $m$$ = Math.maxUInt32;
  hamonengine.math.LCGRandom = function $hamonengine$math$LCGRandom$($seed$$) {
    this._seed = $seed$$;
  };
  hamonengine.math.LCGRandom.prototype.random = function $hamonengine$math$LCGRandom$$random$() {
    return this._seed = (214013 * this._seed + 2531011) % $m$$;
  };
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.album = function $hamonengine$audio$album$($options$$) {
    this._imageResource = new hamonengine.graphics.imageext;
    this._tracks = {};
    this._trackIndex = [];
  };
  hamonengine.audio.album.prototype.load = function $hamonengine$audio$album$$load$($albumMetadata$$) {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$jscomp$1_i$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              if ("string" !== typeof $albumMetadata$$) {
                $$jscomp$generator$state$$ = 1;
                break;
              }
              $$jscomp$generator$state$$ = 2;
              return {value:connect.get($albumMetadata$$), done:!1};
            case 2:
              if (void 0 === $$jscomp$generator$throw$arg$$) {
                $$jscomp$generator$state$$ = 3;
                break;
              }
              $$jscomp$generator$state$$ = -1;
              throw $$jscomp$generator$throw$arg$$;
            case 3:
              $albumMetadataResponse$0$$ = $$jscomp$generator$next$arg24$$ = $$jscomp$generator$next$arg$jscomp$1_i$$, $albumMetadata$$ = JSON.parse($albumMetadataResponse$0$$.data);
            case 1:
              $resourceLoadingPromise$$ = $$jscomp$async$this$$._imageResource.load(albumMetadataResponse.albumUrl);
              for ($$jscomp$generator$next$arg$jscomp$1_i$$ = 0; $$jscomp$generator$next$arg$jscomp$1_i$$ < $albumMetadata$$.tracks.length; $$jscomp$generator$next$arg$jscomp$1_i$$++) {
                $$jscomp$generator$throw$arg$$ = $albumMetadata$$.tracks[$$jscomp$generator$next$arg$jscomp$1_i$$], $$jscomp$async$this$$._trackIndex.push($$jscomp$generator$throw$arg$$.name), $$jscomp$async$this$$._tracks[$$jscomp$generator$throw$arg$$.name] = new hamonengine.graphics.album({track:$$jscomp$async$this$$._imageResource, name:$$jscomp$generator$throw$arg$$.name});
              }
              $$jscomp$generator$state$$ = -1;
              return {value:$resourceLoadingPromise$$, done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $resourceLoadingPromise$$, $albumMetadataResponse$0$$, $$jscomp$generator$next$arg24$$, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.album.prototype.getTrack = function $hamonengine$audio$album$$getTrack$($name$$) {
    return this._tracks[$name$$].clone();
  };
  hamonengine.audio.album.prototype.getTrackByOrdinal = function $hamonengine$audio$album$$getTrackByOrdinal$($index$$) {
    return this._tracks[this._trackIndex[$index$$]].clone();
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.album.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return this._tracks.length;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._imageResource.isLoaded();
  }}});
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.playlist = function $hamonengine$audio$playlist$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.audio.playlist && ($options$$ = {tracks:$options$$._tracks && $options$$._tracks.clone()});
    this._name = $options$$.name;
    this._tracks = $options$$.tracks || [];
    this._state = this._trackURLIndex = 0;
    this._audioCtx = new AudioContext;
    this._gainNode = this._audioCtx.createGain();
    this._panNode = new StereoPannerNode(this._audioCtx, {pan:0});
    hamonengine.util.logger.debug("[hamonengine.audio.playlist.constructor] Name: " + this._name);
    hamonengine.util.logger.debug("[hamonengine.audio.playlist.constructor] Track Begin: " + this._trackBegin);
    hamonengine.util.logger.debug("[hamonengine.audio.playlist.constructor] Track End: {" + this._trackEnd + "}");
  };
  hamonengine.audio.playlist.prototype.clone = function $hamonengine$audio$playlist$$clone$() {
    return new hamonengine.audio.track(this);
  };
  hamonengine.audio.playlist.prototype.load = function $hamonengine$audio$playlist$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return "" !== $src$$ && ($$jscomp$async$this$$.audio.src = $src$$, $$jscomp$async$this$$.audio.load()), $$jscomp$async$this$$._state = 1, $$jscomp$generator$state$$ = -1, {value:new Promise(function($resolve$$, $reject$$) {
                0 === $$jscomp$async$this$$.audio.readyState ? ($$jscomp$async$this$$.audio.addEventListener("loadeddata", function() {
                  $$jscomp$async$this$$._state = 2;
                  $$jscomp$async$this$$._track.connect($$jscomp$async$this$$._audioCtx.destination);
                  $$jscomp$async$this$$.audio.currentTime = $$jscomp$async$this$$._trackBegin;
                  $$jscomp$async$this$$._trackEnd || ($$jscomp$async$this$$._trackEnd = $$jscomp$async$this$$.duration + $$jscomp$async$this$$._trackBegin);
                  hamonengine.util.logger.debug("[hamonengine.audio.track.load] Audio '" + $src$$ + "' has loaded successfully.");
                  $resolve$$();
                }, !1), $$jscomp$async$this$$.audio.addEventListener("error", function($error$$) {
                  $$jscomp$async$this$$._state = 3;
                  $reject$$("The audio '" + ($error$$ && $error$$.path && 0 < $error$$.path.length && $error$$.path[0].src || "") + "' could not be loaded.");
                }, !1)) : ($$jscomp$async$this$$._state = 2, $$jscomp$async$this$$._track.connect($$jscomp$async$this$$._audioCtx.destination), $$jscomp$async$this$$.audio.currentTime = $$jscomp$async$this$$._trackBegin, $resolve$$());
              }), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.playlist.prototype.play = function $hamonengine$audio$playlist$$play$() {
    "suspended" === this._audioCtx.state && this._audioCtx.resume();
    this.audio.play();
  };
  hamonengine.audio.playlist.prototype.pause = function $hamonengine$audio$playlist$$pause$() {
    this.audio.pause();
  };
  hamonengine.audio.playlist.prototype.stop = function $hamonengine$audio$playlist$$stop$() {
    this.audio.pause();
    this.audio.currentTime = this._trackBegin;
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.playlist.prototype, {src:{configurable:!0, enumerable:!0, get:function() {
    return this._audio.src;
  }}, name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }, set:function($v$$) {
    this._name = $v$$;
  }}, context:{configurable:!0, enumerable:!0, get:function() {
    return this._audioCtx;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return 2 === this._state;
  }}, audio:{configurable:!0, enumerable:!0, get:function() {
    return this._audio;
  }}, duration:{configurable:!0, enumerable:!0, get:function() {
    return this._trackEnd - this._trackBegin;
  }}, fallbackSourceURLs:{configurable:!0, enumerable:!0, get:function() {
    return this._fallbackSourceURLs;
  }}, autoplay:{configurable:!0, enumerable:!0, get:function() {
    return this._audio.autoplay;
  }, set:function($v$$) {
    this._audio.autoplay = $v$$;
  }}, loop:{configurable:!0, enumerable:!0, get:function() {
    return this._audio.loop;
  }, set:function($v$$) {
    this._audio.loop = $v$$;
  }}, muted:{configurable:!0, enumerable:!0, get:function() {
    return this._audio.muted;
  }, set:function($v$$) {
    this._audio.muted = $v$$;
  }}, volume:{configurable:!0, enumerable:!0, get:function() {
    return this._gainNode.gain.value;
  }, set:function($v$$) {
    this._gainNode.gain.value = $v$$;
  }}});
})();
hamonengine.audio = hamonengine.audio || {};
(function() {
  hamonengine.audio.track = function $hamonengine$audio$track$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.audio.track && ($options$$ = {audio:$options$$._audio && $options$$._audio.clone()});
    this._name = $options$$.name;
    this._audio = $options$$.audio || new Audio;
    this._trackBegin = $options$$.trackBegin || 0;
    this._trackEnd = $options$$.trackEnd;
    this._fallbackSourceURLs = [];
    $options$$ = this._audio.children;
    if (0 < $options$$.length) {
      for (var $i$$ = 0; $i$$ < $options$$.length; $i$$++) {
        this._fallbackSourceURLs.push($options$$[$i$$].src);
      }
    }
    this._state = 0;
    this._audioCtx = new AudioContext;
    this._gainNode = this._audioCtx.createGain();
    this._panNode = new StereoPannerNode(this._audioCtx, {pan:0});
    this._mediaSource = this._audioCtx.createMediaElementSource(this._audio);
    this._mediaSource.connect(this._gainNode).connect(this._panNode);
    hamonengine.util.logger.debug("[hamonengine.audio.track.constructor] Name: " + this._name);
    hamonengine.util.logger.debug("[hamonengine.audio.track.constructor] Track Begin: " + this._trackBegin);
    hamonengine.util.logger.debug("[hamonengine.audio.track.constructor] Track End: {" + this._trackEnd + "}");
  };
  hamonengine.audio.track.prototype.clone = function $hamonengine$audio$track$$clone$() {
    return new hamonengine.audio.track(this);
  };
  hamonengine.audio.track.prototype.load = function $hamonengine$audio$track$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return "" !== $src$$ && ($$jscomp$async$this$$.audio.src = $src$$, $$jscomp$async$this$$.audio.load()), $$jscomp$async$this$$._state = 1, $$jscomp$generator$state$$ = -1, {value:new Promise(function($resolve$$, $reject$$) {
                0 === $$jscomp$async$this$$.audio.readyState ? ($$jscomp$async$this$$.audio.addEventListener("loadeddata", function() {
                  $$jscomp$async$this$$._state = 2;
                  $$jscomp$async$this$$._mediaSource.connect($$jscomp$async$this$$._audioCtx.destination);
                  $$jscomp$async$this$$.audio.currentTime = $$jscomp$async$this$$._trackBegin;
                  $$jscomp$async$this$$._trackEnd || ($$jscomp$async$this$$._trackEnd = $$jscomp$async$this$$.audio.duration);
                  hamonengine.util.logger.debug("[hamonengine.audio.track.load] Audio '" + $src$$ + "' has loaded successfully.");
                  $resolve$$();
                }, !1), $$jscomp$async$this$$.audio.addEventListener("error", function($error$$) {
                  $$jscomp$async$this$$._state = 3;
                  $reject$$("The audio '" + ($error$$ && $error$$.path && 0 < $error$$.path.length && $error$$.path[0].src || "") + "' could not be loaded.");
                }, !1), $$jscomp$async$this$$._trackEnd !== $$jscomp$async$this$$.audio.duration && $$jscomp$async$this$$.audio.addEventListener("timeupdate", function($e$$) {
                  $$jscomp$async$this$$.audio.currentTime >= $$jscomp$async$this$$._trackEnd && ($$jscomp$async$this$$.pause(), $e$$.preventDefault());
                }, !1)) : ($$jscomp$async$this$$._state = 2, $$jscomp$async$this$$._mediaSource.connect($$jscomp$async$this$$._audioCtx.destination), $$jscomp$async$this$$.audio.currentTime = $$jscomp$async$this$$._trackBegin, $resolve$$());
              }), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.audio.track.prototype.play = function $hamonengine$audio$track$$play$() {
    "suspended" === this._audioCtx.state && this._audioCtx.resume();
    return this.audio.play();
  };
  hamonengine.audio.track.prototype.pause = function $hamonengine$audio$track$$pause$() {
    this.audio.pause();
  };
  hamonengine.audio.track.prototype.stop = function $hamonengine$audio$track$$stop$() {
    this.audio.pause();
    this.audio.currentTime = this._trackBegin;
  };
  $jscomp.global.Object.defineProperties(hamonengine.audio.track.prototype, {src:{configurable:!0, enumerable:!0, get:function() {
    return this._audio.currentSrc;
  }}, name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }, set:function($v$$) {
    this._name = $v$$;
  }}, context:{configurable:!0, enumerable:!0, get:function() {
    return this._audioCtx;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return 2 === this._state;
  }}, audio:{configurable:!0, enumerable:!0, get:function() {
    return this._audio;
  }}, duration:{configurable:!0, enumerable:!0, get:function() {
    return (this._trackEnd || 0) - this._trackBegin;
  }}, fallbackSourceURLs:{configurable:!0, enumerable:!0, get:function() {
    return this._fallbackSourceURLs;
  }}, autoplay:{configurable:!0, enumerable:!0, get:function() {
    return this._audio.autoplay;
  }, set:function($v$$) {
    this._audio.autoplay = $v$$;
  }}, loop:{configurable:!0, enumerable:!0, get:function() {
    return this._audio.loop;
  }, set:function($v$$) {
    this._audio.loop = $v$$;
  }}, muted:{configurable:!0, enumerable:!0, get:function() {
    return this._audio.muted;
  }, set:function($v$$) {
    this._audio.muted = $v$$;
  }}, volume:{configurable:!0, enumerable:!0, get:function() {
    return this._gainNode.gain.value;
  }, set:function($v$$) {
    this._gainNode.gain.value = $v$$;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.line = function $hamonengine$geometry$line$($min$$, $max$$) {
    this.min = void 0 === $min$$ ? 0.0 : $min$$;
    this.max = void 0 === $max$$ ? 0.0 : $max$$;
  };
  hamonengine.geometry.line.clone = function $hamonengine$geometry$line$clone$($line$$) {
    return new hamonengine.geometry.line($line$$.min, $line$$.max);
  };
  hamonengine.geometry.line.prototype.clone = function $hamonengine$geometry$line$$clone$() {
    return hamonengine.geometry.line.clone(this);
  };
  hamonengine.geometry.line.prototype.toString = function $hamonengine$geometry$line$$toString$() {
    return "{min: '" + this.min + "', max: '" + this.max + "'}";
  };
  hamonengine.geometry.line.prototype.mirror = function $hamonengine$geometry$line$$mirror$() {
    return new hamonengine.geometry.line(this.max, this.min);
  };
  hamonengine.geometry.line.prototype.add = function $hamonengine$geometry$line$$add$($l$$) {
    return new hamonengine.geometry.line(this.min + $l$$.min, this.max + $l$$.max);
  };
  hamonengine.geometry.line.prototype.subtract = function $hamonengine$geometry$line$$subtract$($l$$) {
    return new hamonengine.geometry.line(this.min - $l$$.min, this.max - $l$$.max);
  };
  hamonengine.geometry.line.prototype.multiplyScalar = function $hamonengine$geometry$line$$multiplyScalar$($s$$) {
    return new hamonengine.geometry.line(this.min * $s$$, this.max * $s$$);
  };
  hamonengine.geometry.line.prototype.overlap = function $hamonengine$geometry$line$$overlap$($l$$) {
    var $isPointOnLine$$ = function $$isPointOnLine$$$($point$$, $line$$) {
      return $point$$ >= $line$$.min && $point$$ <= $line$$.max;
    }, $min$$ = NaN;
    $isPointOnLine$$(this.min, $l$$) ? $min$$ = this.min : $isPointOnLine$$($l$$.min, this) && ($min$$ = $l$$.min);
    var $max$$ = NaN;
    $isPointOnLine$$(this.max, $l$$) ? $max$$ = this.max : $isPointOnLine$$($l$$.max, this) && ($max$$ = $l$$.max);
    return new hamonengine.geometry.line($min$$, $max$$);
  };
  hamonengine.geometry.line.prototype.contains = function $hamonengine$geometry$line$$contains$($l$$) {
    return $l$$.min >= this.min && $l$$.max <= this.max;
  };
  hamonengine.geometry.line.prototype.getOrientation = function $hamonengine$geometry$line$$getOrientation$($l$$) {
    var $tMidPoint$$ = this.midPoint;
    $l$$ = $l$$.midPoint;
    return $l$$ === $tMidPoint$$ ? 0 : $l$$ < $tMidPoint$$ ? -1 : 1;
  };
  hamonengine.geometry.line.prototype.getDistance = function $hamonengine$geometry$line$$getDistance$($l$$) {
    return Math.abs(this.midPoint - $l$$.midPoint);
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.line.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.abs(this.max - this.min);
  }}, isLine:{configurable:!0, enumerable:!0, get:function() {
    return !isNaN(this.min) && !isNaN(this.max);
  }}, midPoint:{configurable:!0, enumerable:!0, get:function() {
    return (this.max - this.min) / 2;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.polygon = function $hamonengine$geometry$polygon$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.geometry.polygon && ($options$$ = {vertices:$options$$.vertices});
    this._vertices = $options$$.vertices || [];
    this._edges = [];
    this._normals = [];
    this._dimensions = {center:null, max:null, min:null, minVertex:null, maxVertex:null};
    this._dirty = 15;
    this._shapeType = SHAPE_TYPE.UNKNOWN;
  };
  hamonengine.geometry.polygon.prototype.clone = function $hamonengine$geometry$polygon$$clone$() {
    return new hamonengine.geometry.polygon(this);
  };
  hamonengine.geometry.polygon.prototype.toString = function $hamonengine$geometry$polygon$$toString$() {
    for (var $vertexString$$ = "", $i$$ = 0; $i$$ < this._vertices.length; $i$$++) {
      $vertexString$$ += "" + ("" !== $vertexString$$ ? "," : "") + this._vertices[$i$$].toString();
    }
    return "[" + $vertexString$$ + "]";
  };
  hamonengine.geometry.polygon.prototype.toRect = function $hamonengine$geometry$polygon$$toRect$() {
    return new hamonengine.geometry.rect(this.min.x, this.min.y, this.max.x - this.min.x, this.max.y - this.min.y);
  };
  hamonengine.geometry.polygon.prototype.addVertex = function $hamonengine$geometry$polygon$$addVertex$($x$$, $y$$) {
    this._vertices.push(new hamonengine.geometry.vector2($x$$, $y$$));
    this._dirty = 15;
  };
  hamonengine.geometry.polygon.prototype.translate = function $hamonengine$geometry$polygon$$translate$($translateVector$$) {
    $translateVector$$ = $translateVector$$ || new hamonengine.geometry.vector2(0, 0);
    for (var $newVertices$$ = [], $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      $newVertices$$.push(this.vertices[$i$$].add($translateVector$$));
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.rotate = function $hamonengine$geometry$polygon$$rotate$($cosTheta_theta$$, $offsetVector$$) {
    var $sinTheta$$ = Math.sin($cosTheta_theta$$);
    $cosTheta_theta$$ = Math.cos($cosTheta_theta$$);
    $offsetVector$$ = $offsetVector$$ || new hamonengine.geometry.vector2(0, 0);
    for (var $newVertices$$ = [], $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      var $xOffset_y$$ = this.vertices[$i$$].x - $offsetVector$$.x, $yOffset$$ = this.vertices[$i$$].y - $offsetVector$$.y;
      if (hamonengine.geometry.settings.coordinateSystem === COORDINATE_SYSTEM.RHS) {
        var $x$$ = $xOffset_y$$ * $cosTheta_theta$$ - $yOffset$$ * $sinTheta$$;
        $xOffset_y$$ = $xOffset_y$$ * $sinTheta$$ + $yOffset$$ * $cosTheta_theta$$;
      } else {
        $x$$ = $xOffset_y$$ * $cosTheta_theta$$ + $yOffset$$ * $sinTheta$$, $xOffset_y$$ = -($xOffset_y$$ * $sinTheta$$) + $yOffset$$ * $cosTheta_theta$$;
      }
      $newVertices$$.push(new hamonengine.geometry.vector2($x$$ + $offsetVector$$.x, $xOffset_y$$ + $offsetVector$$.y));
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.rotateAtCenter = function $hamonengine$geometry$polygon$$rotateAtCenter$($theta$$) {
    return this.rotate($theta$$, this.center);
  };
  hamonengine.geometry.polygon.prototype.scale = function $hamonengine$geometry$polygon$$scale$($scaleVector$$) {
    $scaleVector$$ = $scaleVector$$ || new hamonengine.geometry.vector2(0, 0);
    for (var $newVertices$$ = [], $i$$ = 0; $i$$ < this.vertices.length; $i$$++) {
      $newVertices$$.push(this.vertices[$i$$].multiplyVector($scaleVector$$));
    }
    return new hamonengine.geometry.polygon({vertices:$newVertices$$});
  };
  hamonengine.geometry.polygon.prototype.isCollision = function $hamonengine$geometry$polygon$$isCollision$($shape$$) {
    return $shape$$ instanceof hamonengine.geometry.rect ? this.isCollisionRect($shape$$) : $shape$$ instanceof hamonengine.geometry.polygon ? this.isCollisionPolygon($shape$$) : new hamonengine.geometry.vector2(0, 0);
  };
  hamonengine.geometry.polygon.prototype.isCollisionPolygon = function $hamonengine$geometry$polygon$$isCollisionPolygon$($polygon$$) {
    if (!($polygon$$ instanceof hamonengine.geometry.polygon)) {
      throw "Parameter polygon is not of type hamonengine.geometry.polygon.";
    }
    for (var $mnimumOverlappingLength$$ = NaN, $mtvAxis$$, $axes$$ = $polygon$$.normals, $i$1_i$$ = 0; $i$1_i$$ < $axes$$.length; $i$1_i$$++) {
      var $thisProjection_thisProjection$2$$ = this.project($axes$$[$i$1_i$$]), $otherProjection_otherProjection$3$$ = $polygon$$.project($axes$$[$i$1_i$$]), $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$ = $thisProjection_thisProjection$2$$.overlap($otherProjection_otherProjection$3$$);
      if (!$overlapping_overlapping$4_overlappingLength_overlappingLength$5$$.isLine) {
        return new hamonengine.geometry.vector2;
      }
      $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$ = $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$.length;
      if ($thisProjection_thisProjection$2$$.contains($otherProjection_otherProjection$3$$) || $otherProjection_otherProjection$3$$.contains($thisProjection_thisProjection$2$$)) {
        var $min$6_min$$ = Math.abs($thisProjection_thisProjection$2$$.min - $otherProjection_otherProjection$3$$.min), $max$7_max$$ = Math.abs($thisProjection_thisProjection$2$$.max - $otherProjection_otherProjection$3$$.max);
        $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$ += $min$6_min$$ < $max$7_max$$ ? $min$6_min$$ : $max$7_max$$;
      }
      if (isNaN($mnimumOverlappingLength$$) || $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$ < $mnimumOverlappingLength$$) {
        $mnimumOverlappingLength$$ = $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$, $mtvAxis$$ = $axes$$[$i$1_i$$], $otherProjection_otherProjection$3$$.getOrientation($thisProjection_thisProjection$2$$);
      }
    }
    $axes$$ = this.normals;
    for ($i$1_i$$ = 0; $i$1_i$$ < $axes$$.length; $i$1_i$$++) {
      $thisProjection_thisProjection$2$$ = this.project($axes$$[$i$1_i$$]);
      $otherProjection_otherProjection$3$$ = $polygon$$.project($axes$$[$i$1_i$$]);
      $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$ = $thisProjection_thisProjection$2$$.overlap($otherProjection_otherProjection$3$$);
      if (!$overlapping_overlapping$4_overlappingLength_overlappingLength$5$$.isLine) {
        return new hamonengine.geometry.vector2;
      }
      $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$ = $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$.length;
      if ($thisProjection_thisProjection$2$$.contains($otherProjection_otherProjection$3$$) || $otherProjection_otherProjection$3$$.contains($thisProjection_thisProjection$2$$)) {
        $min$6_min$$ = Math.abs($thisProjection_thisProjection$2$$.min - $otherProjection_otherProjection$3$$.min), $max$7_max$$ = Math.abs($thisProjection_thisProjection$2$$.max - $otherProjection_otherProjection$3$$.max), $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$ += $min$6_min$$ < $max$7_max$$ ? $min$6_min$$ : $max$7_max$$;
      }
      if (isNaN($mnimumOverlappingLength$$) || $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$ < $mnimumOverlappingLength$$) {
        $mnimumOverlappingLength$$ = $overlapping_overlapping$4_overlappingLength_overlappingLength$5$$, $mtvAxis$$ = $axes$$[$i$1_i$$], $otherProjection_otherProjection$3$$.getOrientation($thisProjection_thisProjection$2$$);
      }
    }
    $mnimumOverlappingLength$$ = $mnimumOverlappingLength$$ < hamonengine.geometry.settings.collisionDetection.floor ? 0.0 : $mnimumOverlappingLength$$;
    return $mtvAxis$$.multiply($mnimumOverlappingLength$$);
  };
  hamonengine.geometry.polygon.prototype.isCollisionRect = function $hamonengine$geometry$polygon$$isCollisionRect$($rect$$) {
    return $rect$$.toPolygon().isCollisionPolygon(this);
  };
  hamonengine.geometry.polygon.prototype.isContained = function $hamonengine$geometry$polygon$$isContained$($shape$$) {
    return new hamonengine.geometry.vector2;
  };
  hamonengine.geometry.polygon.prototype.project = function $hamonengine$geometry$polygon$$project$($vector$$) {
    var $min$$ = 0, $max$$ = 0;
    if (0 < this.vertices.length) {
      $max$$ = $min$$ = $vector$$.dot(this.vertices[0]);
      for (var $i$$ = 1; $i$$ < this.vertices.length; $i$$++) {
        var $projection$$ = $vector$$.dot(this.vertices[$i$$]);
        $projection$$ < $min$$ ? $min$$ = $projection$$ : $projection$$ > $max$$ && ($max$$ = $projection$$);
      }
    }
    return new hamonengine.geometry.line($min$$, $max$$);
  };
  hamonengine.geometry.polygon.calcEdges = function $hamonengine$geometry$polygon$calcEdges$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $edges$$ = [], $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      $edges$$.push($vertices$$[($i$$ + 1) % $vertices$$.length].subtract($vertices$$[$i$$]));
    }
    return $edges$$;
  };
  hamonengine.geometry.polygon.calcNormals = function $hamonengine$geometry$polygon$calcNormals$($edges$$) {
    $edges$$ = void 0 === $edges$$ ? [] : $edges$$;
    return $edges$$.map(function($edge$$) {
      return $edge$$.normal(ROTATION_TYPE.CW);
    });
  };
  hamonengine.geometry.polygon.calcDimensions = function $hamonengine$geometry$polygon$calcDimensions$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $minVertex$$ = null, $maxVertex$$ = null, $xMax$$ = NaN, $xMin$$ = NaN, $yMax$$ = NaN, $yMin$$ = NaN, $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      $xMax$$ = $xMax$$ > $vertices$$[$i$$].x ? $xMax$$ : $vertices$$[$i$$].x;
      $xMin$$ = $xMin$$ < $vertices$$[$i$$].x ? $xMin$$ : $vertices$$[$i$$].x;
      $yMax$$ = $yMax$$ > $vertices$$[$i$$].y ? $yMax$$ : $vertices$$[$i$$].y;
      $yMin$$ = $yMin$$ < $vertices$$[$i$$].y ? $yMin$$ : $vertices$$[$i$$].y;
      if (null === $minVertex$$ || $minVertex$$.x > $vertices$$[$i$$].x && $minVertex$$.y > $vertices$$[$i$$].y) {
        $minVertex$$ = $vertices$$[$i$$];
      }
      if (null === $maxVertex$$ || $maxVertex$$.x < $vertices$$[$i$$].x && $maxVertex$$.y < $vertices$$[$i$$].y) {
        $maxVertex$$ = $vertices$$[$i$$];
      }
    }
    return {max:new hamonengine.geometry.vector2($xMax$$, $yMax$$), min:new hamonengine.geometry.vector2($xMin$$, $yMin$$), center:new hamonengine.geometry.vector2($xMin$$ + ($xMax$$ - $xMin$$) / 2, $yMin$$ + ($yMax$$ - $yMin$$) / 2), minVertex:$minVertex$$, maxVertex:$maxVertex$$};
  };
  hamonengine.geometry.polygon.calcShapeType = function $hamonengine$geometry$polygon$calcShapeType$($vertices$$) {
    $vertices$$ = void 0 === $vertices$$ ? [] : $vertices$$;
    for (var $signCounter$$ = 0, $i$$ = 0; $i$$ < $vertices$$.length; $i$$++) {
      var $p2_v2$$ = $vertices$$[($i$$ + 1) % $vertices$$.length], $p3$$ = $vertices$$[($i$$ + 2) % $vertices$$.length], $v1$$ = $p2_v2$$.subtract($vertices$$[$i$$]);
      $p2_v2$$ = $p3$$.subtract($p2_v2$$);
      $signCounter$$ += 0 < $p2_v2$$.cross($v1$$).z ? 1 : -1;
    }
    return $vertices$$.length === $signCounter$$ ? SHAPE_TYPE.CONVEX : SHAPE_TYPE.CONCAVE;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.polygon.prototype, {vertices:{configurable:!0, enumerable:!0, get:function() {
    return this._vertices;
  }}, edges:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 2) && (this._edges = hamonengine.geometry.polygon.calcEdges(this.vertices), bitflag.toggle(this._dirty, 2, !1));
    return this._edges;
  }}, normals:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 0) && (this._normals = hamonengine.geometry.polygon.calcNormals(this.edges), bitflag.toggle(this._dirty, 0, !1));
    return this._normals;
  }}, center:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), bitflag.toggle(this._dirty, 1, !1));
    return this._dimensions.center;
  }}, max:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), bitflag.toggle(this._dirty, 1, !1));
    return this._dimensions.max;
  }}, min:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), bitflag.toggle(this._dirty, 1, !1));
    return this._dimensions.min;
  }}, minVertex:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), bitflag.toggle(this._dirty, 1, !1));
    return this._dimensions.minVertex;
  }}, maxVertex:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 1) && (this._dimensions = hamonengine.geometry.polygon.calcDimensions(this.vertices), bitflag.toggle(this._dirty, 1, !1));
    return this._dimensions.maxVertex;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this.max.x - this.min.x;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this.max.y - this.min.y;
  }}, shapeType:{configurable:!0, enumerable:!0, get:function() {
    bitflag.isSet(this._dirty, 3) && (this._shapeType = hamonengine.geometry.polygon.calcShapeType(this.vertices), bitflag.toggle(this._dirty, 3, !1));
    return this._shapeType;
  }}});
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.rect = function $hamonengine$geometry$rect$($x$$, $y$$, $width$$, $height$$) {
    this.x = void 0 === $x$$ ? 0 : $x$$;
    this.y = void 0 === $y$$ ? 0 : $y$$;
    this.width = void 0 === $width$$ ? 0 : $width$$;
    this.height = void 0 === $height$$ ? 0 : $height$$;
  };
  hamonengine.geometry.rect.prototype.clone = function $hamonengine$geometry$rect$$clone$() {
    return new hamonengine.geometry.rect(this.x, this.y, this.width, this.height);
  };
  hamonengine.geometry.rect.prototype.toString = function $hamonengine$geometry$rect$$toString$() {
    return "{x: " + this.x + ", y: " + this.y + ", width: " + this.width + ", height: " + this.height + "}";
  };
  hamonengine.geometry.rect.prototype.toPolygon = function $hamonengine$geometry$rect$$toPolygon$() {
    return new hamonengine.geometry.polygon({vertices:[new hamonengine.geometry.vector2(this.x, this.y), new hamonengine.geometry.vector2(this.x + this.width, this.y), new hamonengine.geometry.vector2(this.x + this.width, this.y + this.height), new hamonengine.geometry.vector2(this.x, this.y + this.height)]});
  };
  hamonengine.geometry.rect.prototype.translate = function $hamonengine$geometry$rect$$translate$($translateVector$$) {
    $translateVector$$ = $translateVector$$ || new hamonengine.geometry.vector2(0, 0);
    return new hamonengine.geometry.rect(this.x + $translateVector$$.x, this.y + $translateVector$$.y, this.width, this.height);
  };
  hamonengine.geometry.rect.prototype.isCollision = function $hamonengine$geometry$rect$$isCollision$($shape$$) {
    return $shape$$ instanceof hamonengine.geometry.rect ? this.isCollisionRect($shape$$) : $shape$$ instanceof hamonengine.geometry.polygon ? this.isCollisionPolygon($shape$$) : $shape$$ instanceof hamonengine.geometry.vector2 ? this.isCollisionPoint($shape$$) : new hamonengine.geometry.vector2(0, 0);
  };
  hamonengine.geometry.rect.prototype.isCollisionRect = function $hamonengine$geometry$rect$$isCollisionRect$($max$9_otherRect_other_XAxisProjection$$) {
    $max$9_otherRect_other_XAxisProjection$$ instanceof hamonengine.geometry.rect || hamonengine.util.logger.warning("[hamonengine.geometry.rect.isCollision] The otherRect parameter is not of type hamonengine.geometry.rect!");
    var $mnimumOverlappingLength$$ = NaN, $max$$ = new hamonengine.geometry.line(this.y, this.y + this.height), $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ = new hamonengine.geometry.line($max$9_otherRect_other_XAxisProjection$$.y, $max$9_otherRect_other_XAxisProjection$$.y + $max$9_otherRect_other_XAxisProjection$$.height), $min$8_overlappingYAxis_overlappingYAxisLength$$ = $max$$.overlap($other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$);
    if (!$min$8_overlappingYAxis_overlappingYAxisLength$$.isLine) {
      return new hamonengine.geometry.vector2;
    }
    $min$8_overlappingYAxis_overlappingYAxisLength$$ = $min$8_overlappingYAxis_overlappingYAxisLength$$.length;
    if ($max$$.contains($other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$) || $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.contains($max$$)) {
      var $min$$ = Math.abs($max$$.min - $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.min);
      $max$$ = Math.abs($max$$.max - $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.max);
      $min$8_overlappingYAxis_overlappingYAxisLength$$ += $min$$ < $max$$ ? $min$$ : $max$$;
    }
    if (isNaN($mnimumOverlappingLength$$) || $min$8_overlappingYAxis_overlappingYAxisLength$$ < $mnimumOverlappingLength$$) {
      $mnimumOverlappingLength$$ = $min$8_overlappingYAxis_overlappingYAxisLength$$;
      var $mtvAxis$$ = hamonengine.geometry.vector2.Y_AXIS_NORMAL;
    }
    $max$$ = new hamonengine.geometry.line(this.x, this.x + this.width);
    $max$9_otherRect_other_XAxisProjection$$ = new hamonengine.geometry.line($max$9_otherRect_other_XAxisProjection$$.x, $max$9_otherRect_other_XAxisProjection$$.x + $max$9_otherRect_other_XAxisProjection$$.width);
    $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ = $max$$.overlap($max$9_otherRect_other_XAxisProjection$$);
    if (!$other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.isLine) {
      return new hamonengine.geometry.vector2;
    }
    $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ = $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$.length;
    if ($max$$.contains($max$9_otherRect_other_XAxisProjection$$) || $max$9_otherRect_other_XAxisProjection$$.contains($max$$)) {
      $min$8_overlappingYAxis_overlappingYAxisLength$$ = Math.abs($max$$.min - $max$9_otherRect_other_XAxisProjection$$.min), $max$9_otherRect_other_XAxisProjection$$ = Math.abs($max$$.max - $max$9_otherRect_other_XAxisProjection$$.max), $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ += $min$8_overlappingYAxis_overlappingYAxisLength$$ < $max$9_otherRect_other_XAxisProjection$$ ? $min$8_overlappingYAxis_overlappingYAxisLength$$ : $max$9_otherRect_other_XAxisProjection$$;
    }
    if (isNaN($mnimumOverlappingLength$$) || $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$ < $mnimumOverlappingLength$$) {
      $mnimumOverlappingLength$$ = $other_YAxisProjection_overlappingXAxis_overlappingXAxisLength$$, $mtvAxis$$ = hamonengine.geometry.vector2.X_AXIS_NORMAL;
    }
    $mnimumOverlappingLength$$ = $mnimumOverlappingLength$$ < hamonengine.geometry.settings.collisionDetection.floor ? 0.0 : $mnimumOverlappingLength$$;
    return $mtvAxis$$.multiply($mnimumOverlappingLength$$);
  };
  hamonengine.geometry.rect.prototype.isCollisionPolygon = function $hamonengine$geometry$rect$$isCollisionPolygon$($polygon$$) {
    return $polygon$$.isCollision(this.toPolygon());
  };
  hamonengine.geometry.rect.prototype.isCollisionPoint = function $hamonengine$geometry$rect$$isCollisionPoint$($minY2_point$$) {
    var $outsideDirection$$ = new hamonengine.geometry.vector2;
    if ($minY2_point$$.x >= this.x && $minY2_point$$.x <= this.right && $minY2_point$$.y >= this.y && $minY2_point$$.y <= this.bottom) {
      var $minX_minY$$ = $minY2_point$$.x - this.x, $minX2$$ = this.right - $minY2_point$$.x;
      $outsideDirection$$.x = $minX_minY$$ < $minX2$$ ? $minX_minY$$ : $minX2$$;
      $minX_minY$$ = $minY2_point$$.y - this.y;
      $minY2_point$$ = this.bottom - $minY2_point$$.y;
      $outsideDirection$$.y = $minX_minY$$ < $minY2_point$$ ? $minX_minY$$ : $minY2_point$$;
    }
    return $outsideDirection$$;
  };
  hamonengine.geometry.rect.prototype.isContained = function $hamonengine$geometry$rect$$isContained$($position$$, $rect$$) {
    $rect$$ instanceof hamonengine.geometry.rect || hamonengine.util.logger.warning("[hamonengine.geometry.rect.isContained] The rect parameter is not of type hamonengine.geometry.rect!");
    var $outsideDirection$$ = new hamonengine.geometry.vector2, $xOffset$$ = $position$$.x + $rect$$.x, $yOffset$$ = $position$$.y + $rect$$.y;
    $xOffset$$ < this.x ? (hamonengine.util.logger.debug("[hamonengine.geometry.rect.isContained] Outside -x: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.x = -1) : $position$$.x + $rect$$.right > this.right && (hamonengine.util.logger.debug("[hamonengine.geometry.rect.isContained] Outside +x: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.x = 1);
    $yOffset$$ < this.y ? (hamonengine.util.logger.debug("[hamonengine.geometry.rect.isContained] Outside -y: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.y = -1) : $position$$.y + $rect$$.bottom > this.bottom && (hamonengine.util.logger.debug("[hamonengine.geometry.rect.isContained] Outside +y: (" + $xOffset$$ + ", " + $yOffset$$ + ")"), $outsideDirection$$.y = 1);
    return $outsideDirection$$;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.rect.prototype, {right:{configurable:!0, enumerable:!0, get:function() {
    return this.x + this.width;
  }}, bottom:{configurable:!0, enumerable:!0, get:function() {
    return this.y + this.height;
  }}});
})();
var COORDINATE_SYSTEM = {LHS:0, RHS:1}, COLLISION_TYPES = {NONE:0, EDGE:1, INSIDE:2}, SHAPE_TYPE = {UNKNOWN:0, CONVEX:1, CONCAVE:2}, ROTATION_TYPE = {CW:0, CCW:1};
hamonengine.geometry = hamonengine.geometry || {};
hamonengine.geometry.settings = hamonengine.geometry.settings || {collisionDetection:{floor:0.01, limit:15}, coordinateSystem:COORDINATE_SYSTEM.RHS};
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.vector2 = function $hamonengine$geometry$vector2$($x$$, $y$$) {
    this.x = void 0 === $x$$ ? 0.0 : $x$$;
    this.y = void 0 === $y$$ ? 0.0 : $y$$;
  };
  hamonengine.geometry.vector2.clone = function $hamonengine$geometry$vector2$clone$($vector$$) {
    return new hamonengine.geometry.vector2($vector$$.x, $vector$$.y);
  };
  hamonengine.geometry.vector2.prototype.clone = function $hamonengine$geometry$vector2$$clone$() {
    return hamonengine.geometry.vector2.clone(this);
  };
  hamonengine.geometry.vector2.prototype.toString = function $hamonengine$geometry$vector2$$toString$() {
    return "{x: '" + this.x + "', y: '" + this.y + "'}";
  };
  hamonengine.geometry.vector2.prototype.normalize = function $hamonengine$geometry$vector2$$normalize$() {
    var $l$$ = this.length;
    return 0 < $l$$ ? new hamonengine.geometry.vector2(this.x / $l$$, this.y / $l$$) : new hamonengine.geometry.vector2;
  };
  hamonengine.geometry.vector2.prototype.normal = function $hamonengine$geometry$vector2$$normal$($rotationType$$) {
    $rotationType$$ = void 0 === $rotationType$$ ? ROTATION_TYPE.CCW : $rotationType$$;
    var $l$$ = this.length;
    return 0 < $l$$ ? $rotationType$$ === ROTATION_TYPE.CCW ? new hamonengine.geometry.vector2(-this.y / $l$$, this.x / $l$$) : new hamonengine.geometry.vector2(this.y / $l$$, -this.x / $l$$) : new hamonengine.geometry.vector2;
  };
  hamonengine.geometry.vector2.prototype.mirror = function $hamonengine$geometry$vector2$$mirror$() {
    return new hamonengine.geometry.vector2(-this.x, this.y);
  };
  hamonengine.geometry.vector2.prototype.flip = function $hamonengine$geometry$vector2$$flip$() {
    return new hamonengine.geometry.vector2(this.x, -this.y);
  };
  hamonengine.geometry.vector2.prototype.invert = function $hamonengine$geometry$vector2$$invert$() {
    return new hamonengine.geometry.vector2(-this.x, -this.y);
  };
  hamonengine.geometry.vector2.prototype.add = function $hamonengine$geometry$vector2$$add$($v$$) {
    return new hamonengine.geometry.vector2(this.x + $v$$.x, this.y + $v$$.y);
  };
  hamonengine.geometry.vector2.prototype.subtract = function $hamonengine$geometry$vector2$$subtract$($v$$) {
    return new hamonengine.geometry.vector2(this.x - $v$$.x, this.y - $v$$.y);
  };
  hamonengine.geometry.vector2.prototype.multiply = function $hamonengine$geometry$vector2$$multiply$($vos$$) {
    return $vos$$ instanceof hamonengine.geometry.vector2 ? this.multiplyVector($vos$$) : this.multiplyScalar($vos$$);
  };
  hamonengine.geometry.vector2.prototype.multiplyScalar = function $hamonengine$geometry$vector2$$multiplyScalar$($s$$) {
    return new hamonengine.geometry.vector2(this.x * $s$$, this.y * $s$$);
  };
  hamonengine.geometry.vector2.prototype.multiplyVector = function $hamonengine$geometry$vector2$$multiplyVector$($v$$) {
    return new hamonengine.geometry.vector2(this.x * $v$$.x, this.y * $v$$.y);
  };
  hamonengine.geometry.vector2.prototype.dot = function $hamonengine$geometry$vector2$$dot$($v$$) {
    return this.x * $v$$.x + this.y * $v$$.y;
  };
  hamonengine.geometry.vector2.prototype.cross = function $hamonengine$geometry$vector2$$cross$($v$$) {
    return new hamonengine.geometry.vector3(0, 0, this.x * $v$$.y - this.y * $v$$.x);
  };
  hamonengine.geometry.vector2.prototype.equals = function $hamonengine$geometry$vector2$$equals$($v$$) {
    return this.x === $v$$.x && this.y === $v$$.y;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.vector2.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return (Math.atan2(this.y, this.x) + Math.PI2) % Math.PI2;
  }}});
  hamonengine.geometry.vector2.X_AXIS_NORMAL = new hamonengine.geometry.vector2(1, 0);
  hamonengine.geometry.vector2.Y_AXIS_NORMAL = new hamonengine.geometry.vector2(0, 1);
})();
hamonengine.geometry = hamonengine.geometry || {};
(function() {
  hamonengine.geometry.vector3 = function $hamonengine$geometry$vector3$($x$$, $y$$, $z$$) {
    this.x = void 0 === $x$$ ? 0.0 : $x$$;
    this.y = void 0 === $y$$ ? 0.0 : $y$$;
    this.z = void 0 === $z$$ ? 0.0 : $z$$;
  };
  hamonengine.geometry.vector3.clone = function $hamonengine$geometry$vector3$clone$($vector$$) {
    return new hamonengine.geometry.vector3($vector$$.x, $vector$$.y, $vector$$.z);
  };
  hamonengine.geometry.vector3.prototype.clone = function $hamonengine$geometry$vector3$$clone$() {
    return hamonengine.geometry.vector3.clone(this);
  };
  hamonengine.geometry.vector3.prototype.toString = function $hamonengine$geometry$vector3$$toString$() {
    return "{x: '" + this.x + "', y: '" + this.y + "', z: '" + this.z + "'}";
  };
  hamonengine.geometry.vector3.prototype.normalize = function $hamonengine$geometry$vector3$$normalize$() {
    var $l$$ = this.length;
    return 0 < $l$$ ? new hamonengine.geometry.vector3(this.x / $l$$, this.y / $l$$, this.z / $l$$) : new hamonengine.geometry.vector3;
  };
  hamonengine.geometry.vector3.prototype.invert = function $hamonengine$geometry$vector3$$invert$() {
    return new hamonengine.geometry.vector2(-this.x, -this.y, -this.z);
  };
  hamonengine.geometry.vector3.prototype.add = function $hamonengine$geometry$vector3$$add$($v$$) {
    return new hamonengine.geometry.vector3(this.x + $v$$.x, this.y + $v$$.y, this.z + $v$$.z);
  };
  hamonengine.geometry.vector3.prototype.subtract = function $hamonengine$geometry$vector3$$subtract$($v$$) {
    return new hamonengine.geometry.vector3(this.x - $v$$.x, this.y - $v$$.y, this.z - $v$$.z);
  };
  hamonengine.geometry.vector3.prototype.multiplyScalar = function $hamonengine$geometry$vector3$$multiplyScalar$($s$$) {
    return new hamonengine.geometry.vector3(this.x * $s$$, this.y * $s$$, this.z * $s$$);
  };
  hamonengine.geometry.vector3.prototype.multiplyVector = function $hamonengine$geometry$vector3$$multiplyVector$($v$$) {
    return new hamonengine.geometry.vector3(this.x * $v$$.x, this.y * $v$$.y, this.z * $v$$.z);
  };
  hamonengine.geometry.vector3.prototype.dot = function $hamonengine$geometry$vector3$$dot$($v$$) {
    return this.x * $v$$.x + this.y * $v$$.y + this.z * $v$$.z;
  };
  hamonengine.geometry.vector3.prototype.cross = function $hamonengine$geometry$vector3$$cross$($v$$) {
    return new hamonengine.geometry.vector3(this.y * $v$$.z - this.z * $v$$.y, $v$$.x * this.z - this.x * $v$$.z, this.x * $v$$.y - this.y * $v$$.x);
  };
  hamonengine.geometry.vector3.prototype.equals = function $hamonengine$geometry$vector3$$equals$($v$$) {
    return this.x === $v$$.x && this.y === $v$$.y && this.z === $v$$.z;
  };
  $jscomp.global.Object.defineProperties(hamonengine.geometry.vector3.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }}});
  hamonengine.geometry.vector3.X_AXIS_NORMAL = new hamonengine.geometry.vector3(1, 0, 0);
  hamonengine.geometry.vector3.Y_AXIS_NORMAL = new hamonengine.geometry.vector3(0, 1, 0);
  hamonengine.geometry.vector3.Z_AXIS_NORMAL = new hamonengine.geometry.vector3(0, 0, 1);
})();
hamonengine.graphics = hamonengine.graphics || {};
var BLENDING_OPS = {REPLACE:0, ADD:1, MULTIPLY:2, OR:3, AND:4, XOR:5, DIFFERENCE:6}, TEXT_DRAW_TYPE = {STROKE:0, FILL:1};
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.imageext = function $hamonengine$graphics$imageext$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.graphics.imageext && ($options$$ = {image:$options$$._image});
    this._image = $options$$.image || new Image;
    this._state = 0;
    this._backbufferCtx = this._backbufferResource = null;
    hamonengine.util.logger.debug("[hamonengine.graphics.imageext.constructor] Starting State: {" + this._state + "}");
  };
  hamonengine.graphics.imageext.prototype.clone = function $hamonengine$graphics$imageext$$clone$() {
    return new hamonengine.graphics.imageext(this);
  };
  hamonengine.graphics.imageext.prototype.load = function $hamonengine$graphics$imageext$$load$($src$$) {
    $src$$ = void 0 === $src$$ ? "" : $src$$;
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return "" !== $src$$ && ($$jscomp$async$this$$._image.src = $src$$), $$jscomp$async$this$$._state = 1, $$jscomp$generator$state$$ = -1, {value:new Promise(function($resolve$$, $reject$$) {
                $$jscomp$async$this$$.complete ? ($$jscomp$async$this$$._state = 2, $resolve$$()) : ($$jscomp$async$this$$.image.addEventListener("load", function() {
                  $$jscomp$async$this$$._state = 2;
                  hamonengine.util.logger.debug("[hamonengine.graphics.imageext.load] Image '" + $src$$ + "' has loaded successfully.");
                  $resolve$$();
                }, !1), $$jscomp$async$this$$.image.addEventListener("error", function($error$$) {
                  $$jscomp$async$this$$._state = 3;
                  $reject$$("The image '" + ($error$$ && $error$$.path && 0 < $error$$.path.length && $error$$.path[0].src || "") + "' could not be loaded.");
                }, !1));
              }), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.graphics.imageext.prototype.getImageData = function $hamonengine$graphics$imageext$$getImageData$($region$$) {
    this._backbufferResource = this._backbufferResource || hamonengine.graphics.layer.createNewCanvas(this.rawImage.width, this.rawImage.height);
    this._backbufferCtx = this._backbufferCtx || this._backbufferResource.getContext("2d");
    this._backbufferCtx.drawImage(this.rawImage, 0, 0);
    $region$$ = $region$$ || new hamonengine.geometry.rect;
    return this._backbufferCtx.getImageData($region$$.x, $region$$.y, $region$$.width || this.rawImage.width, $region$$.height || this.rawImage.height);
  };
  hamonengine.graphics.imageext.prototype.blendColorRegion = function $hamonengine$graphics$imageext$$blendColorRegion$($r$$, $g$$, $b$$, $a$$, $region$$, $blendingOps_data$$) {
    $r$$ = void 0 === $r$$ ? 0 : $r$$;
    $g$$ = void 0 === $g$$ ? 0 : $g$$;
    $b$$ = void 0 === $b$$ ? 0 : $b$$;
    $a$$ = void 0 === $a$$ ? 0 : $a$$;
    $region$$ = void 0 === $region$$ ? null : $region$$;
    $blendingOps_data$$ = void 0 === $blendingOps_data$$ ? BLENDING_OPS.REPLACE : $blendingOps_data$$;
    if (this.complete) {
      var $sourceData$$ = this.getImageData($region$$), $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
        return 0 < $s$$ ? $s$$ : $d$$;
      };
      switch($blendingOps_data$$) {
        case BLENDING_OPS.ADD:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ + $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.MULTIPLY:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ * $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.AND:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ & $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.OR:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ | $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.XOR:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ ^ $d$$, 255) : $d$$;
          };
          break;
        case BLENDING_OPS.DIFFERENCE:
          $blendingMethod$$ = function $$blendingMethod$$$($s$$, $d$$) {
            return 0 < $s$$ ? Math.min($s$$ - $d$$, 255) : $d$$;
          };
      }
      $blendingOps_data$$ = $sourceData$$.data;
      for (var $i$$ = 0; $i$$ < $blendingOps_data$$.length; $i$$ += 4) {
        $blendingOps_data$$[$i$$] = $blendingMethod$$($r$$, $blendingOps_data$$[$i$$]), $blendingOps_data$$[$i$$ + 1] = $blendingMethod$$($g$$, $blendingOps_data$$[$i$$ + 1]), $blendingOps_data$$[$i$$ + 2] = $blendingMethod$$($b$$, $blendingOps_data$$[$i$$ + 2]), $blendingOps_data$$[$i$$ + 3] = $blendingMethod$$($a$$, $blendingOps_data$$[$i$$ + 3]);
      }
      this._backbufferCtx.putImageData($sourceData$$, $region$$.x, $region$$.y);
    }
  };
  hamonengine.graphics.imageext.prototype.adjustColorChannel = function $hamonengine$graphics$imageext$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$, $region$$) {
    $r$$ = void 0 === $r$$ ? 1.0 : $r$$;
    $g$$ = void 0 === $g$$ ? 1.0 : $g$$;
    $b$$ = void 0 === $b$$ ? 1.0 : $b$$;
    $a$$ = void 0 === $a$$ ? 1.0 : $a$$;
    $region$$ = void 0 === $region$$ ? null : $region$$;
    if (this.complete) {
      for (var $sourceData$$ = this.getImageData($region$$), $data$$ = $sourceData$$.data, $i$$ = 0; $i$$ < $data$$.length; $i$$ += 4) {
        $data$$[$i$$] = Math.bitRound($data$$[$i$$] * $r$$), $data$$[$i$$ + 1] = Math.bitRound($data$$[$i$$ + 1] * $g$$), $data$$[$i$$ + 2] = Math.bitRound($data$$[$i$$ + 2] * $b$$), $data$$[$i$$ + 3] = Math.bitRound($data$$[$i$$ + 3] * $a$$);
      }
      this._backbufferCtx.putImageData($sourceData$$, $region$$.x, $region$$.y, $region$$.x, $region$$.y, $region$$.width, $region$$.height);
    }
  };
  hamonengine.graphics.imageext.prototype.bitblit = function $hamonengine$graphics$imageext$$bitblit$($destData_imageData$$, $srcRegion$$, $destRegion$$, $transparency$$) {
    if (this.complete && $destData_imageData$$.complete) {
      $destData_imageData$$ instanceof hamonengine.graphics.imageext && ($destData_imageData$$ = $destData_imageData$$.rawImage);
      $transparency$$ = Math.max(Math.min(void 0 === $transparency$$ ? 1.0 : $transparency$$, 1.0), 0.0);
      var $destImageData$$ = this.getImageData($destRegion$$), $srcData_srcImageData_targetCtx$$ = hamonengine.graphics.layer.createNewCanvas($destData_imageData$$.width, $destData_imageData$$.height).getContext("2d");
      $srcData_srcImageData_targetCtx$$.drawImage($destData_imageData$$, 0, 0);
      $srcData_srcImageData_targetCtx$$ = $srcData_srcImageData_targetCtx$$.getImageData($srcRegion$$.x, $srcRegion$$.y, $srcRegion$$.width, $srcRegion$$.height);
      $destData_imageData$$ = $destImageData$$.data;
      $srcData_srcImageData_targetCtx$$ = $srcData_srcImageData_targetCtx$$.data;
      for (var $row$$ = 0; $row$$ < $destRegion$$.height && !($row$$ >= $srcRegion$$.height); $row$$++) {
        for (var $col$$ = 0; $col$$ < $destRegion$$.width && !($col$$ >= $srcRegion$$.width); $col$$++) {
          var $destIndex$$ = 4 * ($row$$ * $destRegion$$.width + $col$$), $srcIndex$$ = 4 * ($row$$ * $srcRegion$$.width + $col$$), $transparencyComplement$$ = 0 < $srcData_srcImageData_targetCtx$$[$srcIndex$$ + 3] ? 1.0 - $transparency$$ : 1.0;
          $destData_imageData$$[$destIndex$$] = Math.bitRound($destData_imageData$$[$destIndex$$] * $transparencyComplement$$ + $srcData_srcImageData_targetCtx$$[$srcIndex$$] * $transparency$$);
          $destData_imageData$$[$destIndex$$ + 1] = Math.bitRound($destData_imageData$$[$destIndex$$ + 1] * $transparencyComplement$$ + $srcData_srcImageData_targetCtx$$[$srcIndex$$ + 1] * $transparency$$);
          $destData_imageData$$[$destIndex$$ + 2] = Math.bitRound($destData_imageData$$[$destIndex$$ + 2] * $transparencyComplement$$ + $srcData_srcImageData_targetCtx$$[$srcIndex$$ + 2] * $transparency$$);
        }
      }
      this._backbufferCtx.putImageData($destImageData$$, $destRegion$$.x, $destRegion$$.y);
    }
  };
  hamonengine.graphics.imageext.prototype.draw = function $hamonengine$graphics$imageext$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this.width : $width$$;
    $height$$ = void 0 === $height$$ ? this.height : $height$$;
    $layer$$.drawImage(this, $x$$, $y$$, this.width, this.height, destinationX, destinationY, $width$$, $height$$);
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.imageext.prototype, {src:{configurable:!0, enumerable:!0, get:function() {
    return this._image.src;
  }}, complete:{configurable:!0, enumerable:!0, get:function() {
    return this._image.complete;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return 2 === this._state;
  }}, image:{configurable:!0, enumerable:!0, get:function() {
    return this._backbufferResource ? this._backbufferResource : this._image;
  }}, rawImage:{configurable:!0, enumerable:!0, get:function() {
    return this._image;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this.image.width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this.image.height;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.layer = function $hamonengine$graphics$layer$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._canvasId = $options$$.canvasId || "";
    this._name = $options$$.name || "";
    this._alpha = void 0 !== $options$$.alpha ? $options$$.alpha : !1;
    this._backgroundColor = $options$$.backgroundColor || "black";
    this._allowEventBinding = void 0 !== $options$$.allowEventBinding ? $options$$.allowEventBinding : !1;
    this._wrapVertical = void 0 !== $options$$.wrapVertical ? $options$$.wrapVertical : !1;
    this._wrapHorizontal = void 0 !== $options$$.wrapHorizontal ? $options$$.wrapHorizontal : !1;
    this._clipToViewPort = void 0 !== $options$$.clipToViewPort ? $options$$.clipToViewPort : !0;
    this._enableImageSmoothing = void 0 !== $options$$.enableImageSmoothing ? $options$$.enableImageSmoothing : !0;
    this._invertYAxis = void 0 !== $options$$.invertYAxis ? $options$$.invertYAxis : !1;
    this._invertXAxis = void 0 !== $options$$.invertXAxis ? $options$$.invertXAxis : !1;
    var $canvas$$ = $options$$.canvas;
    if (!this._canvasId && !$canvas$$) {
      throw console.error("[hamonengine.graphics.layer.constructor] Invalid canvasId '" + this._canvasId + "' or canvas. Unable to create the layer!"), "Cannot create the layer";
    }
    $canvas$$ ? (this._canvas = $canvas$$, this._canvasId = $canvas$$.id, this._name = $options$$.name || $canvas$$.getAttribute("name")) : this._canvas = document.getElementById(this._canvasId);
    if (!this._canvas) {
      throw console.error("[hamonengine.graphics.layer.constructor] Invalid canvas: '" + this._canvasId + "' unable to create the layer!"), "Cannot create the layer";
    }
    try {
      this._alpha ? this._canvasContext = this._canvas.getContext("2d", {alpha:this._alpha}) : (this._workAround = !0, this._canvasContext = this._canvas.getContext("2d"));
    } catch ($err$$) {
    }
    this.enableImageSmoothing($options$$.enableImageSmoothing);
    if (!this._canvasContext) {
      throw console.error("[hamonengine.graphics.layer.constructor] Unable to get the 2d context: '" + this._canvasId + "' unable to create the layer!"), "Cannot create the layer";
    }
    this._viewPort = $options$$.viewPort || new hamonengine.geometry.rect(0, 0, this._canvas.width, this._canvas.height);
    this._wasReset = !1;
    this._allowSaveStateEnabled = !0;
    this._viewPortBorderColor = "";
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] Canvas Id: " + this._canvasId);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] Name: " + this._name);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] Alpha: " + this._alpha);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] AllowEventBinding: " + this._allowEventBinding);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] WrapVertical: " + this._wrapVertical);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] WrapHorizontal: " + this._wrapHorizontal);
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] ClipToViewPort: " + this._clipToViewPort);
  };
  hamonengine.graphics.layer.createNewCanvas = function $hamonengine$graphics$layer$createNewCanvas$($width$$, $height$$, $id$$, $name$$) {
    $id$$ = void 0 === $id$$ ? "" : $id$$;
    $name$$ = void 0 === $name$$ ? "" : $name$$;
    var $canvas$$ = document.createElement("canvas");
    $canvas$$.setAttribute("width", $width$$);
    $canvas$$.setAttribute("height", $height$$);
    $id$$ && $canvas$$.setAttribute("id", $id$$);
    $name$$ && $canvas$$.setAttribute("name", $name$$);
    return $canvas$$;
  };
  hamonengine.graphics.layer.prototype.clone = function $hamonengine$graphics$layer$$clone$($canvasId_newLayer$$, $name$$, $elementToAttach$$) {
    $elementToAttach$$ = void 0 === $elementToAttach$$ ? null : $elementToAttach$$;
    var $newCanvas$$ = hamonengine.graphics.layer.createNewCanvas(this.width, this.height, $canvasId_newLayer$$, $name$$);
    $elementToAttach$$ && $elementToAttach$$.insertBefore($newCanvas$$, null);
    $canvasId_newLayer$$ = new hamonengine.graphics.layer({canvasId:$canvasId_newLayer$$, name:$name$$, canvas:$newCanvas$$, alpha:this.alpha, allowEventBinding:this.allowEventBinding, wrapVertical:this.wrapVertical, wrapHorizontal:this.wrapHorizontal, clipToViewPort:this.clipToViewPort, enableImageSmoothing:this._enableImageSmoothing, invertYAxis:this.invertYAxis, invertXAxis:this.invertXAxis, viewPort:this.viewPort});
    $canvasId_newLayer$$._allowSaveStateEnabled = this._allowSaveStateEnabled;
    $canvasId_newLayer$$._viewPortBorderColor = this._viewPortBorderColor;
    return $canvasId_newLayer$$;
  };
  hamonengine.graphics.layer.prototype.enableImageSmoothing = function $hamonengine$graphics$layer$$enableImageSmoothing$($enable$$) {
    $enable$$ = void 0 === $enable$$ ? !0 : $enable$$;
    hamonengine.util.logger.debug("[hamonengine.graphics.layer.constructor] EnableImageSmoothing: " + $enable$$);
    this._enableImageSmoothing = $enable$$;
    try {
      this.context.webkitImageSmoothingEnabled = $enable$$, this.context.mozImageSmoothingEnabled = $enable$$, this.context.imageSmoothingEnabled = $enable$$;
    } catch ($err$$) {
    }
  };
  hamonengine.graphics.layer.prototype.clear = function $hamonengine$graphics$layer$$clear$($x$$, $y$$, $width$$, $height$$) {
    $x$$ = void 0 === $x$$ ? this.viewPort.x : $x$$;
    $y$$ = void 0 === $y$$ ? this.viewPort.y : $y$$;
    $width$$ = void 0 === $width$$ ? this.viewPort.width : $width$$;
    $height$$ = void 0 === $height$$ ? this.viewPort.height : $height$$;
    this._wasReset = !1;
    this.context.clearRect($x$$, $y$$, $width$$, $height$$);
    if (this._workAround) {
      var $originalFillStyle$$ = this.context.fillStyle;
      this.context.fillStyle = this._backgroundColor;
      this.context.fillRect($x$$, $y$$, $width$$, $height$$);
      this.context.fillStyle = $originalFillStyle$$;
    }
  };
  hamonengine.graphics.layer.prototype.reset = function $hamonengine$graphics$layer$$reset$() {
    this._wasReset || (this.context.resetTransform(), this._wasReset = !0);
  };
  hamonengine.graphics.layer.prototype.save = function $hamonengine$graphics$layer$$save$() {
    this.allowSaveState && this.context.save();
  };
  hamonengine.graphics.layer.prototype.restore = function $hamonengine$graphics$layer$$restore$() {
    this.allowSaveState && this.context.restore();
  };
  hamonengine.graphics.layer.prototype.fillLayerImage = function $hamonengine$graphics$layer$$fillLayerImage$($image$$, $x$$, $y$$) {
    $x$$ = void 0 === $x$$ ? this.viewPort.x : $x$$;
    $y$$ = void 0 === $y$$ ? this.viewPort.y : $y$$;
    this.context.drawImage($image$$, $x$$, $y$$, this.viewPort.width, this.viewPort.height);
  };
  hamonengine.graphics.layer.prototype.beginPainting = function $hamonengine$graphics$layer$$beginPainting$() {
    this.clear();
    this.borderColor && (this.context.strokeStyle = this.borderColor, this.context.strokeRect(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height));
    !this.clipToViewPort || 0 === this.viewPort.x && 0 === this.viewPort.y && this.viewPort.width === this.width && this.viewPort.height === this.height || (this.context.beginPath(), this.context.rect(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height), this.context.clip());
  };
  hamonengine.graphics.layer.prototype.endPainting = function $hamonengine$graphics$layer$$endPainting$() {
    this.reset();
  };
  hamonengine.graphics.layer.prototype.drawLayer = function $hamonengine$graphics$layer$$drawLayer$($layer$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$) {
    $destinationWidth$$ = void 0 === $destinationWidth$$ ? this.width : $destinationWidth$$;
    $destinationHeight$$ = void 0 === $destinationHeight$$ ? this.height : $destinationHeight$$;
    if (!($layer$$ instanceof hamonengine.graphics.layer)) {
      throw "Parameter layer is not of type hamonengine.graphics.layer.";
    }
    this.context.drawImage($layer$$.canvas, void 0 === $destinationX$$ ? 0 : $destinationX$$, void 0 === $destinationY$$ ? 0 : $destinationY$$, $destinationWidth$$, $destinationHeight$$);
  };
  hamonengine.graphics.layer.prototype.drawText = function $hamonengine$graphics$layer$$drawText$($text$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var2_$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    $$jscomp$destructuring$var2_$$ = void 0 === $$jscomp$destructuring$var2_$$ ? {} : $$jscomp$destructuring$var2_$$;
    var $color$$ = void 0 === $$jscomp$destructuring$var2_$$.color ? "white" : $$jscomp$destructuring$var2_$$.color, $textDrawType$$ = void 0 === $$jscomp$destructuring$var2_$$.textDrawType ? TEXT_DRAW_TYPE.FILL : $$jscomp$destructuring$var2_$$.textDrawType;
    this.context.font = void 0 === $$jscomp$destructuring$var2_$$.font ? "16px serif" : $$jscomp$destructuring$var2_$$.font;
    this.context.textBaseline = "top";
    $textDrawType$$ === TEXT_DRAW_TYPE.STROKE ? (this.context.strokeStyle = $color$$, this.context.strokeText($text$$, $sourceX$$, $sourceY$$)) : (this.context.fillStyle = $color$$, this.context.fillText($text$$, $sourceX$$, $sourceY$$));
  };
  hamonengine.graphics.layer.prototype.drawImage = function $hamonengine$graphics$layer$$drawImage$($image$$, $sourceX$$, $sourceY$$, $sourceWidth$$, $sourceHeight$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$) {
    $image$$.complete && this.context.drawImage($image$$ instanceof hamonengine.graphics.imageext ? $image$$.image : $image$$, $sourceX$$, $sourceY$$, $sourceWidth$$, $sourceHeight$$, $destinationX$$, $destinationY$$, $destinationWidth$$, $destinationHeight$$);
  };
  hamonengine.graphics.layer.prototype.drawVector = function $hamonengine$graphics$layer$$drawVector$($vector$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var4_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var5_color$$ = void 0 === $$jscomp$destructuring$var4_lineWidth$$ ? {} : $$jscomp$destructuring$var4_lineWidth$$;
    $$jscomp$destructuring$var4_lineWidth$$ = void 0 === $$jscomp$destructuring$var5_color$$.lineWidth ? 1 : $$jscomp$destructuring$var5_color$$.lineWidth;
    $$jscomp$destructuring$var5_color$$ = void 0 === $$jscomp$destructuring$var5_color$$.color ? "white" : $$jscomp$destructuring$var5_color$$.color;
    if (!($vector$$ instanceof hamonengine.geometry.vector2 || $vector$$ instanceof hamonengine.geometry.vector3)) {
      throw "Parameter polygon is not of type hamonengine.geometry.vector2 or of type hamonengine.geometry.vector3.";
    }
    this.context.lineWidth = $$jscomp$destructuring$var4_lineWidth$$;
    this.context.strokeStyle = $$jscomp$destructuring$var5_color$$;
    this.context.beginPath();
    this.context.moveTo($sourceX$$, $sourceY$$);
    this.context.lineTo($sourceX$$ + $vector$$.x, $sourceY$$ + $vector$$.y);
    this.context.stroke();
  };
  hamonengine.graphics.layer.prototype.drawRect = function $hamonengine$graphics$layer$$drawRect$($rect$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var6_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var7_fillColor$$ = void 0 === $$jscomp$destructuring$var6_lineWidth$$ ? {} : $$jscomp$destructuring$var6_lineWidth$$;
    $$jscomp$destructuring$var6_lineWidth$$ = void 0 === $$jscomp$destructuring$var7_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var7_fillColor$$.lineWidth;
    var $color$$ = void 0 === $$jscomp$destructuring$var7_fillColor$$.color ? "white" : $$jscomp$destructuring$var7_fillColor$$.color, $fill$$ = void 0 === $$jscomp$destructuring$var7_fillColor$$.fill ? !1 : $$jscomp$destructuring$var7_fillColor$$.fill;
    $$jscomp$destructuring$var7_fillColor$$ = void 0 === $$jscomp$destructuring$var7_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var7_fillColor$$.fillColor;
    this.simpleDrawRect($rect$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var6_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var7_fillColor$$});
    if (this.wrapHorizontal) {
      var $xOffset$jscomp$2_yOffset$$ = $sourceX$$ + $rect$$.x - this.viewPort.x;
      0 >= $xOffset$jscomp$2_yOffset$$ && this.simpleDrawRect($rect$$, this.viewPort.width + $xOffset$jscomp$2_yOffset$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var6_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var7_fillColor$$});
      $sourceX$$ + $rect$$.width >= this.viewPort.width && this.simpleDrawRect($rect$$, this.viewPort.x - (this.viewPort.width - ($sourceX$$ + $rect$$.x)), $sourceY$$, {lineWidth:$$jscomp$destructuring$var6_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var7_fillColor$$});
    }
    this.wrapVertical && ($xOffset$jscomp$2_yOffset$$ = $sourceY$$ + $rect$$.y - this.viewPort.y, 0 >= $xOffset$jscomp$2_yOffset$$ && this.simpleDrawRect($rect$$, $sourceX$$, this.viewPort.height + $xOffset$jscomp$2_yOffset$$, {lineWidth:$$jscomp$destructuring$var6_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var7_fillColor$$}), $sourceY$$ + $rect$$.height >= this.viewPort.height && this.simpleDrawRect($rect$$, $sourceX$$, this.viewPort.y - (this.viewPort.height - ($sourceY$$ + 
    $rect$$.y)), {lineWidth:$$jscomp$destructuring$var6_lineWidth$$, color:$color$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var7_fillColor$$}));
  };
  hamonengine.graphics.layer.prototype.simpleDrawRect = function $hamonengine$graphics$layer$$simpleDrawRect$($rect$$, $sourceX$jscomp$4_x$$, $sourceY$jscomp$4_y$$, $$jscomp$destructuring$var8_fill$$) {
    var $$jscomp$destructuring$var9_fillColor$$ = void 0 === $$jscomp$destructuring$var8_fill$$ ? {} : $$jscomp$destructuring$var8_fill$$, $lineWidth$$ = void 0 === $$jscomp$destructuring$var9_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var9_fillColor$$.lineWidth, $color$$ = void 0 === $$jscomp$destructuring$var9_fillColor$$.color ? "white" : $$jscomp$destructuring$var9_fillColor$$.color;
    $$jscomp$destructuring$var8_fill$$ = void 0 === $$jscomp$destructuring$var9_fillColor$$.fill ? !1 : $$jscomp$destructuring$var9_fillColor$$.fill;
    $$jscomp$destructuring$var9_fillColor$$ = void 0 === $$jscomp$destructuring$var9_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var9_fillColor$$.fillColor;
    if (!($rect$$ instanceof hamonengine.geometry.rect)) {
      throw "Parameter rect is not of type hamonengine.geometry.rect.";
    }
    this.context.lineWidth = $lineWidth$$;
    this.context.strokeStyle = $color$$;
    this.context.fillStyle = $$jscomp$destructuring$var9_fillColor$$;
    $sourceX$jscomp$4_x$$ = $rect$$.x + (void 0 === $sourceX$jscomp$4_x$$ ? 0 : $sourceX$jscomp$4_x$$);
    $sourceY$jscomp$4_y$$ = $rect$$.y + (void 0 === $sourceY$jscomp$4_y$$ ? 0 : $sourceY$jscomp$4_y$$);
    this.invertYAxis && ($sourceY$jscomp$4_y$$ = this.viewPort.height - $sourceY$jscomp$4_y$$);
    this.invertXAxis && ($sourceX$jscomp$4_x$$ = this.viewPort.width - $sourceX$jscomp$4_x$$);
    this.context.beginPath();
    this.context.moveTo($sourceX$jscomp$4_x$$, $sourceY$jscomp$4_y$$);
    this.context.strokeRect($sourceX$jscomp$4_x$$, $sourceY$jscomp$4_y$$, $rect$$.width, $rect$$.height);
    this.context.closePath();
    $$jscomp$destructuring$var8_fill$$ && this.context.fillRect($sourceX$jscomp$4_x$$, $sourceY$jscomp$4_y$$, $rect$$.width, $rect$$.height);
    this.context.stroke();
  };
  hamonengine.graphics.layer.prototype.drawPolygon = function $hamonengine$graphics$layer$$drawPolygon$($polygon$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var10_lineWidth$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var11_fillColor$$ = void 0 === $$jscomp$destructuring$var10_lineWidth$$ ? {} : $$jscomp$destructuring$var10_lineWidth$$;
    $$jscomp$destructuring$var10_lineWidth$$ = void 0 === $$jscomp$destructuring$var11_fillColor$$.lineWidth ? 1 : $$jscomp$destructuring$var11_fillColor$$.lineWidth;
    var $color$$ = void 0 === $$jscomp$destructuring$var11_fillColor$$.color ? "white" : $$jscomp$destructuring$var11_fillColor$$.color, $drawNormals$$ = void 0 === $$jscomp$destructuring$var11_fillColor$$.drawNormals ? !1 : $$jscomp$destructuring$var11_fillColor$$.drawNormals, $fill$$ = void 0 === $$jscomp$destructuring$var11_fillColor$$.fill ? !1 : $$jscomp$destructuring$var11_fillColor$$.fill;
    $$jscomp$destructuring$var11_fillColor$$ = void 0 === $$jscomp$destructuring$var11_fillColor$$.fillColor ? "white" : $$jscomp$destructuring$var11_fillColor$$.fillColor;
    this.simpleDrawPolygon($polygon$$, $sourceX$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var10_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var11_fillColor$$});
    if (this.wrapHorizontal) {
      var $xOffset$jscomp$3_yOffset$$ = $sourceX$$ + $polygon$$.min.x - this.viewPort.x;
      0 >= $xOffset$jscomp$3_yOffset$$ && this.simpleDrawPolygon($polygon$$, this.viewPort.width + $xOffset$jscomp$3_yOffset$$, $sourceY$$, {lineWidth:$$jscomp$destructuring$var10_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var11_fillColor$$});
      $sourceX$$ + $polygon$$.width >= this.viewPort.width && this.simpleDrawPolygon($polygon$$, this.viewPort.x - (this.viewPort.width - ($sourceX$$ + $polygon$$.min.x)), $sourceY$$, {lineWidth:$$jscomp$destructuring$var10_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var11_fillColor$$});
    }
    this.wrapVertical && ($xOffset$jscomp$3_yOffset$$ = $sourceY$$ + $polygon$$.min.y - this.viewPort.y, 0 >= $xOffset$jscomp$3_yOffset$$ && this.simpleDrawPolygon($polygon$$, $sourceX$$, this.viewPort.height + $xOffset$jscomp$3_yOffset$$, {lineWidth:$$jscomp$destructuring$var10_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var11_fillColor$$}), $sourceY$$ + $polygon$$.height >= this.viewPort.height && this.simpleDrawPolygon($polygon$$, $sourceX$$, 
    this.viewPort.y - (this.viewPort.height - ($sourceY$$ + $polygon$$.min.y)), {lineWidth:$$jscomp$destructuring$var10_lineWidth$$, color:$color$$, drawNormals:$drawNormals$$, fill:$fill$$, fillColor:$$jscomp$destructuring$var11_fillColor$$}));
  };
  hamonengine.graphics.layer.prototype.simpleDrawPolygon = function $hamonengine$graphics$layer$$simpleDrawPolygon$($polygon$$, $sourceX$$, $sourceY$$, $$jscomp$destructuring$var12_drawNormals$$) {
    $sourceX$$ = void 0 === $sourceX$$ ? 0 : $sourceX$$;
    $sourceY$$ = void 0 === $sourceY$$ ? 0 : $sourceY$$;
    var $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$ = void 0 === $$jscomp$destructuring$var12_drawNormals$$ ? {} : $$jscomp$destructuring$var12_drawNormals$$, $edge$jscomp$1_index$jscomp$47_lineWidth$$ = void 0 === $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.lineWidth ? 1 : $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.lineWidth, $color$jscomp$7_vertex_x$$ = void 0 === $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.color ? "white" : $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.color;
    $$jscomp$destructuring$var12_drawNormals$$ = void 0 === $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.drawNormals ? !1 : $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.drawNormals;
    var $fill$$ = void 0 === $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.fill ? !1 : $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.fill;
    $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$ = void 0 === $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.fillColor ? "white" : $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.fillColor;
    if (!($polygon$$ instanceof hamonengine.geometry.polygon)) {
      throw "Parameter polygon is not of type hamonengine.geometry.polygon.";
    }
    this.context.lineWidth = $edge$jscomp$1_index$jscomp$47_lineWidth$$;
    this.context.strokeStyle = $color$jscomp$7_vertex_x$$;
    this.context.fillStyle = $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$;
    this.context.beginPath();
    for ($edge$jscomp$1_index$jscomp$47_lineWidth$$ = 0; $edge$jscomp$1_index$jscomp$47_lineWidth$$ < $polygon$$.vertices.length; $edge$jscomp$1_index$jscomp$47_lineWidth$$++) {
      $color$jscomp$7_vertex_x$$ = Math.bitRound($sourceX$$ + $polygon$$.vertices[$edge$jscomp$1_index$jscomp$47_lineWidth$$].x), $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$ = Math.bitRound($sourceY$$ + $polygon$$.vertices[$edge$jscomp$1_index$jscomp$47_lineWidth$$].y), this.invertYAxis && ($$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$ = this.viewPort.height - $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$), this.invertXAxis && ($color$jscomp$7_vertex_x$$ = 
      this.viewPort.width - $color$jscomp$7_vertex_x$$), 0 === $edge$jscomp$1_index$jscomp$47_lineWidth$$ ? this.context.moveTo($color$jscomp$7_vertex_x$$, $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$) : this.context.lineTo($color$jscomp$7_vertex_x$$, $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$);
    }
    this.context.closePath();
    $fill$$ && this.context.fill();
    this.context.stroke();
    if (hamonengine.debug && $$jscomp$destructuring$var12_drawNormals$$) {
      for (this.context.strokeStyle = "white", $$jscomp$destructuring$var12_drawNormals$$ = 0; $$jscomp$destructuring$var12_drawNormals$$ < $polygon$$.vertices.length; $$jscomp$destructuring$var12_drawNormals$$++) {
        $color$jscomp$7_vertex_x$$ = $polygon$$.vertices[$$jscomp$destructuring$var12_drawNormals$$], $edge$jscomp$1_index$jscomp$47_lineWidth$$ = $polygon$$.edges[$$jscomp$destructuring$var12_drawNormals$$], $fill$$ = Math.bitRound($sourceX$$ + $color$jscomp$7_vertex_x$$.x + $edge$jscomp$1_index$jscomp$47_lineWidth$$.x / 2), $color$jscomp$7_vertex_x$$ = Math.bitRound($sourceY$$ + $color$jscomp$7_vertex_x$$.y + $edge$jscomp$1_index$jscomp$47_lineWidth$$.y / 2), this.invertYAxis && ($color$jscomp$7_vertex_x$$ = 
        this.viewPort.height - $color$jscomp$7_vertex_x$$), this.invertXAxis && ($fill$$ = this.viewPort.width - $fill$$), this.context.beginPath(), this.context.moveTo($fill$$, $color$jscomp$7_vertex_x$$), $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$ = $polygon$$.normals[$$jscomp$destructuring$var12_drawNormals$$], $edge$jscomp$1_index$jscomp$47_lineWidth$$ = Math.bitRound($edge$jscomp$1_index$jscomp$47_lineWidth$$.length / 2), this.invertYAxis && ($$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.y = 
        -$$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.y), this.invertXAxis && ($$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.x = -$$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.x), this.context.lineTo($fill$$ + $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.x * $edge$jscomp$1_index$jscomp$47_lineWidth$$, $color$jscomp$7_vertex_x$$ + $$jscomp$destructuring$var13_fillColor$jscomp$3_normal_y$$.y * $edge$jscomp$1_index$jscomp$47_lineWidth$$), this.context.stroke();
      }
    }
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.layer.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, allowEventBinding:{configurable:!0, enumerable:!0, get:function() {
    return this._allowEventBinding;
  }}, context:{configurable:!0, enumerable:!0, get:function() {
    return this._canvasContext;
  }}, canvas:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas;
  }}, clipToViewPort:{configurable:!0, enumerable:!0, get:function() {
    return this._clipToViewPort;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas.width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._canvas.height;
  }}, offsetX:{configurable:!0, enumerable:!0, get:function() {
    return this.canvas.offsetLeft;
  }}, offsetY:{configurable:!0, enumerable:!0, get:function() {
    return this.canvas.offsetTop;
  }}, position:{configurable:!0, enumerable:!0, get:function() {
    var $boundRect$$ = this.canvas.getBoundingClientRect() || {left:0, top:0};
    return new hamonengine.geometry.vector2($boundRect$$.left, $boundRect$$.top);
  }}, viewPort:{configurable:!0, enumerable:!0, get:function() {
    return this._viewPort;
  }}, wrapHorizontal:{configurable:!0, enumerable:!0, get:function() {
    return this._wrapHorizontal;
  }, set:function($v$$) {
    this._wrapHorizontal = $v$$;
  }}, wrapVertical:{configurable:!0, enumerable:!0, get:function() {
    return this._wrapVertical;
  }, set:function($v$$) {
    this._wrapVertical = $v$$;
  }}, allowSaveState:{configurable:!0, enumerable:!0, get:function() {
    return this._allowSaveStateEnabled;
  }, set:function($v$$) {
    this._allowSaveStateEnabled = $v$$;
  }}, borderColor:{configurable:!0, enumerable:!0, get:function() {
    return this._viewPortBorderColor;
  }, set:function($v$$) {
    this._viewPortBorderColor = $v$$;
  }}, invertYAxis:{configurable:!0, enumerable:!0, get:function() {
    return this._invertYAxis;
  }, set:function($v$$) {
    this._invertYAxis = $v$$;
  }}, invertXAxis:{configurable:!0, enumerable:!0, get:function() {
    return this._invertXAxis;
  }, set:function($v$$) {
    this._invertXAxis = $v$$;
  }}, alpha:{configurable:!0, enumerable:!0, get:function() {
    return this.context.globalAlpha;
  }, set:function($v$$) {
    this.context.globalAlpha = $v$$;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.sprite = function $hamonengine$graphics$sprite$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    $options$$ instanceof hamonengine.graphics.sprite && ($options$$ = {image:$options$$._image && $options$$._image.clone(), dimensions:$options$$._dimensions, theta:$options$$.theta});
    this._name = $options$$.name;
    this._image = $options$$.image || new hamonengine.graphics.imageext;
    this._dimensions = $options$$.dimensions ? $options$$.dimensions : this._image instanceof HTMLImageElement ? new hamonengine.geometry.rect(0, 0, this._image.width, this._image.height) : new hamonengine.geometry.rect;
    this._theta = $options$$.theta || 0.0;
    this._scaleVector = new hamonengine.geometry.vector2(1.0, 1.0);
    this._spriteOrientation = 0;
    this._showFullImage = this._showDiagnosisLines = !1;
    this._maxWrapping = 0;
    hamonengine.util.logger.debug("[hamonengine.graphics.sprite.constructor] Starting Dimensions: {" + this._dimensions.toString() + "}");
    hamonengine.util.logger.debug("[hamonengine.graphics.sprite.constructor] Name: " + this._name);
    hamonengine.util.logger.debug("[hamonengine.graphics.sprite.constructor] Theta: " + this._theta);
    hamonengine.util.logger.debug("[hamonengine.graphics.sprite.constructor] ScaleVector: {" + this._scaleVector.toString() + "}");
  };
  hamonengine.graphics.sprite.prototype.copyProperties = function $hamonengine$graphics$sprite$$copyProperties$($properties$$) {
    this._theta = $properties$$.theta;
    this._scaleVector = $properties$$._scaleVector;
    this._spriteOrientation = $properties$$._spriteOrientation;
    this._showDiagnosisLines = $properties$$._showDiagnosisLines;
    this._showFullImage = $properties$$._showFullImage;
  };
  hamonengine.graphics.sprite.prototype.clone = function $hamonengine$graphics$sprite$$clone$() {
    return new hamonengine.graphics.sprite(this);
  };
  hamonengine.graphics.sprite.prototype.load = function $hamonengine$graphics$sprite$$load$($src$$) {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return $$jscomp$generator$state$$ = -1, {value:new Promise(function($resolve$$, $reject$$) {
                $$jscomp$async$this$$._image instanceof hamonengine.graphics.imageext ? $$jscomp$async$this$$._image.load($src$$).then(function() {
                  $$jscomp$async$this$$._dimensions = new hamonengine.geometry.rect(0, 0, $$jscomp$async$this$$._image.width, $$jscomp$async$this$$._image.height);
                  $resolve$$();
                }).catch(function($err$$) {
                  $reject$$($err$$);
                }) : $resolve$$();
              }), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.graphics.sprite.prototype.rotate = function $hamonengine$graphics$sprite$$rotate$($theta$$) {
    this._theta = $theta$$ || 0.0;
    return this;
  };
  hamonengine.graphics.sprite.prototype.scale = function $hamonengine$graphics$sprite$$scale$($x$$, $y$$) {
    this._scaleVector.x = $x$$;
    this._scaleVector.y = $y$$;
    return this;
  };
  hamonengine.graphics.sprite.prototype.mirror = function $hamonengine$graphics$sprite$$mirror$($state$$) {
    this._spriteOrientation = bitflag.toggle(this._spriteOrientation, 2, $state$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.flip = function $hamonengine$graphics$sprite$$flip$($state$$) {
    this._spriteOrientation = bitflag.toggle(this._spriteOrientation, 1, $state$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.blendColor = function $hamonengine$graphics$sprite$$blendColor$($r$$, $g$$, $b$$, $a$$, $blendingOps$$) {
    $blendingOps$$ = void 0 === $blendingOps$$ ? BLENDING_OPS.REPLACE : $blendingOps$$;
    this._image.blendColorRegion(void 0 === $r$$ ? 0 : $r$$, void 0 === $g$$ ? 0 : $g$$, void 0 === $b$$ ? 0 : $b$$, void 0 === $a$$ ? 0 : $a$$, this._dimensions, $blendingOps$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.adjustColorChannel = function $hamonengine$graphics$sprite$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$) {
    this._image.adjustColorChannel(void 0 === $r$$ ? 1.0 : $r$$, void 0 === $g$$ ? 1.0 : $g$$, void 0 === $b$$ ? 1.0 : $b$$, void 0 === $a$$ ? 1.0 : $a$$, this._dimensions);
    return this;
  };
  hamonengine.graphics.sprite.prototype.bitblit = function $hamonengine$graphics$sprite$$bitblit$($sprite$$, $transparency$$) {
    this._image.bitblit($sprite$$._image, $sprite$$._dimensions, this._dimensions, void 0 === $transparency$$ ? 1.0 : $transparency$$);
    return this;
  };
  hamonengine.graphics.sprite.prototype.drawRaw = function $hamonengine$graphics$sprite$$drawRaw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this._dimensions.width : $width$$;
    $height$$ = void 0 === $height$$ ? this._dimensions.height : $height$$;
    this._image.complete && (this.showFullImage ? $layer$$.context.drawImage(this._image.image, Math.bitRound($x$$), Math.bitRound($y$$), Math.bitRound($width$$), Math.bitRound($height$$)) : $layer$$.drawImage(this._image, this._dimensions.x, this._dimensions.y, this._dimensions.width, this._dimensions.height, Math.bitRound($x$$), Math.bitRound($y$$), Math.bitRound($width$$), Math.bitRound($height$$)));
  };
  hamonengine.graphics.sprite.prototype.draw = function $hamonengine$graphics$sprite$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? this._dimensions.width : $width$$;
    $height$$ = void 0 === $height$$ ? this._dimensions.height : $height$$;
    $x$$ = Math.bitRound($x$$);
    $y$$ = Math.bitRound($y$$);
    var $xCenterOffset_xCenterOffset$17$$ = Math.bitRound($width$$ / 2) + $x$$, $yCenterOffset_yCenterOffset$18$$ = Math.bitRound($height$$ / 2) + $y$$, $yOrientation$$ = bitflag.isSet(this._spriteOrientation, 1) ? -1.0 : 1.0, $xOrientation$$ = bitflag.isSet(this._spriteOrientation, 2) ? -1.0 : 1.0;
    $layer$$.save();
    if (1 !== this._scaleVector.x || 1 !== this._scaleVector.y) {
      $layer$$.context.translate($x$$, $y$$), $layer$$.context.scale(this._scaleVector.x, this._scaleVector.y), $layer$$.context.translate(-$x$$, -$y$$);
    }
    0 < this._spriteOrientation && ($layer$$.context.translate($xCenterOffset_xCenterOffset$17$$, $yCenterOffset_yCenterOffset$18$$), $layer$$.context.scale($xOrientation$$, $yOrientation$$), $layer$$.context.translate(-$xCenterOffset_xCenterOffset$17$$, -$yCenterOffset_yCenterOffset$18$$));
    0.0 !== this.theta && ($layer$$.context.translate($xCenterOffset_xCenterOffset$17$$, $yCenterOffset_yCenterOffset$18$$), $layer$$.context.rotate(this.theta), $layer$$.context.translate(-$xCenterOffset_xCenterOffset$17$$, -$yCenterOffset_yCenterOffset$18$$));
    ($layer$$.wrapHorizontal || $layer$$.wrapVertical) && this.drawSpriteWrapping($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$, $xOrientation$$, $yOrientation$$);
    this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$);
    if (hamonengine.debug && this.showDiagnosisLines) {
      $xCenterOffset_xCenterOffset$17$$ = Math.bitRound($width$$ / 2) + $x$$;
      $yCenterOffset_yCenterOffset$18$$ = Math.bitRound($height$$ / 2) + $y$$;
      if ($layer$$.wrapHorizontal || $layer$$.wrapVertical) {
        $layer$$.context.strokeStyle = "red", $layer$$.context.lineWidth = 2, $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$17$$, $yCenterOffset_yCenterOffset$18$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$17$$ + $layer$$.viewPort.width, $yCenterOffset_yCenterOffset$18$$), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$17$$, $yCenterOffset_yCenterOffset$18$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$17$$ - 
        $layer$$.viewPort.width, $yCenterOffset_yCenterOffset$18$$), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$17$$, $yCenterOffset_yCenterOffset$18$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$17$$, $yCenterOffset_yCenterOffset$18$$ + $layer$$.viewPort.height), $layer$$.context.stroke(), $layer$$.context.beginPath(), $layer$$.context.moveTo($xCenterOffset_xCenterOffset$17$$, $yCenterOffset_yCenterOffset$18$$), $layer$$.context.lineTo($xCenterOffset_xCenterOffset$17$$, 
        $yCenterOffset_yCenterOffset$18$$ - $layer$$.viewPort.height), $layer$$.context.stroke(), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$ + $layer$$.viewPort.width, $y$$, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$ - $layer$$.viewPort.width, $y$$, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$ + $layer$$.viewPort.height, $width$$, $height$$), this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$ - 
        $layer$$.viewPort.height, $width$$, $height$$), $layer$$.context.strokeStyle = "white", $layer$$.context.strokeRect($xCenterOffset_xCenterOffset$17$$ - $layer$$.viewPort.width / 2, $yCenterOffset_yCenterOffset$18$$ - $layer$$.viewPort.height / 2, $layer$$.viewPort.width, $layer$$.viewPort.height);
      }
      $layer$$.context.strokeStyle = "red";
      $layer$$.context.strokeRect($x$$, $y$$, $width$$, $height$$);
      $layer$$.context.strokeStyle = "cyan";
      $layer$$.context.strokeRect($layer$$.viewPort.x, $layer$$.viewPort.y, $layer$$.viewPort.width, $layer$$.viewPort.height);
    }
    $layer$$.restore();
  };
  hamonengine.graphics.sprite.prototype.drawSpriteWrapping = function $hamonengine$graphics$sprite$$drawSpriteWrapping$($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$93_xOffset$$, $y$jscomp$73_yOffset$$, $width$$, $height$$, $xOrientation$$, $yOrientation$$) {
    var $cosAngle_wrapLoop$20_wrapLoop$21$$ = Math.cos(-this.theta), $sinAngle$$ = Math.sin(-this.theta), $widthScaled_wrapLoop_wrapLoop$19$$ = $width$$ * this._scaleVector.x, $heightScaled$$ = $height$$ * this._scaleVector.y, $wrappingDirection$$ = new hamonengine.geometry.vector2;
    if ($layer$$.wrapHorizontal) {
      var $horizontalLength_v1y$$ = $layer$$.viewPort.width / this._scaleVector.x * $xOrientation$$;
      var $v1x$$ = Math.bitRound($cosAngle_wrapLoop$20_wrapLoop$21$$ * $horizontalLength_v1y$$);
      $horizontalLength_v1y$$ = Math.bitRound($sinAngle$$ * $horizontalLength_v1y$$);
      if ($x$jscomp$93_xOffset$$ - $widthScaled_wrapLoop_wrapLoop$19$$ <= $layer$$.viewPort.x) {
        if ($wrappingDirection$$.x = 1, $widthScaled_wrapLoop_wrapLoop$19$$ = Math.abs(parseInt(($x$jscomp$93_xOffset$$ - $widthScaled_wrapLoop_wrapLoop$19$$) / $layer$$.viewPort.width, 10)) + 1, 0 === this._maxWrapping || $widthScaled_wrapLoop_wrapLoop$19$$ < this._maxWrapping) {
          this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$93_xOffset$$ + $v1x$$ * $widthScaled_wrapLoop_wrapLoop$19$$, $y$jscomp$73_yOffset$$ + $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$19$$, $width$$, $height$$), 0 < --$widthScaled_wrapLoop_wrapLoop$19$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$93_xOffset$$ + $v1x$$ * $widthScaled_wrapLoop_wrapLoop$19$$, $y$jscomp$73_yOffset$$ + $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$19$$, 
          $width$$, $height$$);
        }
      } else {
        $x$jscomp$93_xOffset$$ + $widthScaled_wrapLoop_wrapLoop$19$$ >= $layer$$.viewPort.width && ($wrappingDirection$$.x = -1, $widthScaled_wrapLoop_wrapLoop$19$$ = parseInt(($x$jscomp$93_xOffset$$ + $widthScaled_wrapLoop_wrapLoop$19$$) / $layer$$.viewPort.width, 10), 0 === this._maxWrapping || $widthScaled_wrapLoop_wrapLoop$19$$ < this._maxWrapping) && (this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$93_xOffset$$ - $v1x$$ * $widthScaled_wrapLoop_wrapLoop$19$$, $y$jscomp$73_yOffset$$ - 
        $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$19$$, $width$$, $height$$), 0 < --$widthScaled_wrapLoop_wrapLoop$19$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$93_xOffset$$ - $v1x$$ * $widthScaled_wrapLoop_wrapLoop$19$$, $y$jscomp$73_yOffset$$ - $horizontalLength_v1y$$ * $widthScaled_wrapLoop_wrapLoop$19$$, $width$$, $height$$));
      }
    }
    if ($layer$$.wrapVertical) {
      var $v2y_verticalLength$$ = $layer$$.viewPort.height / this._scaleVector.y * $yOrientation$$;
      var $v2x$$ = Math.bitRound($sinAngle$$ * $v2y_verticalLength$$);
      $v2y_verticalLength$$ = Math.bitRound($cosAngle_wrapLoop$20_wrapLoop$21$$ * $v2y_verticalLength$$);
      if ($y$jscomp$73_yOffset$$ - $heightScaled$$ <= $layer$$.viewPort.y) {
        if ($wrappingDirection$$.y = 1, $cosAngle_wrapLoop$20_wrapLoop$21$$ = Math.abs(parseInt(($y$jscomp$73_yOffset$$ - $heightScaled$$) / $layer$$.viewPort.height, 10)) + 1, 0 === this._maxWrapping || $cosAngle_wrapLoop$20_wrapLoop$21$$ < this._maxWrapping) {
          this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$93_xOffset$$ - $v2x$$ * $cosAngle_wrapLoop$20_wrapLoop$21$$, $y$jscomp$73_yOffset$$ + $v2y_verticalLength$$ * $cosAngle_wrapLoop$20_wrapLoop$21$$, $width$$, $height$$), 0 < --$cosAngle_wrapLoop$20_wrapLoop$21$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$93_xOffset$$ - $v2x$$ * $cosAngle_wrapLoop$20_wrapLoop$21$$, $y$jscomp$73_yOffset$$ + $v2y_verticalLength$$ * $cosAngle_wrapLoop$20_wrapLoop$21$$, $width$$, 
          $height$$);
        }
      } else {
        $y$jscomp$73_yOffset$$ + $heightScaled$$ >= $layer$$.viewPort.height && ($wrappingDirection$$.y = -1, $cosAngle_wrapLoop$20_wrapLoop$21$$ = parseInt(($y$jscomp$73_yOffset$$ + $heightScaled$$) / $layer$$.viewPort.height, 10), 0 === this._maxWrapping || $cosAngle_wrapLoop$20_wrapLoop$21$$ < this._maxWrapping) && (this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$93_xOffset$$ + $v2x$$ * $cosAngle_wrapLoop$20_wrapLoop$21$$, $y$jscomp$73_yOffset$$ - $v2y_verticalLength$$ * $cosAngle_wrapLoop$20_wrapLoop$21$$, 
        $width$$, $height$$), 0 < --$cosAngle_wrapLoop$20_wrapLoop$21$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$93_xOffset$$ + $v2x$$ * $cosAngle_wrapLoop$20_wrapLoop$21$$, $y$jscomp$73_yOffset$$ - $v2y_verticalLength$$ * $cosAngle_wrapLoop$20_wrapLoop$21$$, $width$$, $height$$));
      }
    }
    $layer$$.wrapVertical && $layer$$.wrapHorizontal && ($x$jscomp$93_xOffset$$ = $x$jscomp$93_xOffset$$ - $wrappingDirection$$.y * $v2x$$ + $wrappingDirection$$.x * $v1x$$, $y$jscomp$73_yOffset$$ = $y$jscomp$73_yOffset$$ + $wrappingDirection$$.y * $v2y_verticalLength$$ + $wrappingDirection$$.x * $horizontalLength_v1y$$, $x$jscomp$93_xOffset$$ && $y$jscomp$73_yOffset$$ && this.drawRaw($layer$$, $elapsedTimeInMilliseconds$$, $x$jscomp$93_xOffset$$, $y$jscomp$73_yOffset$$, $width$$, $height$$));
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.sprite.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }, set:function($v$$) {
    this._name = $v$$;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._dimensions.height;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._dimensions.width;
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return this._theta;
  }}, showDiagnosisLines:{configurable:!0, enumerable:!0, get:function() {
    return this._showDiagnosisLines;
  }, set:function($v$$) {
    this._showDiagnosisLines = $v$$;
  }}, showFullImage:{configurable:!0, enumerable:!0, get:function() {
    return this._showFullImage;
  }, set:function($v$$) {
    this._showFullImage = $v$$;
  }}, maxWrapping:{configurable:!0, enumerable:!0, set:function($v$$) {
    this._maxWrapping = $v$$;
  }}, image:{configurable:!0, enumerable:!0, get:function() {
    return this._image;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.animsprite = function $hamonengine$graphics$animsprite$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.graphics.sprite.call(this, $options$$);
    $options$$ instanceof hamonengine.graphics.animsprite && ($options$$ = {frames:$options$$._frames.map(function($frame$$) {
      return $frame$$.clone();
    }), animationRate:$options$$._animationRate, animationCycles:$options$$._animationCycles});
    this._frames = $options$$.frames || [];
    this._animationRate = $options$$.animationRate || 0;
    this._animationCycles = $options$$.animationCycles || -1;
    this._numberOfAnimationCycles = this._timeSinceLastFrame = this._index = 0;
    this._enableAnimation = !0;
    hamonengine.util.logger.debug("[hamonengine.graphics.animsprite.constructor] Starting Animation Rate: " + this._animationRate);
    hamonengine.util.logger.debug("[hamonengine.graphics.animsprite.constructor] Starting Animation Cycle: " + this._animationCycles);
    hamonengine.util.logger.debug("[hamonengine.graphics.animsprite.constructor] Starting Index: " + this._index);
    hamonengine.util.logger.debug("[hamonengine.graphics.animsprite.constructor] Starting Enable Animation: " + this._enableAnimation);
  };
  $jscomp.inherits(hamonengine.graphics.animsprite, hamonengine.graphics.sprite);
  hamonengine.graphics.animsprite.prototype.clone = function $hamonengine$graphics$animsprite$$clone$() {
    return new hamonengine.graphics.animsprite(this);
  };
  hamonengine.graphics.animsprite.prototype.start = function $hamonengine$graphics$animsprite$$start$() {
    this._enableAnimation = !0;
    this._numberOfAnimationCycles = 0;
  };
  hamonengine.graphics.animsprite.prototype.stop = function $hamonengine$graphics$animsprite$$stop$() {
    this._enableAnimation = !1;
  };
  hamonengine.graphics.animsprite.prototype.pause = function $hamonengine$graphics$animsprite$$pause$() {
    this._enableAnimation = !this._enableAnimation;
  };
  hamonengine.graphics.animsprite.prototype.next = function $hamonengine$graphics$animsprite$$next$() {
    this.index++;
  };
  hamonengine.graphics.animsprite.prototype.prev = function $hamonengine$graphics$animsprite$$prev$() {
    var $index$$ = this.index - 1;
    this.index = 0 > $index$$ ? this._frames.length + $index$$ : $index$$;
  };
  hamonengine.graphics.animsprite.prototype.addFrame = function $hamonengine$graphics$animsprite$$addFrame$($frame$$) {
    hamonengine.util.logger.debug("[hamonengine.graphics.animsprite.animsprite.addFrame]");
    this._frames.push($frame$$);
  };
  hamonengine.graphics.animsprite.prototype.blendColor = function $hamonengine$graphics$animsprite$$blendColor$($r$$, $g$$, $b$$, $a$$, $blendingOps$$) {
    $r$$ = void 0 === $r$$ ? 0 : $r$$;
    $g$$ = void 0 === $g$$ ? 0 : $g$$;
    $b$$ = void 0 === $b$$ ? 0 : $b$$;
    $a$$ = void 0 === $a$$ ? 0 : $a$$;
    $blendingOps$$ = void 0 === $blendingOps$$ ? BLENDING_OPS.REPLACE : $blendingOps$$;
    for (var $i$$ = 0; $i$$ < this._frames.length; $i$$++) {
      this._frames[$i$$].blendColor($r$$, $g$$, $b$$, $a$$, $blendingOps$$);
    }
  };
  hamonengine.graphics.animsprite.prototype.adjustColorChannel = function $hamonengine$graphics$animsprite$$adjustColorChannel$($r$$, $g$$, $b$$, $a$$) {
    $r$$ = void 0 === $r$$ ? 1.0 : $r$$;
    $g$$ = void 0 === $g$$ ? 1.0 : $g$$;
    $b$$ = void 0 === $b$$ ? 1.0 : $b$$;
    $a$$ = void 0 === $a$$ ? 1.0 : $a$$;
    for (var $i$$ = 0; $i$$ < this._frames.length; $i$$++) {
      this._frames[$i$$].adjustColorChannel($r$$, $g$$, $b$$, $a$$);
    }
  };
  hamonengine.graphics.animsprite.prototype.draw = function $hamonengine$graphics$animsprite$$draw$($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$, $height$$) {
    $width$$ = void 0 === $width$$ ? null : $width$$;
    $height$$ = void 0 === $height$$ ? null : $height$$;
    var $timeSinceLastFrame$$ = this._timeSinceLastFrame + $elapsedTimeInMilliseconds$$;
    if (this._enableAnimation) {
      var $currentFrame_numberOfAnimationCycles_numberOfFrames$$ = parseInt($timeSinceLastFrame$$ / this.animationRate, 10);
      $currentFrame_numberOfAnimationCycles_numberOfFrames$$ = this.index + $currentFrame_numberOfAnimationCycles_numberOfFrames$$;
      -1 < this.animationCycles && (this._numberOfAnimationCycles += parseInt($currentFrame_numberOfAnimationCycles_numberOfFrames$$ / this._frames.length, 10), this._enableAnimation = this._numberOfAnimationCycles <= this.animationCycles);
      this.index = $currentFrame_numberOfAnimationCycles_numberOfFrames$$;
    }
    0 < this._frames.length && ($currentFrame_numberOfAnimationCycles_numberOfFrames$$ = this._frames[this.index], $currentFrame_numberOfAnimationCycles_numberOfFrames$$.copyProperties(this), $currentFrame_numberOfAnimationCycles_numberOfFrames$$.draw($layer$$, $elapsedTimeInMilliseconds$$, $x$$, $y$$, $width$$ || $currentFrame_numberOfAnimationCycles_numberOfFrames$$.width, $height$$ || $currentFrame_numberOfAnimationCycles_numberOfFrames$$.height));
    this._timeSinceLastFrame = $timeSinceLastFrame$$ % this.animationRate;
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.animsprite.prototype, {index:{configurable:!0, enumerable:!0, get:function() {
    return this._index;
  }, set:function($v$$) {
    this._index = $v$$ % this._frames.length || 0;
  }}, animationRate:{configurable:!0, enumerable:!0, get:function() {
    return this._animationRate;
  }, set:function($v$$) {
    this._animationRate = 0 < $v$$ ? $v$$ : 1;
  }}, animationCycles:{configurable:!0, enumerable:!0, get:function() {
    return this._animationCycles;
  }, set:function($v$$) {
    this._animationCycles = $v$$;
    this._enableAnimation = !0;
  }}});
})();
hamonengine.graphics = hamonengine.graphics || {};
(function() {
  hamonengine.graphics.spritesheet = function $hamonengine$graphics$spritesheet$($options$$) {
    this._imageResource = new hamonengine.graphics.imageext;
    this._sprites = {};
    this._spriteIndex = [];
  };
  hamonengine.graphics.spritesheet.prototype.load = function $hamonengine$graphics$spritesheet$$load$($spriteSheetMetadata$$) {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$jscomp$6_i$22_i$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              if ("string" !== typeof $spriteSheetMetadata$$) {
                $$jscomp$generator$state$$ = 1;
                break;
              }
              $$jscomp$generator$state$$ = 2;
              return {value:connect.get($spriteSheetMetadata$$), done:!1};
            case 2:
              if (void 0 === $$jscomp$generator$throw$arg$$) {
                $$jscomp$generator$state$$ = 3;
                break;
              }
              $$jscomp$generator$state$$ = -1;
              throw $$jscomp$generator$throw$arg$$;
            case 3:
              $spriteSheetMetadataResponse$$ = $$jscomp$generator$next$arg25$$ = $$jscomp$generator$next$arg$jscomp$6_i$22_i$$, $spriteSheetMetadata$$ = JSON.parse($spriteSheetMetadataResponse$$.data);
            case 1:
              $resourceLoadingPromise$$ = $$jscomp$async$this$$._imageResource.load($spriteSheetMetadata$$.spritesheetUrl);
              for ($$jscomp$generator$next$arg$jscomp$6_i$22_i$$ = 0; $$jscomp$generator$next$arg$jscomp$6_i$22_i$$ < $spriteSheetMetadata$$.sprites.length; $$jscomp$generator$next$arg$jscomp$6_i$22_i$$++) {
                $$jscomp$generator$throw$arg$$ = $spriteSheetMetadata$$.sprites[$$jscomp$generator$next$arg$jscomp$6_i$22_i$$], $$jscomp$async$this$$._spriteIndex.push($$jscomp$generator$throw$arg$$.name), $$jscomp$async$this$$._sprites[$$jscomp$generator$throw$arg$$.name] = new hamonengine.graphics.sprite({image:$$jscomp$async$this$$._imageResource, name:$$jscomp$generator$throw$arg$$.name, dimensions:new hamonengine.geometry.rect($$jscomp$generator$throw$arg$$.x, $$jscomp$generator$throw$arg$$.y, 
                $$jscomp$generator$throw$arg$$.width, $$jscomp$generator$throw$arg$$.height)});
              }
              for ($$jscomp$generator$next$arg$jscomp$6_i$22_i$$ = 0; $$jscomp$generator$next$arg$jscomp$6_i$22_i$$ < $spriteSheetMetadata$$.animSprites.length; $$jscomp$generator$next$arg$jscomp$6_i$22_i$$++) {
                $$jscomp$generator$throw$arg$$ = $spriteSheetMetadata$$.animSprites[$$jscomp$generator$next$arg$jscomp$6_i$22_i$$];
                for (var $animatedSprite$$ = new hamonengine.graphics.animsprite({animationRate:$$jscomp$generator$throw$arg$$.animationRate}), $j$$ = 0; $j$$ < $$jscomp$generator$throw$arg$$.frames.length; $j$$++) {
                  var $frameMetadata$$ = $$jscomp$generator$throw$arg$$.frames[$j$$];
                  $animatedSprite$$.addFrame(new hamonengine.graphics.sprite({image:$$jscomp$async$this$$._imageResource, name:$frameMetadata$$.name, dimensions:new hamonengine.geometry.rect($frameMetadata$$.x, $frameMetadata$$.y, $frameMetadata$$.width, $frameMetadata$$.height)}));
                }
                $$jscomp$async$this$$._spriteIndex.push($$jscomp$generator$throw$arg$$.name);
                $$jscomp$async$this$$._sprites[$$jscomp$generator$throw$arg$$.name] = $animatedSprite$$;
              }
              $$jscomp$generator$state$$ = -1;
              return {value:$resourceLoadingPromise$$, done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $resourceLoadingPromise$$, $spriteSheetMetadataResponse$$, $$jscomp$generator$next$arg25$$, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.graphics.spritesheet.prototype.getSprite = function $hamonengine$graphics$spritesheet$$getSprite$($spriteName$$) {
    return this._sprites[$spriteName$$].clone();
  };
  hamonengine.graphics.spritesheet.prototype.getSpriteByOrdinal = function $hamonengine$graphics$spritesheet$$getSpriteByOrdinal$($index$$) {
    return this._sprites[this._spriteIndex[$index$$]].clone();
  };
  $jscomp.global.Object.defineProperties(hamonengine.graphics.spritesheet.prototype, {length:{configurable:!0, enumerable:!0, get:function() {
    return this._spriteIndex.length;
  }}, isLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._imageResource.isLoaded();
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.object2d = function $hamonengine$entities$object2d$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    this._name = $options$$.name || "";
    this._boundingShape = $options$$.boundingShape;
    this._width = $options$$.width || 0;
    this._height = $options$$.height || 0;
    this._zindex = $options$$.zindex || 0;
    this._movementRate = $options$$.movementRate || 0;
    this._position = $options$$.position || new hamonengine.geometry.vector2;
    this._direction = $options$$.direction || new hamonengine.geometry.vector2;
    this._theta = $options$$.theta || 0.0;
    this._isSolid = void 0 === $options$$.isSolid ? !0 : !1;
    this._isMoveable = void 0 === $options$$.isMoveable ? !1 : !0;
    this._isVisible = void 0 === $options$$.isVisible ? !0 : !1;
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Name: " + this.name);
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Starting Dimensions {Width: " + this.width + ", Height: " + this.height + "}");
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Starting Direction: {x: " + this.direction.x + ", y: " + this.direction.y + "}");
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Starting Position: {x: " + this.position.x + ", y: " + this.position.y + "}");
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Starting Theta: " + this.theta);
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] Movement Rate: " + this._movementRate);
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] isSolid: " + this.isSolid);
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] isMoveable: " + this.isMoveable);
    hamonengine.util.logger.debug("[hamonengine.entities.object2d.constructor] isVisible: " + this.isVisible);
  };
  hamonengine.entities.object2d.prototype.move = function $hamonengine$entities$object2d$$move$($elapsedTimeInMilliseconds$$, $movementVector$$) {
    this.isMoveable && ($movementVector$$ = (void 0 === $movementVector$$ ? null : $movementVector$$) || this.calcMove($elapsedTimeInMilliseconds$$), this.position.x += $movementVector$$.x, this.position.y += $movementVector$$.y);
  };
  hamonengine.entities.object2d.prototype.calcMove = function $hamonengine$entities$object2d$$calcMove$($elapsedTimeInMilliseconds$$) {
    return new hamonengine.geometry.vector2(this._movementRate * this.direction.x * $elapsedTimeInMilliseconds$$, this._movementRate * this.direction.y * $elapsedTimeInMilliseconds$$);
  };
  hamonengine.entities.object2d.prototype.isCollision = function $hamonengine$entities$object2d$$isCollision$($object$$) {
    return this.boundingShape.translate(this.position).isCollision($object$$);
  };
  hamonengine.entities.object2d.prototype.isContained = function $hamonengine$entities$object2d$$isContained$($targetObject$$) {
    return this.boundingShape.isContained($targetObject$$.position, $targetObject$$.boundingShape);
  };
  hamonengine.entities.object2d.prototype.render = function $hamonengine$entities$object2d$$render$($layer$$, $elapsedTimeInMilliseconds$$) {
  };
  hamonengine.entities.object2d.prototype.toString = function $hamonengine$entities$object2d$$toString$() {
    return "{name: '" + this.name + "', position: '" + this.position + "'}";
  };
  hamonengine.entities.object2d.prototype.onEnvironmentCollision = function $hamonengine$entities$object2d$$onEnvironmentCollision$($position$$, $environmentObject$$) {
    this._position = $position$$;
    return !0;
  };
  hamonengine.entities.object2d.prototype.onObjectCollision = function $hamonengine$entities$object2d$$onObjectCollision$($x$$, $y$$, $object$$) {
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.object2d.prototype, {name:{configurable:!0, enumerable:!0, get:function() {
    return this._name;
  }}, position:{configurable:!0, enumerable:!0, get:function() {
    return this._position;
  }, set:function($v$$) {
    this._position = $v$$;
  }}, direction:{configurable:!0, enumerable:!0, get:function() {
    return this._direction;
  }}, theta:{configurable:!0, enumerable:!0, get:function() {
    return this._theta || 0.0;
  }}, width:{configurable:!0, enumerable:!0, get:function() {
    return this._width;
  }}, height:{configurable:!0, enumerable:!0, get:function() {
    return this._height;
  }}, zIndex:{configurable:!0, enumerable:!0, get:function() {
    return this._zindex;
  }, set:function($v$$) {
    this._zindex = $v$$;
  }}, boundingShape:{configurable:!0, enumerable:!0, get:function() {
    return this._boundingShape = this._boundingShape || new hamonengine.geometry.rect(0, 0, this.width, this.height);
  }}, isMoveable:{configurable:!0, enumerable:!0, get:function() {
    return this._isMoveable;
  }}, isSolid:{configurable:!0, enumerable:!0, get:function() {
    return this._isSolid;
  }}, isVisible:{configurable:!0, enumerable:!0, get:function() {
    return this._isVisible;
  }, set:function($v$$) {
    this._isVisible = $v$$;
  }}});
})();
hamonengine.entities = hamonengine.entities || {};
(function() {
  hamonengine.entities.cell = function $hamonengine$entities$cell$($options$$) {
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.entities.object2d.call(this, $options$$);
    this._movementRate = 0;
    this._direction = new hamonengine.geometry.vector2;
    this._theta = 0;
    this._children = [];
    this._objects = [];
    this._zIndexSorter = new hamonengine.math.sort({compareFunc:function($a$$, $b$$) {
      return $a$$ === $b$$ ? 0 : $a$$.zIndex < $b$$.zIndex ? -1 : 1;
    }});
  };
  $jscomp.inherits(hamonengine.entities.cell, hamonengine.entities.object2d);
  hamonengine.entities.cell.prototype.addChild = function $hamonengine$entities$cell$$addChild$($child$$) {
    this._children.push($child$$);
  };
  hamonengine.entities.cell.prototype.addObject = function $hamonengine$entities$cell$$addObject$($object$$) {
    this._objects.push($object$$);
  };
  hamonengine.entities.cell.prototype.addObjects = function $hamonengine$entities$cell$$addObjects$($objects$$) {
    for (var $i$$ = 0; $i$$ < $objects$$.length; $i$$++) {
      this._objects.push($objects$$[$i$$]);
    }
  };
  hamonengine.entities.cell.prototype.process = function $hamonengine$entities$cell$$process$($elapsedTimeInMilliseconds$$) {
    if (this.objects) {
      for (var $collisionsEdges$$ = new Set, $i$$ = 0; $i$$ < this.objects.length; $i$$++) {
        var $object$$ = this.objects[$i$$];
        if ($object$$.isMoveable && ($object$$.move($elapsedTimeInMilliseconds$$), this.isSolid)) {
          var $adjustedPosition_i$23$$ = hamonengine.geometry.vector2.clone($object$$.position), $collisionVector_siblingObject$$ = this.isContained($object$$);
          0 > $collisionVector_siblingObject$$.x ? $adjustedPosition_i$23$$.x = this.boundingShape.x - $object$$.boundingShape.x : 0 < $collisionVector_siblingObject$$.x && ($adjustedPosition_i$23$$.x = this.boundingShape.width - $object$$.boundingShape.right);
          0 > $collisionVector_siblingObject$$.y ? $adjustedPosition_i$23$$.y = this.boundingShape.y - $object$$.boundingShape.y : 0 < $collisionVector_siblingObject$$.y && ($adjustedPosition_i$23$$.y = this.boundingShape.height - $object$$.boundingShape.bottom);
          if (!$object$$.onEnvironmentCollision($adjustedPosition_i$23$$, this)) {
            break;
          }
        }
        for ($adjustedPosition_i$23$$ = 0; $adjustedPosition_i$23$$ < this.objects.length; $adjustedPosition_i$23$$++) {
          if ($collisionVector_siblingObject$$ = this.objects[$adjustedPosition_i$23$$], $object$$ !== $collisionVector_siblingObject$$) {
            var $edgeName$$ = $object$$.name + "->" + $collisionVector_siblingObject$$.name;
            $collisionsEdges$$.has($edgeName$$) || ($collisionsEdges$$.add($edgeName$$), $collisionsEdges$$.add($collisionVector_siblingObject$$.name + "->" + $object$$.name));
          }
        }
      }
    }
  };
  hamonengine.entities.cell.prototype.render = function $hamonengine$entities$cell$$render$($layer$$, $elapsedTimeInMilliseconds$$) {
    if (this.objects && (this._zIndexSorter.quickSort(this._objects), this.objects)) {
      for (var $i$$ = 0; $i$$ < this.objects.length; $i$$++) {
        this.objects[$i$$].render($layer$$, $elapsedTimeInMilliseconds$$);
      }
    }
  };
  $jscomp.global.Object.defineProperties(hamonengine.entities.cell.prototype, {children:{configurable:!0, enumerable:!0, get:function() {
    return this._children;
  }}, objects:{configurable:!0, enumerable:!0, get:function() {
    return this._objects;
  }}});
})();
hamonengine.core = hamonengine.core || {};
(function() {
  var $ENGINE_STATES_NAMES$$ = ["STOPPED", "STARTED", "LOADING", "RUNNING"];
  hamonengine.core.engine = function $hamonengine$core$engine$($options$$) {
    var $$jscomp$this$$ = this;
    $options$$ = void 0 === $options$$ ? {} : $options$$;
    hamonengine.util.logger.info("HamonEngine -- Using version: 0.1.1");
    this._movementRate = $options$$.movementRate || 0.25;
    this._size = $options$$.size || 64;
    this._showFPS = void 0 !== $options$$.showFPS ? $options$$.showFPS : !1;
    this._syncFrames = void 0 !== $options$$.syncFrames ? $options$$.syncFrames : !1;
    this._splashScreenWait = void 0 !== $options$$.splashScreenWait ? $options$$.splashScreenWait : 500;
    this._detectCanvas = void 0 !== $options$$.detectCanvas ? $options$$.detectCanvas : !1;
    this._allowDocumentEventBinding = void 0 !== $options$$.allowDocumentEventBinding ? $options$$.allowDocumentEventBinding : !1;
    this._animationId = this._lastFrameTimeStamp = this._startTimeStamp = this._state = 0;
    this._fpsCounter = new fpscounter;
    this._layers = {};
    var $canvasCollection$$ = $options$$.canvas || [];
    if (this._detectCanvas && 0 === $canvasCollection$$.length) {
      hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] DetectCanvas: true.  Attempting to detect all canvas."), Object.entries(document.getElementsByTagName("canvas")).forEach(function($$jscomp$destructuring$var14_canvasName$jscomp$1_key$$) {
        var $$jscomp$destructuring$var15_value$$ = $jscomp.makeIterator($$jscomp$destructuring$var14_canvasName$jscomp$1_key$$);
        $$jscomp$destructuring$var14_canvasName$jscomp$1_key$$ = $$jscomp$destructuring$var15_value$$.next().value;
        $$jscomp$destructuring$var15_value$$ = $$jscomp$destructuring$var15_value$$.next().value;
        $$jscomp$destructuring$var14_canvasName$jscomp$1_key$$ = $$jscomp$destructuring$var15_value$$.getAttribute("name") || "canvas" + $$jscomp$destructuring$var14_canvasName$jscomp$1_key$$;
        $$jscomp$this$$._layers[$$jscomp$destructuring$var14_canvasName$jscomp$1_key$$] = new hamonengine.graphics.layer({name:$$jscomp$destructuring$var14_canvasName$jscomp$1_key$$, canvas:$$jscomp$destructuring$var15_value$$, allowEventBinding:$$jscomp$destructuring$var15_value$$.dataset.alloweventbinding, enableImageSmoothing:$$jscomp$destructuring$var15_value$$.dataset.enableimagesmoothing, clipToViewPort:$$jscomp$destructuring$var15_value$$.dataset.alloweventbinding});
      });
    } else {
      hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] DetectCanvas: false.  Using collection of options.canvas.");
      for (var $index$$ = 0, $i$$ = 0; $i$$ < $canvasCollection$$.length; $i$$++) {
        var $canvas$$ = $canvasCollection$$[$i$$], $canvasName$$ = $canvas$$.name || "canvas" + $index$$++;
        this._layers[$canvasName$$] = new hamonengine.graphics.layer({name:$canvasName$$, canvasId:$canvas$$.id, viewPort:$canvas$$.viewPort, allowEventBinding:$canvas$$.allowEventBinding, enableImageSmoothing:$options$$.enableImageSmoothing, clipToViewPort:$canvas$$.clipToViewPort});
      }
    }
    this._resourcesLoaded = !1;
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] MovementRate: " + this._movementRate);
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] State: " + $ENGINE_STATES_NAMES$$[this._state]);
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] SyncFrames: " + (this.syncFrames ? "Enabled" : "Disabled"));
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] SplashScreen Wait Time: " + this._splashScreenWait + " milliseconds.");
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] Global States");
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] hamonengine.geometry.settings.collisionDetection.floor: " + hamonengine.geometry.settings.collisionDetection.floor);
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] hamonengine.geometry.settings.collisionDetection.limit: " + hamonengine.geometry.settings.collisionDetection.limit);
    hamonengine.util.logger.debug("[hamonengine.core.engine.constructor] hamonengine.geometry.settings.coordinateSystem: " + hamonengine.geometry.settings.coordinateSystem);
  };
  hamonengine.core.engine.prototype.getLayer = function $hamonengine$core$engine$$getLayer$($name$$) {
    return this._layers[$name$$];
  };
  hamonengine.core.engine.prototype.load = function $hamonengine$core$engine$$load$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              hamonengine.util.logger.info("[hamonengine.core.engine.load]");
              $preloadPromise$$ = new Promise(function($resolve$$) {
                $$jscomp$async$this$$.onPreload() ? setTimeout(function() {
                  return $resolve$$();
                }, $$jscomp$async$this$$._splashScreenWait) : $resolve$$();
              });
              $$jscomp$async$this$$._state = 2;
              hamonengine.util.logger.debug("[hamonengine.core.engine.load] State: " + $ENGINE_STATES_NAMES$$[$$jscomp$async$this$$._state]);
              try {
                $eventBindingPromise$$ = $$jscomp$async$this$$.onEventBinding();
                if ($eventBindingPromise$$ instanceof Promise) {
                  $$jscomp$generator$state$$ = 3;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw "onEventBinding is not returning a promise!  This event must return an unhandled promise.";
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 3:
              try {
                return hamonengine.util.logger.warning("[hamonengine.core.engine.load] Engine is paused, waiting for event binding to resolve..."), $$jscomp$generator$state$$ = 4, {value:$eventBindingPromise$$, done:!1};
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 4:
              try {
                if (void 0 === $$jscomp$generator$throw$arg$$) {
                  $$jscomp$generator$state$$ = 5;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw $$jscomp$generator$throw$arg$$;
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 5:
              try {
                hamonengine.util.logger.info("[hamonengine.core.engine.load] Engine has resumed loading, event binding has completed.");
                $loadingResource$$ = $$jscomp$async$this$$.onloadResources();
                if ($loadingResource$$ instanceof Promise) {
                  $$jscomp$generator$state$$ = 6;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw "onloadResources is not returning a promise!  This event must return an unhandled promise.";
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 6:
              try {
                return hamonengine.util.logger.warning("[hamonengine.core.engine.load] Engine is paused, waiting for resources to resolve..."), $$jscomp$generator$state$$ = 7, {value:$loadingResource$$, done:!1};
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 7:
              try {
                if (void 0 === $$jscomp$generator$throw$arg$$) {
                  $$jscomp$generator$state$$ = 8;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw $$jscomp$generator$throw$arg$$;
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 8:
              try {
                return $$jscomp$async$this$$._resourcesLoaded = !0, hamonengine.util.logger.info("[hamonengine.core.engine.load] Engine has resumed loading, resource loading completed."), $$jscomp$generator$state$$ = 9, {value:$preloadPromise$$, done:!1};
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 9:
              try {
                if (void 0 === $$jscomp$generator$throw$arg$$) {
                  $$jscomp$generator$state$$ = 10;
                  break;
                }
                $$jscomp$generator$state$$ = -1;
                throw $$jscomp$generator$throw$arg$$;
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 10:
              try {
                hamonengine.util.logger.info("[hamonengine.core.engine.load] Preload completed.");
                $$jscomp$generator$state$$ = 2;
                break;
              } catch ($$jscomp$generator$error$$) {
                $$jscomp$generator$global$error$$ = $$jscomp$generator$error$$;
                $$jscomp$generator$state$$ = 1;
                break;
              }
            case 1:
              $error$$ = $$jscomp$generator$global$error$$, console.error("[hamonengine.core.engine.load] Resources could not be loaded due to a failure! Stopping the engine."), console.error($error$$), $$jscomp$async$this$$.stop({reasons:"A critical error occured during resource loading."});
            case 2:
              return $$jscomp$generator$state$$ = -1, {value:$$jscomp$async$this$$, done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $error$$, $loadingResource$$, $eventBindingPromise$$, $$jscomp$generator$global$error$$, $preloadPromise$$, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.core.engine.prototype.start = function $hamonengine$core$engine$$start$() {
    hamonengine.util.logger.info("[hamonengine.core.engine.start]");
    2 === this._state && (this._state = 1, hamonengine.util.logger.debug("[hamonengine.core.engine.start] State: " + $ENGINE_STATES_NAMES$$[this._state]), this.fpsCounter.start(), this.onDraw(0));
    return this;
  };
  hamonengine.core.engine.prototype.stop = function $hamonengine$core$engine$$stop$($$jscomp$destructuring$var16_reasons$$) {
    $$jscomp$destructuring$var16_reasons$$ = (void 0 === $$jscomp$destructuring$var16_reasons$$ ? {reasons:"Stopped By User"} : $$jscomp$destructuring$var16_reasons$$).reasons;
    hamonengine.util.logger.info("[hamonengine.core.engine.stop]");
    window.cancelAnimationFrame(this._animationId);
    this._state = this._startTimeStamp = this._animationId = 0;
    hamonengine.util.logger.debug("[hamonengine.core.engine.stop] State: " + $ENGINE_STATES_NAMES$$[this._state]);
    this.onStop($$jscomp$destructuring$var16_reasons$$);
    return this;
  };
  hamonengine.core.engine.prototype.onPreload = function $hamonengine$core$engine$$onPreload$() {
    hamonengine.util.logger.info("[hamonengine.core.engine.onPreload]");
    return !1;
  };
  hamonengine.core.engine.prototype.onloadResources = function $hamonengine$core$engine$$onloadResources$() {
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return hamonengine.util.logger.info("[hamonengine.core.engine.onloadResources]"), $$jscomp$generator$state$$ = -1, {value:Promise.resolve(), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.core.engine.prototype.onEventBinding = function $hamonengine$core$engine$$onEventBinding$() {
    var $$jscomp$async$this$$ = this;
    return $jscomp.executeAsyncGenerator(function $jscomp$async$generator() {
      function $$jscomp$generator$impl$$($$jscomp$generator$next$arg$$, $$jscomp$generator$throw$arg$$) {
        for (;;) {
          switch($$jscomp$generator$state$$) {
            case 0:
              return $$jscomp$generator$state$$ = -1, {value:new Promise(function($resolve$$, $reject$$) {
                window.addEventListener("DOMContentLoaded", function($event$$) {
                  var $bindEvents$$ = function $$bindEvents$$$($elementToBind$$, $eventObject$$) {
                    var $mouseEvent$$ = function $$mouseEvent$$$($type$$, $e$$) {
                      return $$jscomp$async$this$$.onMouseEvent($type$$, new hamonengine.geometry.vector2($e$$.offsetX, $e$$.offsetY), $e$$, $eventObject$$);
                    }, $touchEvent$$ = function $$touchEvent$$$($type$$, $e$$) {
                      var $touches$$ = [], $position$$ = $eventObject$$.position;
                      if ($position$$) {
                        for (var $i$$ = 0; $i$$ < $e$$.touches.length; $i$$++) {
                          $touches$$.push({left:$e$$.touches[$i$$].clientX - $position$$.x, top:$e$$.touches[$i$$].clientY - $position$$.y});
                        }
                        $$jscomp$async$this$$.onTouchEvent($type$$, $e$$, $touches$$, $eventObject$$);
                      }
                    };
                    $elementToBind$$.addEventListener("keyup", function($e$$) {
                      return $$jscomp$async$this$$.onKeyEvent("up", $e$$.code, $e$$, $eventObject$$);
                    });
                    $elementToBind$$.addEventListener("keydown", function($e$$) {
                      return $$jscomp$async$this$$.onKeyEvent("down", $e$$.code, $e$$, $eventObject$$);
                    });
                    $elementToBind$$.addEventListener("click", function($e$$) {
                      return $$jscomp$async$this$$.onMouseClick(new hamonengine.geometry.vector2($e$$.offsetX, $e$$.offsetY), $e$$, $eventObject$$);
                    });
                    $elementToBind$$.addEventListener("mouseup", function($e$$) {
                      return $mouseEvent$$("up", $e$$);
                    });
                    $elementToBind$$.addEventListener("mousedown", function($e$$) {
                      return $mouseEvent$$("down", $e$$);
                    });
                    $elementToBind$$.addEventListener("mousemove", function($e$$) {
                      return $mouseEvent$$("move", $e$$);
                    });
                    $elementToBind$$.addEventListener("touchstart", function($e$$) {
                      return $touchEvent$$("start", $e$$);
                    }, {passive:!1});
                    $elementToBind$$.addEventListener("touchmove", function($e$$) {
                      return $touchEvent$$("move", $e$$);
                    }, {passive:!1});
                    $elementToBind$$.addEventListener("touchend", function($e$$) {
                      return $$jscomp$async$this$$.onTouchEnd($e$$, $eventObject$$);
                    });
                    $elementToBind$$.addEventListener("touchcancel", function($e$$) {
                      return $$jscomp$async$this$$.onTouchCancel($e$$, $eventObject$$);
                    });
                  };
                  $$jscomp$async$this$$.allowDocumentEventBinding && $bindEvents$$(document, $$jscomp$async$this$$);
                  $$jscomp$async$this$$.layers.forEach(function($layer$$) {
                    $layer$$.allowEventBinding && $bindEvents$$($layer$$.canvas, $layer$$);
                  });
                });
                $resolve$$();
              }), done:!0};
            default:
              return {value:void 0, done:!0};
          }
        }
      }
      var $$jscomp$generator$state$$ = 0, $iterator$$ = {next:function($arg$$) {
        return $$jscomp$generator$impl$$($arg$$, void 0);
      }, throw:function($arg$$) {
        return $$jscomp$generator$impl$$(void 0, $arg$$);
      }, return:function($arg$$) {
        throw Error("Not yet implemented");
      }};
      $jscomp.initSymbolIterator();
      $iterator$$[Symbol.iterator] = function $$iterator$$$Symbol$iterator$() {
        return this;
      };
      return $iterator$$;
    }());
  };
  hamonengine.core.engine.prototype.onMouseClick = function $hamonengine$core$engine$$onMouseClick$($v$$, $e$$, $layer$$) {
    hamonengine.util.logger.debug("[hamonengine.core.engine.onMouseClick] '" + $e$$ + "'");
  };
  hamonengine.core.engine.prototype.onMouseEvent = function $hamonengine$core$engine$$onMouseEvent$($type$$, $v$$, $e$$, $layer$$) {
    hamonengine.util.logger.debug("[hamonengine.core.engine.onMouseEvent] Type: '" + $type$$ + "' '" + $v$$.toString() + "'");
  };
  hamonengine.core.engine.prototype.onKeyEvent = function $hamonengine$core$engine$$onKeyEvent$($type$$, $keyCode$$, $e$$, $layer$$) {
    $e$$ && $e$$.preventDefault();
    hamonengine.util.logger.debug("[hamonengine.core.engine.onKeyEvent] Type: '" + $type$$ + "' '" + $keyCode$$ + "'");
  };
  hamonengine.core.engine.prototype.onTouchEvent = function $hamonengine$core$engine$$onTouchEvent$($type$$, $e$$, $touches$$, $layer$$) {
    $e$$ && $e$$.preventDefault();
    hamonengine.util.logger.debug("[hamonengine.core.engine.onTouchEvent] Type: '" + $type$$ + "' '" + $e$$ + "'");
  };
  hamonengine.core.engine.prototype.onTouchEnd = function $hamonengine$core$engine$$onTouchEnd$($e$$, $layer$$) {
    $e$$ && $e$$.preventDefault();
    hamonengine.util.logger.debug("[hamonengine.core.engine.onTouchEnd] '" + $e$$ + "'");
  };
  hamonengine.core.engine.prototype.onTouchCancel = function $hamonengine$core$engine$$onTouchCancel$($e$$, $layer$$) {
    $e$$ && $e$$.preventDefault();
    hamonengine.util.logger.debug("[hamonengine.core.engine.onTouchCancel] '" + $e$$ + "'");
  };
  hamonengine.core.engine.prototype.onDraw = function $hamonengine$core$engine$$onDraw$($timestampInMilliseconds$$) {
    var $$jscomp$this$$ = this;
    $timestampInMilliseconds$$ = $timestampInMilliseconds$$ || 0;
    this._startTimeStamp || (this._startTimeStamp = $timestampInMilliseconds$$);
    var $elapsedTimeInMilliseconds$$ = $timestampInMilliseconds$$ - this._lastFrameTimeStamp;
    try {
      var $processingComplete$$ = !1;
      setTimeout(function() {
        $$jscomp$this$$.onProcessingFrame($elapsedTimeInMilliseconds$$);
        $processingComplete$$ = !0;
      }, 1);
      this._animationId = window.requestAnimationFrame(function($scopedTimestampInMS$$) {
        $$jscomp$this$$._state = 3;
        $$jscomp$this$$.syncFrames && !$processingComplete$$ || $$jscomp$this$$.onFrame($elapsedTimeInMilliseconds$$);
        $$jscomp$this$$.onDraw($scopedTimestampInMS$$);
      });
    } catch ($exception$$) {
      this.stop(), hamonengine.util.logger.debug($exception$$);
    }
    this._lastFrameTimeStamp = $timestampInMilliseconds$$;
    return this;
  };
  hamonengine.core.engine.prototype.onFrame = function $hamonengine$core$engine$$onFrame$($elapsedTimeInMilliseconds$$) {
    return this;
  };
  hamonengine.core.engine.prototype.onProcessingFrame = function $hamonengine$core$engine$$onProcessingFrame$($elapsedTimeInMilliseconds$$) {
    return this;
  };
  hamonengine.core.engine.prototype.onStop = function $hamonengine$core$engine$$onStop$($reasons$$) {
    return this;
  };
  $jscomp.global.Object.defineProperties(hamonengine.core.engine.prototype, {primaryLayer:{configurable:!0, enumerable:!0, get:function() {
    return this._layers.canvas0;
  }}, resourcesLoaded:{configurable:!0, enumerable:!0, get:function() {
    return this._resourcesLoaded;
  }}, fpsCounter:{configurable:!0, enumerable:!0, get:function() {
    return this._fpsCounter;
  }}, layers:{configurable:!0, enumerable:!0, get:function() {
    return Object.values(this._layers);
  }}, syncFrames:{configurable:!0, enumerable:!0, get:function() {
    return this._syncFrames;
  }, set:function($v$$) {
    this._syncFrames = $v$$;
  }}, allowDocumentEventBinding:{configurable:!0, enumerable:!0, get:function() {
    return this._allowDocumentEventBinding;
  }}});
})();

